/**
 * Deployment Service API
 * This is the API Documentation for the mbed deployment service which is part of the update service.
 *
 * OpenAPI spec version: 0.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import request = require('request');
import http = require('http');

let defaultBasePath = 'http://api.mbedcloud.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

export class CampaignDeviceMetadataSerializer {
    /**
    * The description of the object
    */
    'description': string;
    /**
    * The update campaign to which this device belongs
    */
    'campaign': string;
    /**
    * The time the object was created
    */
    'createdAt': Date;
    /**
    * The API resource entity
    */
    'object': string;
    /**
    * The time the object was updated
    */
    'updatedAt': Date;
    /**
    * The ID of the channel used to communicated with the device
    */
    'mechanism': string;
    /**
    * The name of the object
    */
    'name': string;
    /**
    * The entity instance signature
    */
    'etag': Date;
    /**
    * The address of the Connector to use
    */
    'mechanismUrl': string;
    /**
    * The state of the deployment
    */
    'deploymentState': CampaignDeviceMetadataSerializer.DeploymentStateEnum;
    /**
    * The ID of the metadata concerning this device/campaign
    */
    'id': string;
    /**
    * The ID of the device to deploy
    */
    'deviceId': string;
}

export namespace CampaignDeviceMetadataSerializer {
    export enum DeploymentStateEnum {
        Pending = <any> 'pending',
        UpdatedDeviceCatalog = <any> 'updated_device_catalog',
        UpdatedConnectorChannel = <any> 'updated_connector_channel',
        Deployed = <any> 'deployed',
        Manifestremoved = <any> 'manifestremoved'
    }
}
export class UpdateCampaignSerializer {
    /**
    * An optional description of the campaign
    */
    'description': string;
    /**
    * The state of the campaign
    */
    'state': UpdateCampaignSerializer.StateEnum;
    /**
    * The updating IAM user ID
    */
    'updatingUserId': string;
    /**
    * The time the object was created
    */
    'createdAt': Date;
    /**
    * The API resource entity
    */
    'object': string;
    'rootManifestId': string;
    /**
    * DEPRECATED: The ID of the campaign
    */
    'campaignId': string;
    /**
    * The updating account ID
    */
    'updatingAccountId': string;
    /**
    * The time the object was updated
    */
    'updatedAt': Date;
    /**
    * The timestamp at which update campaign scheduled to start
    */
    'when': Date;
    /**
    * The timestamp when the update campaign finished
    */
    'finished': Date;
    /**
    * The entity instance signature
    */
    'etag': Date;
    'rootManifestUrl': string;
    /**
    * The gateway client API key
    */
    'updatingApiKey': string;
    /**
    * The ID of the campaign
    */
    'id': string;
    /**
    * The filter for the devices the campaign will target
    */
    'deviceFilter': string;
    /**
    * A name for this campaign
    */
    'name': string;
}

export namespace UpdateCampaignSerializer {
    export enum StateEnum {
        Draft = <any> 'draft',
        Scheduled = <any> 'scheduled',
        Devicefetch = <any> 'devicefetch',
        Devicecopy = <any> 'devicecopy',
        Devicecopycomplete = <any> 'devicecopycomplete',
        Publishing = <any> 'publishing',
        Deploying = <any> 'deploying',
        Deployed = <any> 'deployed',
        Manifestremoved = <any> 'manifestremoved',
        Expired = <any> 'expired'
    }
}
export class UpdateCampaignStatusSerializer {
    'directDevices': string;
    'connectorDevices': string;
    /**
    * An optional description of the campaign
    */
    'description': string;
    /**
    * The state of the campaign
    */
    'state': UpdateCampaignStatusSerializer.StateEnum;
    /**
    * The updating IAM user ID
    */
    'updatingUserId': string;
    /**
    * The time the object was created
    */
    'createdAt': Date;
    'totalDevices': string;
    'campaigndevicemetadataSet': Array<CampaignDeviceMetadataSerializer>;
    /**
    * DEPRECATED: The ID of the campaign
    */
    'campaignId': string;
    'deployedDevices': string;
    /**
    * The time the object was updated
    */
    'updatedAt': Date;
    /**
    * The timestamp at which campaign is scheduled to start
    */
    'when': Date;
    /**
    * The timestamp when the update campaign finished
    */
    'finished': Date;
    'rootManifestUrl': string;
    /**
    * The gateway client API key
    */
    'updatingApiKey': string;
    /**
    * The updating account ID
    */
    'updatingAccountId': string;
    /**
    * The filter for the devices the campaign will target
    */
    'deviceFilter': string;
    /**
    * A name for this campaign
    */
    'name': string;
}

export namespace UpdateCampaignStatusSerializer {
    export enum StateEnum {
        Draft = <any> 'draft',
        Scheduled = <any> 'scheduled',
        Devicefetch = <any> 'devicefetch',
        Devicecopy = <any> 'devicecopy',
        Devicecopycomplete = <any> 'devicecopycomplete',
        Publishing = <any> 'publishing',
        Deploying = <any> 'deploying',
        Deployed = <any> 'deployed',
        Manifestremoved = <any> 'manifestremoved',
        Expired = <any> 'expired'
    }
}
export class WriteCampaignDeviceMetadataSerializer {
    /**
    * The description of the object
    */
    'description': string;
    /**
    * The update campaign to which this device belongs
    */
    'campaign': string;
    /**
    * The API resource entity
    */
    'object': string;
    /**
    * The ID of the channel used to communicated with the device
    */
    'mechanism': string;
    /**
    * The name of the object
    */
    'name': string;
    /**
    * The address of the Connector to use
    */
    'mechanismUrl': string;
    /**
    * The state of the deployment
    */
    'deploymentState': WriteCampaignDeviceMetadataSerializer.DeploymentStateEnum;
    /**
    * The ID of the device to deploy
    */
    'deviceId': string;
}

export namespace WriteCampaignDeviceMetadataSerializer {
    export enum DeploymentStateEnum {
        Pending = <any> 'pending',
        UpdatedDeviceCatalog = <any> 'updated_device_catalog',
        UpdatedConnectorChannel = <any> 'updated_connector_channel',
        Deployed = <any> 'deployed',
        Manifestremoved = <any> 'manifestremoved'
    }
}
export class WriteUpdateCampaignSerializer {
    /**
    * A name for this campaign
    */
    'name': string;
    /**
    * The state of the campaign
    */
    'state': WriteUpdateCampaignSerializer.StateEnum;
    /**
    * The updating IAM user ID
    */
    'updatingUserId': string;
    /**
    * The API resource entity
    */
    'object': string;
    'rootManifestId': string;
    /**
    * DEPRECATED: The ID of the campaign
    */
    'campaignId': string;
    /**
    * The gateway client API key
    */
    'updatingApiKey': string;
    /**
    * The timestamp at which update campaign scheduled to start
    */
    'when': Date;
    /**
    * The timestamp when the update campaign finished
    */
    'finished': Date;
    /**
    * The updating account ID
    */
    'updatingAccountId': string;
    /**
    * The filter for the devices the campaign will target
    */
    'deviceFilter': string;
    /**
    * An optional description of the campaign
    */
    'description': string;
}

export namespace WriteUpdateCampaignSerializer {
    export enum StateEnum {
        Draft = <any> 'draft',
        Scheduled = <any> 'scheduled',
        Devicefetch = <any> 'devicefetch',
        Devicecopy = <any> 'devicecopy',
        Devicecopycomplete = <any> 'devicecopycomplete',
        Publishing = <any> 'publishing',
        Deploying = <any> 'deploying',
        Deployed = <any> 'deployed',
        Manifestremoved = <any> 'manifestremoved',
        Expired = <any> 'expired'
    }
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: request.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: request.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header") {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: request.Options): void {
        requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
    }
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        // Do nothing
    }
}

export enum DefaultApiApiKeys {
    Bearer,
}

export class DefaultApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: DefaultApiApiKeys, value: string) {
        this.authentications[DefaultApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * &lt;p&gt;Reads the deploy_info.json file and returns the Build and Git ID to the caller.&lt;/p&gt; &lt;p&gt;Will return a 500 error if the file is missing, cannot be parsed or the keys are missing.&lt;/p&gt;
     */
    public deployInfoGET () : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/v3/ds_deploy_info';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * &lt;p&gt;The APIs for creating and manipulating update campaigns. Update campaigns are used to control firmware update to a list of devices specified by a filter.  &lt;/p&gt; &lt;p&gt;Create update campaign&lt;/p&gt;
     * @param name A name for this campaign
     * @param campaignId DEPRECATED: The ID of the campaign
     * @param description An optional description of the campaign
     * @param deviceFilter The filter for the devices the campaign will target
     * @param finished The timestamp when the update campaign finished
     * @param object The API resource entity
     * @param rootManifestId 
     * @param state The state of the campaign
     * @param when The timestamp at which update campaign scheduled to start
     */
    public updateCampaignCreate (name: string, campaignId?: string, description?: string, deviceFilter?: string, finished?: Date, object?: string, rootManifestId?: string, state?: string, when?: Date) : Promise<{ response: http.IncomingMessage; body: UpdateCampaignSerializer;  }> {
        const localVarPath = this.basePath + '/v3/update-campaigns/';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling updateCampaignCreate.');
        }

        let useFormData = false;

        if (campaignId !== undefined) {
            formParams['campaign_id'] = campaignId;
        }

        if (description !== undefined) {
            formParams['description'] = description;
        }

        if (deviceFilter !== undefined) {
            formParams['device_filter'] = deviceFilter;
        }

        if (finished !== undefined) {
            formParams['finished'] = finished;
        }

        if (name !== undefined) {
            formParams['name'] = name;
        }

        if (object !== undefined) {
            formParams['object'] = object;
        }

        if (rootManifestId !== undefined) {
            formParams['root_manifest_id'] = rootManifestId;
        }

        if (state !== undefined) {
            formParams['state'] = state;
        }

        if (when !== undefined) {
            formParams['when'] = when;
        }

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: UpdateCampaignSerializer;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * &lt;p&gt;The APIs for creating and manipulating update campaigns. Update campaigns are used to control firmware update to a list of devices specified by a filter.  &lt;/p&gt; &lt;p&gt;Delete update campaign&lt;/p&gt;
     * @param campaignId The ID of the update campaign
     * @param updatingRequestId 
     * @param updatingIpAddress 
     * @param createdAt 
     * @param updatedAt 
     * @param attempts 
     * @param description 
     * @param deviceFilter 
     * @param etag 
     * @param finished 
     * @param name 
     * @param object 
     * @param rootManifestId 
     * @param state 
     * @param when 
     */
    public updateCampaignDestroy (campaignId: string, updatingRequestId?: string, updatingIpAddress?: string, createdAt?: string, updatedAt?: string, attempts?: string, description?: string, deviceFilter?: string, etag?: string, finished?: string, name?: string, object?: string, rootManifestId?: string, state?: string, when?: string) : Promise<{ response: http.IncomingMessage; body: UpdateCampaignSerializer;  }> {
        const localVarPath = this.basePath + '/v3/update-campaigns/{campaign_id}/'
            .replace('{' + 'campaign_id' + '}', String(campaignId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling updateCampaignDestroy.');
        }

        if (updatingRequestId !== undefined) {
            queryParameters['updating_request_id'] = updatingRequestId;
        }

        if (updatingIpAddress !== undefined) {
            queryParameters['updating_ip_address'] = updatingIpAddress;
        }

        if (createdAt !== undefined) {
            queryParameters['created_at'] = createdAt;
        }

        if (updatedAt !== undefined) {
            queryParameters['updated_at'] = updatedAt;
        }

        if (attempts !== undefined) {
            queryParameters['attempts'] = attempts;
        }

        if (description !== undefined) {
            queryParameters['description'] = description;
        }

        if (deviceFilter !== undefined) {
            queryParameters['device_filter'] = deviceFilter;
        }

        if (etag !== undefined) {
            queryParameters['etag'] = etag;
        }

        if (finished !== undefined) {
            queryParameters['finished'] = finished;
        }

        if (name !== undefined) {
            queryParameters['name'] = name;
        }

        if (object !== undefined) {
            queryParameters['object'] = object;
        }

        if (rootManifestId !== undefined) {
            queryParameters['root_manifest_id'] = rootManifestId;
        }

        if (state !== undefined) {
            queryParameters['state'] = state;
        }

        if (when !== undefined) {
            queryParameters['when'] = when;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: UpdateCampaignSerializer;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * &lt;p&gt;The APIs for creating and manipulating update campaigns. Update campaigns are used to control firmware update to a list of devices specified by a filter.  &lt;/p&gt; &lt;p&gt;List all update campaigns&lt;/p&gt;
     * @param updatingRequestId 
     * @param updatingIpAddress 
     * @param createdAt 
     * @param updatedAt 
     * @param attempts 
     * @param campaignId 
     * @param description 
     * @param deviceFilter 
     * @param etag 
     * @param finished 
     * @param name 
     * @param object 
     * @param rootManifestId 
     * @param state 
     * @param when 
     * @param page The page number to retrieve. If not given, then defaults to first page.
     * @param rootManifestUrl The firmware catalog URL for the manifest that will be sent to the device as part of the campaign
     */
    public updateCampaignList (updatingRequestId?: string, updatingIpAddress?: string, createdAt?: string, updatedAt?: string, attempts?: string, campaignId?: string, description?: string, deviceFilter?: string, etag?: string, finished?: string, name?: string, object?: string, rootManifestId?: string, state?: string, when?: string, page?: number, rootManifestUrl?: string) : Promise<{ response: http.IncomingMessage; body: Array<UpdateCampaignSerializer>;  }> {
        const localVarPath = this.basePath + '/v3/update-campaigns/';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (updatingRequestId !== undefined) {
            queryParameters['updating_request_id'] = updatingRequestId;
        }

        if (updatingIpAddress !== undefined) {
            queryParameters['updating_ip_address'] = updatingIpAddress;
        }

        if (createdAt !== undefined) {
            queryParameters['created_at'] = createdAt;
        }

        if (updatedAt !== undefined) {
            queryParameters['updated_at'] = updatedAt;
        }

        if (attempts !== undefined) {
            queryParameters['attempts'] = attempts;
        }

        if (campaignId !== undefined) {
            queryParameters['campaign_id'] = campaignId;
        }

        if (description !== undefined) {
            queryParameters['description'] = description;
        }

        if (deviceFilter !== undefined) {
            queryParameters['device_filter'] = deviceFilter;
        }

        if (etag !== undefined) {
            queryParameters['etag'] = etag;
        }

        if (finished !== undefined) {
            queryParameters['finished'] = finished;
        }

        if (name !== undefined) {
            queryParameters['name'] = name;
        }

        if (object !== undefined) {
            queryParameters['object'] = object;
        }

        if (rootManifestId !== undefined) {
            queryParameters['root_manifest_id'] = rootManifestId;
        }

        if (state !== undefined) {
            queryParameters['state'] = state;
        }

        if (when !== undefined) {
            queryParameters['when'] = when;
        }

        if (page !== undefined) {
            queryParameters['page'] = page;
        }

        if (rootManifestUrl !== undefined) {
            queryParameters['root_manifest_url'] = rootManifestUrl;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<UpdateCampaignSerializer>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * &lt;p&gt;The APIs for creating and manipulating update campaigns. Update campaigns are used to control firmware update to a list of devices specified by a filter.  &lt;/p&gt; &lt;p&gt;Update campaign fields&lt;/p&gt;
     * @param campaignId DEPRECATED: The ID of the campaign
     * @param description An optional description of the campaign
     * @param deviceFilter The filter for the devices the campaign will target
     * @param finished The timestamp when the update campaign finished
     * @param name A name for this campaign
     * @param object The API resource entity
     * @param rootManifestId 
     * @param state The state of the campaign
     * @param when The timestamp at which update campaign scheduled to start
     */
    public updateCampaignPartialUpdate (campaignId?: string, description?: string, deviceFilter?: string, finished?: Date, name?: string, object?: string, rootManifestId?: string, state?: string, when?: Date) : Promise<{ response: http.IncomingMessage; body: UpdateCampaignSerializer;  }> {
        const localVarPath = this.basePath + '/v3/update-campaigns/{campaign_id}/';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        if (campaignId !== undefined) {
            formParams['campaign_id'] = campaignId;
        }

        if (description !== undefined) {
            formParams['description'] = description;
        }

        if (deviceFilter !== undefined) {
            formParams['device_filter'] = deviceFilter;
        }

        if (finished !== undefined) {
            formParams['finished'] = finished;
        }

        if (name !== undefined) {
            formParams['name'] = name;
        }

        if (object !== undefined) {
            formParams['object'] = object;
        }

        if (rootManifestId !== undefined) {
            formParams['root_manifest_id'] = rootManifestId;
        }

        if (state !== undefined) {
            formParams['state'] = state;
        }

        if (when !== undefined) {
            formParams['when'] = when;
        }

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: UpdateCampaignSerializer;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * &lt;p&gt;The APIs for creating and manipulating update campaigns. Update campaigns are used to control firmware update to a list of devices specified by a filter.  &lt;/p&gt; &lt;p&gt;Retrieve campaign&lt;/p&gt;
     * @param campaignId The ID of the campaign
     * @param updatingRequestId 
     * @param updatingIpAddress 
     * @param createdAt 
     * @param updatedAt 
     * @param attempts 
     * @param description 
     * @param deviceFilter 
     * @param etag 
     * @param finished 
     * @param name 
     * @param object 
     * @param rootManifestId 
     * @param state 
     * @param when 
     * @param rootManifestUrl The firmware catalog URL for the manifest that will be sent to the device as part of the campaign
     */
    public updateCampaignRetrieve (campaignId: string, updatingRequestId?: string, updatingIpAddress?: string, createdAt?: string, updatedAt?: string, attempts?: string, description?: string, deviceFilter?: string, etag?: string, finished?: string, name?: string, object?: string, rootManifestId?: string, state?: string, when?: string, rootManifestUrl?: string) : Promise<{ response: http.IncomingMessage; body: UpdateCampaignSerializer;  }> {
        const localVarPath = this.basePath + '/v3/update-campaigns/{campaign_id}/';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling updateCampaignRetrieve.');
        }

        if (updatingRequestId !== undefined) {
            queryParameters['updating_request_id'] = updatingRequestId;
        }

        if (updatingIpAddress !== undefined) {
            queryParameters['updating_ip_address'] = updatingIpAddress;
        }

        if (createdAt !== undefined) {
            queryParameters['created_at'] = createdAt;
        }

        if (updatedAt !== undefined) {
            queryParameters['updated_at'] = updatedAt;
        }

        if (attempts !== undefined) {
            queryParameters['attempts'] = attempts;
        }

        if (description !== undefined) {
            queryParameters['description'] = description;
        }

        if (deviceFilter !== undefined) {
            queryParameters['device_filter'] = deviceFilter;
        }

        if (etag !== undefined) {
            queryParameters['etag'] = etag;
        }

        if (finished !== undefined) {
            queryParameters['finished'] = finished;
        }

        if (name !== undefined) {
            queryParameters['name'] = name;
        }

        if (object !== undefined) {
            queryParameters['object'] = object;
        }

        if (rootManifestId !== undefined) {
            queryParameters['root_manifest_id'] = rootManifestId;
        }

        if (state !== undefined) {
            queryParameters['state'] = state;
        }

        if (when !== undefined) {
            queryParameters['when'] = when;
        }

        if (rootManifestUrl !== undefined) {
            queryParameters['root_manifest_url'] = rootManifestUrl;
        }

        let useFormData = false;

        if (campaignId !== undefined) {
            formParams['campaign_id'] = campaignId;
        }

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: UpdateCampaignSerializer;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * &lt;p&gt;The APIs for creating and manipulating update campaigns. Update campaigns are used to control firmware update to a list of devices specified by a filter.  &lt;/p&gt; &lt;p&gt;Show the status of an update campaign&lt;/p&gt;
     * @param campaignId The ID of the update campaign
     * @param updatingRequestId 
     * @param updatingIpAddress 
     * @param createdAt 
     * @param updatedAt 
     * @param attempts 
     * @param description 
     * @param deviceFilter 
     * @param etag 
     * @param finished 
     * @param name 
     * @param object 
     * @param rootManifestId 
     * @param state 
     * @param when 
     */
    public updateCampaignStatus (campaignId: string, updatingRequestId?: string, updatingIpAddress?: string, createdAt?: string, updatedAt?: string, attempts?: string, description?: string, deviceFilter?: string, etag?: string, finished?: string, name?: string, object?: string, rootManifestId?: string, state?: string, when?: string) : Promise<{ response: http.IncomingMessage; body: UpdateCampaignStatusSerializer;  }> {
        const localVarPath = this.basePath + '/v3/update-campaigns/{campaign_id}/status/'
            .replace('{' + 'campaign_id' + '}', String(campaignId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'campaignId' is not null or undefined
        if (campaignId === null || campaignId === undefined) {
            throw new Error('Required parameter campaignId was null or undefined when calling updateCampaignStatus.');
        }

        if (updatingRequestId !== undefined) {
            queryParameters['updating_request_id'] = updatingRequestId;
        }

        if (updatingIpAddress !== undefined) {
            queryParameters['updating_ip_address'] = updatingIpAddress;
        }

        if (createdAt !== undefined) {
            queryParameters['created_at'] = createdAt;
        }

        if (updatedAt !== undefined) {
            queryParameters['updated_at'] = updatedAt;
        }

        if (attempts !== undefined) {
            queryParameters['attempts'] = attempts;
        }

        if (description !== undefined) {
            queryParameters['description'] = description;
        }

        if (deviceFilter !== undefined) {
            queryParameters['device_filter'] = deviceFilter;
        }

        if (etag !== undefined) {
            queryParameters['etag'] = etag;
        }

        if (finished !== undefined) {
            queryParameters['finished'] = finished;
        }

        if (name !== undefined) {
            queryParameters['name'] = name;
        }

        if (object !== undefined) {
            queryParameters['object'] = object;
        }

        if (rootManifestId !== undefined) {
            queryParameters['root_manifest_id'] = rootManifestId;
        }

        if (state !== undefined) {
            queryParameters['state'] = state;
        }

        if (when !== undefined) {
            queryParameters['when'] = when;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: UpdateCampaignStatusSerializer;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * &lt;p&gt;The APIs for creating and manipulating update campaigns. Update campaigns are used to control firmware update to a list of devices specified by a filter.  &lt;/p&gt; &lt;p&gt;Update campaign&lt;/p&gt;
     * @param name A name for this campaign
     * @param campaignId DEPRECATED: The ID of the campaign
     * @param description An optional description of the campaign
     * @param deviceFilter The filter for the devices the campaign will target
     * @param finished The timestamp when the update campaign finished
     * @param object The API resource entity
     * @param rootManifestId 
     * @param state The state of the campaign
     * @param when The timestamp at which update campaign scheduled to start
     */
    public updateCampaignUpdate (name: string, campaignId?: string, description?: string, deviceFilter?: string, finished?: Date, object?: string, rootManifestId?: string, state?: string, when?: Date) : Promise<{ response: http.IncomingMessage; body: UpdateCampaignSerializer;  }> {
        const localVarPath = this.basePath + '/v3/update-campaigns/{campaign_id}/';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling updateCampaignUpdate.');
        }

        let useFormData = false;

        if (campaignId !== undefined) {
            formParams['campaign_id'] = campaignId;
        }

        if (description !== undefined) {
            formParams['description'] = description;
        }

        if (deviceFilter !== undefined) {
            formParams['device_filter'] = deviceFilter;
        }

        if (finished !== undefined) {
            formParams['finished'] = finished;
        }

        if (name !== undefined) {
            formParams['name'] = name;
        }

        if (object !== undefined) {
            formParams['object'] = object;
        }

        if (rootManifestId !== undefined) {
            formParams['root_manifest_id'] = rootManifestId;
        }

        if (state !== undefined) {
            formParams['state'] = state;
        }

        if (when !== undefined) {
            formParams['when'] = when;
        }

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: UpdateCampaignSerializer;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
