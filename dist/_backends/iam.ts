/**
 * IAM Identities REST API
 * REST API to manage accounts, groups, users and API keys
 *
 * OpenAPI spec version: v3
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import request = require('request');
import http = require('http');

let defaultBasePath = 'https://api.mbedcloud.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

/**
* This object represents an account creation response.
*/
export class AccountEnrollmentReq {
    /**
    * A username for the new account admin containing alphanumerical letters and -,._@+= characters.
    */
    'username': string;
    /**
    * The password for the new account admin.
    */
    'password': string;
    /**
    * Verification code.
    */
    'code': string;
    /**
    * An array of aliases.
    */
    'aliases': Array<string>;
}

/**
* This object represents an account creation response.
*/
export class AccountEnrollmentResp {
    /**
    * The status of the user. INVITED means that the user has not accepted the invitation request. RESET means that the password must be changed immediately.
    */
    'status': AccountEnrollmentResp.StatusEnum;
    /**
    * A username containing alphanumerical letters and -,._@+= characters.
    */
    'username': string;
    /**
    * A flag indicating whether the user's email address has been verified or not.
    */
    'emailVerified': boolean;
    /**
    * The UUID of the account.
    */
    'accountId': string;
    /**
    * A timestamp of the latest change of the user password, in milliseconds.
    */
    'passwordChangedTime': number;
    /**
    * An array of aliases.
    */
    'aliases': Array<string>;
    /**
    * A list of IDs of the groups this user belongs to.
    */
    'groups': Array<string>;
    /**
    * Creation UTC time RFC3339.
    */
    'createdAt': string;
    /**
    * Entity name: always 'user'
    */
    'object': AccountEnrollmentResp.ObjectEnum;
    /**
    * A flag indicating that the General Terms and Conditions has been accepted.
    */
    'isGtcAccepted': boolean;
    /**
    * The email address.
    */
    'email': string;
    /**
    * A flag indicating that receiving marketing information has been accepted.
    */
    'isMarketingAccepted': boolean;
    /**
    * API resource entity version.
    */
    'etag': string;
    /**
    * The full name of the user.
    */
    'fullName': string;
    /**
    * Address.
    */
    'address': string;
    'creationTimeMillis': number;
    /**
    * A timestamp of the user creation in the storage, in milliseconds.
    */
    'creationTime': number;
    /**
    * The password when creating a new user. It will will generated when not present in the request.
    */
    'password': string;
    /**
    * Phone number.
    */
    'phoneNumber': string;
    /**
    * The UUID of the user.
    */
    'id': string;
    /**
    * A timestamp of the latest login of the user, in milliseconds.
    */
    'lastLoginTime': number;
}

export namespace AccountEnrollmentResp {
    export enum StatusEnum {
        INVITED = <any> 'INVITED',
        ACTIVE = <any> 'ACTIVE',
        RESET = <any> 'RESET',
        INACTIVE = <any> 'INACTIVE'
    }
    export enum ObjectEnum {
        User = <any> 'user',
        Apikey = <any> 'apikey',
        Group = <any> 'group',
        Account = <any> 'account',
        AccountTemplate = <any> 'account_template',
        CaCert = <any> 'ca_cert',
        List = <any> 'list',
        Error = <any> 'error'
    }
}
/**
* This object represents an account in requests and responses.
*/
export class AccountInfo {
    /**
    * The phone number of the company.
    */
    'phoneNumber': string;
    /**
    * The postal code part of the postal address.
    */
    'postalCode': string;
    /**
    * Account ID.
    */
    'id': string;
    /**
    * An array of aliases.
    */
    'aliases': Array<string>;
    /**
    * Postal address line 2.
    */
    'addressLine2': string;
    /**
    * The city part of the postal address.
    */
    'city': string;
    /**
    * Postal address line 1.
    */
    'addressLine1': string;
    /**
    * The display name for the account.
    */
    'displayName': string;
    /**
    * The state part of the postal address.
    */
    'state': string;
    /**
    * API resource entity version.
    */
    'etag': string;
    /**
    * Flag (true/false) indicating whether Factory Tool is allowed to download or not.
    */
    'isProvisioningAllowed': boolean;
    'creationTimeMillis': number;
    /**
    * The company email address for this account.
    */
    'email': string;
    /**
    * The status of the account.
    */
    'status': AccountInfo.StatusEnum;
    /**
    * The name of the company.
    */
    'company': string;
    /**
    * Entity name: always 'account'
    */
    'object': AccountInfo.ObjectEnum;
    /**
    * Time when upgraded to commercial account in UTC format RFC3339.
    */
    'upgradedAt': string;
    /**
    * The tier level of the account; '0': free tier, '1': commercial account. Other values are reserved for the future.
    */
    'tier': string;
    /**
    * List of limits as key-value pairs if requested.
    */
    'limits': { [key: string]: string; };
    /**
    * The country part of the postal address.
    */
    'country': string;
    /**
    * Creation UTC time RFC3339.
    */
    'createdAt': string;
    /**
    * The name of the contact person for this account.
    */
    'contact': string;
    /**
    * List of policies if requested.
    */
    'policies': Array<Policy>;
    /**
    * Account template ID.
    */
    'templateId': string;
}

export namespace AccountInfo {
    export enum StatusEnum {
        ENROLLING = <any> 'ENROLLING',
        ACTIVE = <any> 'ACTIVE',
        SUSPENDED = <any> 'SUSPENDED',
        DISABLED = <any> 'DISABLED'
    }
    export enum ObjectEnum {
        User = <any> 'user',
        Apikey = <any> 'apikey',
        Group = <any> 'group',
        Account = <any> 'account',
        AccountTemplate = <any> 'account_template',
        CaCert = <any> 'ca_cert',
        List = <any> 'list',
        Error = <any> 'error'
    }
}
/**
* This object represents a service sign-up request.
*/
export class AccountSignupReq {
    /**
    * The phone number of the user.
    */
    'phoneNumber': string;
    /**
    * A flag indicating that receiving marketing information has been accepted.
    */
    'isMarketingAccepted': boolean;
    /**
    * The country for the company.
    */
    'country': string;
    /**
    * The name of the company.
    */
    'company': string;
    /**
    * A flag indicating that the General Terms and Conditions has been accepted.
    */
    'isGtcAccepted': boolean;
    /**
    * The full name of the user.
    */
    'fullName': string;
    /**
    * The email address of the user.
    */
    'email': string;
}

/**
* This object represents a service sign-up request.
*/
export class AccountSignupResp {
    /**
    * The email address of the user.
    */
    'email': string;
    /**
    * The UUID of the account enrolling.
    */
    'accountId': string;
    /**
    * The sign-up ID.
    */
    'id': string;
}

/**
* This object represents a verify request during service sign-up process.
*/
export class AccountSignupVerify {
    /**
    * Verification code, also required while checking account aliases.
    */
    'code': string;
    /**
    * Account alias array to be checked for being unique.
    */
    'aliases': Array<string>;
}

/**
* This object represents an account template creation request.
*/
export class AccountTemplateReq {
    /**
    * List of limits as name-value pairs
    */
    'limits': { [key: string]: string; };
    /**
    * List of resource-action-allow triplets, policies.
    */
    'resources': Array<Policy>;
    /**
    * Account template name
    */
    'name': string;
    /**
    * ID of the parent template, can be null.
    */
    'parent': string;
    /**
    * Account template description
    */
    'description': string;
}

/**
* This object represents an account template in responses.
*/
export class AccountTemplateResp {
    /**
    * List of limits as name-value pairs
    */
    'limits': { [key: string]: string; };
    /**
    * Account template name
    */
    'name': string;
    /**
    * ID of the parent template, can be null.
    */
    'parent': string;
    /**
    * Creation UTC time RFC3339.
    */
    'createdAt': string;
    /**
    * entity name: 'user', 'apikey', 'group', 'account' or error
    */
    'object': AccountTemplateResp.ObjectEnum;
    /**
    * API resource entity version.
    */
    'etag': string;
    'creationTimeMillis': number;
    /**
    * Entity ID.
    */
    'id': string;
    /**
    * List of resource-action-allow triplets, policies.
    */
    'resources': Array<Policy>;
    /**
    * Account template description
    */
    'description': string;
}

export namespace AccountTemplateResp {
    export enum ObjectEnum {
        User = <any> 'user',
        Apikey = <any> 'apikey',
        Group = <any> 'group',
        Account = <any> 'account',
        AccountTemplate = <any> 'account_template',
        CaCert = <any> 'ca_cert',
        List = <any> 'list',
        Error = <any> 'error'
    }
}
export class AccountTemplateRespList {
    /**
    * The entity ID to fetch after the given one.
    */
    'after': string;
    /**
    * Flag indicating whether there is more results.
    */
    'hasMore': boolean;
    /**
    * The total number or records, if requested. It might be returned also for small lists.
    */
    'totalCount': number;
    /**
    * Entity name: always 'list'
    */
    'object': AccountTemplateRespList.ObjectEnum;
    /**
    * The number of results to return, (range: 2-1000), or equals to `total_count`
    */
    'limit': number;
    /**
    * A list of entities.
    */
    'data': Array<AccountTemplateResp>;
    /**
    * The order of the records to return. Available values: ASC, DESC; by default ASC.
    */
    'order': AccountTemplateRespList.OrderEnum;
}

export namespace AccountTemplateRespList {
    export enum ObjectEnum {
        User = <any> 'user',
        Apikey = <any> 'apikey',
        Group = <any> 'group',
        Account = <any> 'account',
        AccountTemplate = <any> 'account_template',
        CaCert = <any> 'ca_cert',
        List = <any> 'list',
        Error = <any> 'error'
    }
    export enum OrderEnum {
        ASC = <any> 'ASC',
        DESC = <any> 'DESC'
    }
}
/**
* This object represents an account update request.
*/
export class AccountUpdateReq {
    /**
    * Postal address line 2.
    */
    'addressLine2': string;
    /**
    * The city part of the postal address.
    */
    'city': string;
    /**
    * Postal address line 1.
    */
    'addressLine1': string;
    /**
    * The display name for the account.
    */
    'displayName': string;
    /**
    * The country part of the postal address.
    */
    'country': string;
    /**
    * The name of the company.
    */
    'company': string;
    /**
    * Account template ID. Manageable by the root admin only.
    */
    'templateId': string;
    /**
    * The status of the account. Manageable by the root admin only.
    */
    'status': string;
    /**
    * The state part of the postal address.
    */
    'state': string;
    /**
    * The name of the contact person for this account.
    */
    'contact': string;
    /**
    * The postal code part of the postal address.
    */
    'postalCode': string;
    /**
    * Flag (true/false) indicating whether Factory Tool is allowed to download or not. Manageable by the root admin only.
    */
    'isProvisioningAllowed': boolean;
    /**
    * The tier level of the account; '0': free tier, '1': commercial account. Other values are reserved for the future. Manageable by the root admin only.
    */
    'tier': string;
    /**
    * The phone number of the company.
    */
    'phoneNumber': string;
    /**
    * The company email address for this account.
    */
    'email': string;
    /**
    * An array of aliases.
    */
    'aliases': Array<string>;
}

/**
* This object represents an API key in requests towards mbed Cloud.
*/
export class ApiKeyInfoReq {
    /**
    * The owner of this API key, who is the creator by default.
    */
    'owner': string;
    /**
    * The display name for the API key.
    */
    'name': string;
    /**
    * A list of group IDs this API key belongs to.
    */
    'groups': Array<string>;
}

/**
* This object represents an API key in mbed Cloud.
*/
export class ApiKeyInfoResp {
    /**
    * The status of the API key.
    */
    'status': ApiKeyInfoResp.StatusEnum;
    /**
    * The API key.
    */
    'apikey': string;
    /**
    * The display name for the API key.
    */
    'name': string;
    /**
    * Creation UTC time RFC3339.
    */
    'createdAt': string;
    /**
    * Entity name: always 'apikey'
    */
    'object': ApiKeyInfoResp.ObjectEnum;
    /**
    * The timestamp of the API key creation in the storage, in milliseconds.
    */
    'creationTime': number;
    'creationTimeMillis': number;
    /**
    * API resource entity version.
    */
    'etag': string;
    /**
    * A list of group IDs this API key belongs to.
    */
    'groups': Array<string>;
    /**
    * The owner of this API key, who is the creator by default.
    */
    'owner': string;
    /**
    * API key secret, deprecated and always empty string.
    */
    'secretKey': string;
    /**
    * The UUID of the API key.
    */
    'id': string;
    /**
    * The timestamp of the latest API key usage, in milliseconds.
    */
    'lastLoginTime': number;
}

export namespace ApiKeyInfoResp {
    export enum StatusEnum {
        ACTIVE = <any> 'ACTIVE',
        INACTIVE = <any> 'INACTIVE'
    }
    export enum ObjectEnum {
        User = <any> 'user',
        Apikey = <any> 'apikey',
        Group = <any> 'group',
        Account = <any> 'account',
        AccountTemplate = <any> 'account_template',
        CaCert = <any> 'ca_cert',
        List = <any> 'list',
        Error = <any> 'error'
    }
}
export class ApiKeyInfoRespList {
    /**
    * The entity ID to fetch after the given one.
    */
    'after': string;
    /**
    * Flag indicating whether there is more results.
    */
    'hasMore': boolean;
    /**
    * The total number or records, if requested. It might be returned also for small lists.
    */
    'totalCount': number;
    /**
    * Entity name: always 'list'
    */
    'object': ApiKeyInfoRespList.ObjectEnum;
    /**
    * The number of results to return, (range: 2-1000), or equals to `total_count`
    */
    'limit': number;
    /**
    * A list of entities.
    */
    'data': Array<ApiKeyInfoResp>;
    /**
    * The order of the records to return. Available values: ASC, DESC; by default ASC.
    */
    'order': ApiKeyInfoRespList.OrderEnum;
}

export namespace ApiKeyInfoRespList {
    export enum ObjectEnum {
        User = <any> 'user',
        Apikey = <any> 'apikey',
        Group = <any> 'group',
        Account = <any> 'account',
        AccountTemplate = <any> 'account_template',
        CaCert = <any> 'ca_cert',
        List = <any> 'list',
        Error = <any> 'error'
    }
    export enum OrderEnum {
        ASC = <any> 'ASC',
        DESC = <any> 'DESC'
    }
}
/**
* This object represents an API key in requests towards mbed Cloud.
*/
export class ApiKeyUpdateReq {
    /**
    * The owner of this API key, who is the creator by default.
    */
    'owner': string;
    /**
    * The display name for the API key.
    */
    'name': string;
}

/**
* This object represents an CA Certificate in requests.
*/
export class CACertificateReq {
    /**
    * X509.v3 CA certificate in PEM or base64 encoded DER format.
    */
    'certData': string;
    /**
    * Certificate name.
    */
    'name': string;
    /**
    * Service name where the certificate must be used.
    */
    'service': CACertificateReq.ServiceEnum;
    /**
    * Base64 encoded signature of the account ID signed by the certificate to be uploaded. Signature must be hashed with SHA256.
    */
    'signature': string;
}

export namespace CACertificateReq {
    export enum ServiceEnum {
        Lwm2m = <any> 'lwm2m',
        Bootstrap = <any> 'bootstrap',
        Provisioning = <any> 'provisioning'
    }
}
/**
* This object represents an CA Certificate in responses.
*/
export class CACertificateResp {
    /**
    * The UUID of the account.
    */
    'accountId': string;
    /**
    * Service name where the certificate is to be used.
    */
    'service': CACertificateResp.ServiceEnum;
    /**
    * Creation UTC time RFC3339.
    */
    'createdAt': string;
    /**
    * entity name: 'user', 'apikey', 'group', 'account' or error
    */
    'object': CACertificateResp.ObjectEnum;
    /**
    * Subject of the certificate.
    */
    'subject': string;
    /**
    * Expiration time in UTC formatted as RFC3339.
    */
    'validity': string;
    /**
    * API resource entity version.
    */
    'etag': string;
    'creationTimeMillis': number;
    /**
    * Issuer of the certificate.
    */
    'issuer': string;
    /**
    * X509.v3 CA certificate in PEM or base64 encoded DER format.
    */
    'certData': string;
    /**
    * Entity ID.
    */
    'id': string;
    /**
    * Certificate name.
    */
    'name': string;
}

export namespace CACertificateResp {
    export enum ServiceEnum {
        Lwm2m = <any> 'lwm2m',
        Bootstrap = <any> 'bootstrap',
        Provisioning = <any> 'provisioning'
    }
    export enum ObjectEnum {
        User = <any> 'user',
        Apikey = <any> 'apikey',
        Group = <any> 'group',
        Account = <any> 'account',
        AccountTemplate = <any> 'account_template',
        CaCert = <any> 'ca_cert',
        List = <any> 'list',
        Error = <any> 'error'
    }
}
export class CACertificateRespList {
    /**
    * The entity ID to fetch after the given one.
    */
    'after': string;
    /**
    * Flag indicating whether there is more results.
    */
    'hasMore': boolean;
    /**
    * The total number or records, if requested. It might be returned also for small lists.
    */
    'totalCount': number;
    /**
    * Entity name: always 'list'
    */
    'object': CACertificateRespList.ObjectEnum;
    /**
    * The number of results to return, (range: 2-1000), or equals to `total_count`
    */
    'limit': number;
    /**
    * A list of entities.
    */
    'data': Array<CACertificateResp>;
    /**
    * The order of the records to return. Available values: ASC, DESC; by default ASC.
    */
    'order': CACertificateRespList.OrderEnum;
}

export namespace CACertificateRespList {
    export enum ObjectEnum {
        User = <any> 'user',
        Apikey = <any> 'apikey',
        Group = <any> 'group',
        Account = <any> 'account',
        AccountTemplate = <any> 'account_template',
        CaCert = <any> 'ca_cert',
        List = <any> 'list',
        Error = <any> 'error'
    }
    export enum OrderEnum {
        ASC = <any> 'ASC',
        DESC = <any> 'DESC'
    }
}
/**
* This object represents an error message.
*/
export class ErrorResponse {
    /**
    * Response code.
    */
    'code': number;
    /**
    * Failed input fields during request object validation.
    */
    'fields': Array<Field>;
    /**
    * Entity name, always 'error'.
    */
    'object': ErrorResponse.ObjectEnum;
    /**
    * Request ID.
    */
    'requestId': string;
    /**
    * A human readable message with detailed info.
    */
    'message': string;
    /**
    * Error type.
    */
    'type': ErrorResponse.TypeEnum;
}

export namespace ErrorResponse {
    export enum ObjectEnum {
        User = <any> 'user',
        Apikey = <any> 'apikey',
        Group = <any> 'group',
        Account = <any> 'account',
        AccountTemplate = <any> 'account_template',
        CaCert = <any> 'ca_cert',
        List = <any> 'list',
        Error = <any> 'error'
    }
    export enum TypeEnum {
        Success = <any> 'success',
        Created = <any> 'created',
        Accepted = <any> 'accepted',
        PermanentlyDeleted = <any> 'permanently_deleted',
        ValidationError = <any> 'validation_error',
        InvalidToken = <any> 'invalid_token',
        AccessDenied = <any> 'access_denied',
        AccountLimitExceeded = <any> 'account_limit_exceeded',
        NotFound = <any> 'not_found',
        MethodNotSupported = <any> 'method_not_supported',
        NotAcceptable = <any> 'not_acceptable',
        Duplicate = <any> 'duplicate',
        PreconditionFailed = <any> 'precondition_failed',
        UnsupportedMediaType = <any> 'unsupported_media_type',
        RateLimitExceeded = <any> 'rate_limit_exceeded',
        InternalServerError = <any> 'internal_server_error',
        SystemUnavailable = <any> 'system_unavailable'
    }
}
export class Field {
    'message': string;
    'name': string;
}

/**
* This object contains basic information about groups.
*/
export class GroupSummary {
    /**
    * The name of the group.
    */
    'name': string;
    /**
    * A timestamp of the latest group update, in milliseconds.
    */
    'lastUpdateTime': number;
    /**
    * The number of API keys in this group.
    */
    'apiKeyCount': number;
    /**
    * Creation UTC time RFC3339.
    */
    'createdAt': string;
    /**
    * Entity name: always 'group'
    */
    'object': GroupSummary.ObjectEnum;
    /**
    * A timestamp of the group creation in the storage, in milliseconds.
    */
    'creationTime': number;
    /**
    * API resource entity version.
    */
    'etag': string;
    'creationTimeMillis': number;
    /**
    * The UUID of the group.
    */
    'id': string;
    /**
    * The number of users in this group.
    */
    'userCount': number;
}

export namespace GroupSummary {
    export enum ObjectEnum {
        User = <any> 'user',
        Apikey = <any> 'apikey',
        Group = <any> 'group',
        Account = <any> 'account',
        AccountTemplate = <any> 'account_template',
        CaCert = <any> 'ca_cert',
        List = <any> 'list',
        Error = <any> 'error'
    }
}
export class GroupSummaryList {
    /**
    * The entity ID to fetch after the given one.
    */
    'after': string;
    /**
    * Flag indicating whether there is more results.
    */
    'hasMore': boolean;
    /**
    * The total number or records, if requested. It might be returned also for small lists.
    */
    'totalCount': number;
    /**
    * Entity name: always 'list'
    */
    'object': GroupSummaryList.ObjectEnum;
    /**
    * The number of results to return, (range: 2-1000), or equals to `total_count`
    */
    'limit': number;
    /**
    * A list of entities.
    */
    'data': Array<GroupSummary>;
    /**
    * The order of the records to return. Available values: ASC, DESC; by default ASC.
    */
    'order': GroupSummaryList.OrderEnum;
}

export namespace GroupSummaryList {
    export enum ObjectEnum {
        User = <any> 'user',
        Apikey = <any> 'apikey',
        Group = <any> 'group',
        Account = <any> 'account',
        AccountTemplate = <any> 'account_template',
        CaCert = <any> 'ca_cert',
        List = <any> 'list',
        Error = <any> 'error'
    }
    export enum OrderEnum {
        ASC = <any> 'ASC',
        DESC = <any> 'DESC'
    }
}
/**
* This object represents a password recovery request.
*/
export class PasswordRecoveryReq {
    /**
    * The new password to be set.
    */
    'password': string;
    /**
    * The hash code for the password recovery.
    */
    'hash': string;
}

/**
* This object represents a password recovery request.
*/
export class PasswordResetReq {
    /**
    * Email address.
    */
    'email': string;
}

/**
* This object represents a policy.
*/
export class Policy {
    /**
    * Comma separated list of action, empty string represents all actions.
    */
    'action': string;
    /**
    * Resource that is protected by this policy.
    */
    'resource': string;
    /**
    * true or false controlling wether action is allowed or not.
    */
    'allow': boolean;
}

/**
* This object represents a user in requests towards mbed Cloud.
*/
export class UserInfoReq {
    /**
    * A username containing alphanumerical letters and -,._@+= characters.
    */
    'username': string;
    /**
    * Phone number.
    */
    'phoneNumber': string;
    /**
    * A list of IDs of the groups this user belongs to.
    */
    'groups': Array<string>;
    /**
    * A flag indicating that the General Terms and Conditions has been accepted.
    */
    'isGtcAccepted': boolean;
    /**
    * A flag indicating that receiving marketing information has been accepted.
    */
    'isMarketingAccepted': boolean;
    /**
    * The full name of the user.
    */
    'fullName': string;
    /**
    * Address.
    */
    'address': string;
    /**
    * The password when creating a new user. It will will generated when not present in the request.
    */
    'password': string;
    /**
    * The email address.
    */
    'email': string;
}

/**
* This object represents a user in mbed Cloud.
*/
export class UserInfoResp {
    /**
    * The status of the user. INVITED means that the user has not accepted the invitation request. RESET means that the password must be changed immediately.
    */
    'status': UserInfoResp.StatusEnum;
    /**
    * A username containing alphanumerical letters and -,._@+= characters.
    */
    'username': string;
    /**
    * A flag indicating whether the user's email address has been verified or not.
    */
    'emailVerified': boolean;
    /**
    * The UUID of the account.
    */
    'accountId': string;
    /**
    * A timestamp of the latest change of the user password, in milliseconds.
    */
    'passwordChangedTime': number;
    /**
    * A list of IDs of the groups this user belongs to.
    */
    'groups': Array<string>;
    /**
    * Creation UTC time RFC3339.
    */
    'createdAt': string;
    /**
    * Entity name: always 'user'
    */
    'object': UserInfoResp.ObjectEnum;
    /**
    * A flag indicating that the General Terms and Conditions has been accepted.
    */
    'isGtcAccepted': boolean;
    /**
    * The email address.
    */
    'email': string;
    /**
    * A flag indicating that receiving marketing information has been accepted.
    */
    'isMarketingAccepted': boolean;
    /**
    * API resource entity version.
    */
    'etag': string;
    /**
    * The full name of the user.
    */
    'fullName': string;
    /**
    * Address.
    */
    'address': string;
    'creationTimeMillis': number;
    /**
    * A timestamp of the user creation in the storage, in milliseconds.
    */
    'creationTime': number;
    /**
    * The password when creating a new user. It will will generated when not present in the request.
    */
    'password': string;
    /**
    * Phone number.
    */
    'phoneNumber': string;
    /**
    * The UUID of the user.
    */
    'id': string;
    /**
    * A timestamp of the latest login of the user, in milliseconds.
    */
    'lastLoginTime': number;
}

export namespace UserInfoResp {
    export enum StatusEnum {
        INVITED = <any> 'INVITED',
        ACTIVE = <any> 'ACTIVE',
        RESET = <any> 'RESET',
        INACTIVE = <any> 'INACTIVE'
    }
    export enum ObjectEnum {
        User = <any> 'user',
        Apikey = <any> 'apikey',
        Group = <any> 'group',
        Account = <any> 'account',
        AccountTemplate = <any> 'account_template',
        CaCert = <any> 'ca_cert',
        List = <any> 'list',
        Error = <any> 'error'
    }
}
export class UserInfoRespList {
    /**
    * The entity ID to fetch after the given one.
    */
    'after': string;
    /**
    * Flag indicating whether there is more results.
    */
    'hasMore': boolean;
    /**
    * The total number or records, if requested. It might be returned also for small lists.
    */
    'totalCount': number;
    /**
    * Entity name: always 'list'
    */
    'object': UserInfoRespList.ObjectEnum;
    /**
    * The number of results to return, (range: 2-1000), or equals to `total_count`
    */
    'limit': number;
    /**
    * A list of entities.
    */
    'data': Array<UserInfoResp>;
    /**
    * The order of the records to return. Available values: ASC, DESC; by default ASC.
    */
    'order': UserInfoRespList.OrderEnum;
}

export namespace UserInfoRespList {
    export enum ObjectEnum {
        User = <any> 'user',
        Apikey = <any> 'apikey',
        Group = <any> 'group',
        Account = <any> 'account',
        AccountTemplate = <any> 'account_template',
        CaCert = <any> 'ca_cert',
        List = <any> 'list',
        Error = <any> 'error'
    }
    export enum OrderEnum {
        ASC = <any> 'ASC',
        DESC = <any> 'DESC'
    }
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: request.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: request.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header") {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: request.Options): void {
        requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
    }
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        // Do nothing
    }
}

export enum AccountAdminApiApiKeys {
    Bearer,
}

export class AccountAdminApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: AccountAdminApiApiKeys, value: string) {
        this.authentications[AccountAdminApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Upload a new CA certificate.
     * An endpoint for uploading new CA certificates.
     * @param body A CA certificate object with attributes.
     */
    public addCertificate (body: CACertificateReq) : Promise<{ response: http.IncomingMessage; body: CACertificateResp;  }> {
        const localVarPath = this.basePath + '/v3/ca-certificates';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addCertificate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CACertificateResp;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a new user.
     * An endpoint for creating a new user.
     * @param body A user object with attributes.
     * @param action Action, either &#39;create&#39; or &#39;invite&#39;.
     */
    public createUser (body: UserInfoReq, action?: string) : Promise<{ response: http.IncomingMessage; body: UserInfoResp;  }> {
        const localVarPath = this.basePath + '/v3/users';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createUser.');
        }

        if (action !== undefined) {
            queryParameters['action'] = action;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: UserInfoResp;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a CA certificate by ID.
     * An endpoint for deleting a CA certificate.
     * @param caCertId The ID of the CA certificate to be deleted.
     */
    public deleteCertificate (caCertId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v3/ca-certificates/{ca-cert-id}'
            .replace('{' + 'ca-cert-id' + '}', String(caCertId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'caCertId' is not null or undefined
        if (caCertId === null || caCertId === undefined) {
            throw new Error('Required parameter caCertId was null or undefined when calling deleteCertificate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a user.
     * An endpoint for deleting a user.
     * @param userId The ID of the user to be deleted.
     * @param force Flag indicating that user is forced to be deleted.
     */
    public deleteUser (userId: string, force?: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v3/users/{user-id}'
            .replace('{' + 'user-id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling deleteUser.');
        }

        if (force !== undefined) {
            queryParameters['force'] = force;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all CA certificates.
     * An endpoint for retrieving CA certificates in an array.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     * @param filter The filter for the query, for example filter&#x3D;service%3Dlwm2m
     */
    public getAllCertificates (limit?: number, after?: string, order?: string, include?: string, filter?: string) : Promise<{ response: http.IncomingMessage; body: CACertificateRespList;  }> {
        const localVarPath = this.basePath + '/v3/ca-certificates';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (after !== undefined) {
            queryParameters['after'] = after;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        if (include !== undefined) {
            queryParameters['include'] = include;
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CACertificateRespList;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the details of all users.
     * An endpoint for retrieving the details of all users.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     * @param filter Filter for the query, for example filter&#x3D;status%3Dactive,status%3Dreset.
     */
    public getAllUsers (limit?: number, after?: string, order?: string, include?: string, filter?: string) : Promise<{ response: http.IncomingMessage; body: UserInfoRespList;  }> {
        const localVarPath = this.basePath + '/v3/users';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (after !== undefined) {
            queryParameters['after'] = after;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        if (include !== undefined) {
            queryParameters['include'] = include;
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: UserInfoRespList;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get CA certificate by ID.
     * An endpoint for retrieving a CA certificate by ID.
     * @param caCertId The ID or name of the CA certificate to be retrieved.
     */
    public getCertificate (caCertId: string) : Promise<{ response: http.IncomingMessage; body: CACertificateResp;  }> {
        const localVarPath = this.basePath + '/v3/ca-certificates/{ca-cert-id}'
            .replace('{' + 'ca-cert-id' + '}', String(caCertId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'caCertId' is not null or undefined
        if (caCertId === null || caCertId === undefined) {
            throw new Error('Required parameter caCertId was null or undefined when calling getCertificate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CACertificateResp;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Details of a user.
     * An endpoint for retrieving the details of a user.
     * @param userId The ID or name of the user whose details are retrieved.
     */
    public getUser (userId: string) : Promise<{ response: http.IncomingMessage; body: UserInfoResp;  }> {
        const localVarPath = this.basePath + '/v3/users/{user-id}'
            .replace('{' + 'user-id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUser.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: UserInfoResp;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update CA certificate.
     * An endpoint for updating existing CA certificates.
     * @param caCertId The ID of the CA certificate to be updated.
     * @param body A CA certificate object with attributes.
     */
    public updateCertificate (caCertId: string, body: CACertificateReq) : Promise<{ response: http.IncomingMessage; body: CACertificateResp;  }> {
        const localVarPath = this.basePath + '/v3/ca-certificates/{ca-cert-id}'
            .replace('{' + 'ca-cert-id' + '}', String(caCertId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'caCertId' is not null or undefined
        if (caCertId === null || caCertId === undefined) {
            throw new Error('Required parameter caCertId was null or undefined when calling updateCertificate.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateCertificate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CACertificateResp;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates attributes of the account.
     * An endpoint for updating the account.
     * @param body Details of the account to be updated.
     */
    public updateMyAccount (body: AccountUpdateReq) : Promise<{ response: http.IncomingMessage; body: AccountInfo;  }> {
        const localVarPath = this.basePath + '/v3/accounts/me';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateMyAccount.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AccountInfo;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update user details.
     * An endpoint for updating user details.
     * @param userId The ID of the user whose details are updated.
     * @param body A user object with attributes.
     */
    public updateUser (userId: string, body: UserInfoReq) : Promise<{ response: http.IncomingMessage; body: UserInfoResp;  }> {
        const localVarPath = this.basePath + '/v3/users/{user-id}'
            .replace('{' + 'user-id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling updateUser.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateUser.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: UserInfoResp;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DefaultApiApiKeys {
    Bearer,
}

export class DefaultApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: DefaultApiApiKeys, value: string) {
        this.authentications[DefaultApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Accept invitation.
     * Accepting pending invitation and providing missing details.
     * @param invitationId Invitation ID received in email.
     * @param body Details of the user accepting the invitation.
     */
    public activateUser (invitationId: string, body: UserInfoReq) : Promise<{ response: http.IncomingMessage; body: UserInfoResp;  }> {
        const localVarPath = this.basePath + '/auth/invitations/{invitation-id}'
            .replace('{' + 'invitation-id' + '}', String(invitationId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'invitationId' is not null or undefined
        if (invitationId === null || invitationId === undefined) {
            throw new Error('Required parameter invitationId was null or undefined when calling activateUser.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling activateUser.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: UserInfoResp;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Apply password recovery.
     * Applying password recovery by providing a secret hash code.
     * @param body Hash received by email and new password.
     * @param xForwardedFor 
     */
    public applyPasswordRecovery (body: PasswordRecoveryReq, xForwardedFor?: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/auth/recover';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling applyPasswordRecovery.');
        }

        headerParams['X-Forwarded-For'] = xForwardedFor;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get invited user.
     * Returns information about the user being invited.
     * @param invitationId Invitation ID received in email.
     */
    public getInvitedUser (invitationId: string) : Promise<{ response: http.IncomingMessage; body: UserInfoResp;  }> {
        const localVarPath = this.basePath + '/auth/invitations/{invitation-id}'
            .replace('{' + 'invitation-id' + '}', String(invitationId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'invitationId' is not null or undefined
        if (invitationId === null || invitationId === undefined) {
            throw new Error('Required parameter invitationId was null or undefined when calling getInvitedUser.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: UserInfoResp;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get registering user.
     * Retrieving the details of a user to register.
     * @param signupId ID received while signing up.
     */
    public getSelfEnrollingUser (signupId: string) : Promise<{ response: http.IncomingMessage; body: AccountSignupResp;  }> {
        const localVarPath = this.basePath + '/auth/register/{signup-id}'
            .replace('{' + 'signup-id' + '}', String(signupId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'signupId' is not null or undefined
        if (signupId === null || signupId === undefined) {
            throw new Error('Required parameter signupId was null or undefined when calling getSelfEnrollingUser.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AccountSignupResp;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Register a new account.
     * An endpoint for registering a new account.
     * @param signupId ID received while signing up.
     * @param body Details of the account to be created.
     */
    public registerAccount (signupId: string, body: AccountEnrollmentReq) : Promise<{ response: http.IncomingMessage; body: AccountEnrollmentResp;  }> {
        const localVarPath = this.basePath + '/auth/register/{signup-id}'
            .replace('{' + 'signup-id' + '}', String(signupId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'signupId' is not null or undefined
        if (signupId === null || signupId === undefined) {
            throw new Error('Required parameter signupId was null or undefined when calling registerAccount.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling registerAccount.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AccountEnrollmentResp;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Request password recovery.
     * Requesting password recovery by email address.
     * @param body Email address of the user whose password needs to be recovered.
     * @param xForwardedFor 
     */
    public requestPasswordRecovery (body: PasswordResetReq, xForwardedFor?: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/auth/recover';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling requestPasswordRecovery.');
        }

        headerParams['X-Forwarded-For'] = xForwardedFor;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Sign up for a new account.
     * Signing up for a new free tier account with email address.
     * @param body Email address of the user to be signed up.
     */
    public signup (body: AccountSignupReq) : Promise<{ response: http.IncomingMessage; body: AccountSignupResp;  }> {
        const localVarPath = this.basePath + '/auth/register';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling signup.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AccountSignupResp;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Verify self-enrollment code and aliases.
     * Verifying whether the code received by email is valid. Optionally, it also verifies whether account with the given aliases exists.
     * @param signupId ID received while signing up.
     * @param body Verification code received by email and aliases to be checked.
     */
    public verifySelfEnrollment (signupId: string, body?: AccountSignupVerify) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/auth/register/{signup-id}'
            .replace('{' + 'signup-id' + '}', String(signupId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'signupId' is not null or undefined
        if (signupId === null || signupId === undefined) {
            throw new Error('Required parameter signupId was null or undefined when calling verifySelfEnrollment.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DeveloperApiApiKeys {
    Bearer,
}

export class DeveloperApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: DeveloperApiApiKeys, value: string) {
        this.authentications[DeveloperApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Create a new API key.
     * An endpoint for creating a new API key.
     * @param body The details of the API key to be created.
     */
    public createApiKey (body: ApiKeyInfoReq) : Promise<{ response: http.IncomingMessage; body: ApiKeyInfoResp;  }> {
        const localVarPath = this.basePath + '/v3/api-keys';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createApiKey.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ApiKeyInfoResp;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete API key.
     * An endpoint for deleting the API key.
     * @param apiKey The ID of the API key to be deleted.
     */
    public deleteApiKey (apiKey: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/v3/api-keys/{apiKey}'
            .replace('{' + 'apiKey' + '}', String(apiKey));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'apiKey' is not null or undefined
        if (apiKey === null || apiKey === undefined) {
            throw new Error('Required parameter apiKey was null or undefined when calling deleteApiKey.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all API keys
     * An endpoint for retrieving API keys in an array, optionally filtered by the owner.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     * @param filter A filter for the query, for example filter&#x3D;owner%3Duuid.
     * @param owner Owner name filter.
     */
    public getAllApiKeys (limit?: number, after?: string, order?: string, include?: string, filter?: string, owner?: string) : Promise<{ response: http.IncomingMessage; body: ApiKeyInfoRespList;  }> {
        const localVarPath = this.basePath + '/v3/api-keys';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (after !== undefined) {
            queryParameters['after'] = after;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        if (include !== undefined) {
            queryParameters['include'] = include;
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (owner !== undefined) {
            queryParameters['owner'] = owner;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ApiKeyInfoRespList;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all group information.
     * An endpoint for retrieving all group information.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     */
    public getAllGroups (limit?: number, after?: string, order?: string, include?: string) : Promise<{ response: http.IncomingMessage; body: GroupSummaryList;  }> {
        const localVarPath = this.basePath + '/v3/policy-groups';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (after !== undefined) {
            queryParameters['after'] = after;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        if (include !== undefined) {
            queryParameters['include'] = include;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GroupSummaryList;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get API key details.
     * An endpoint for retrieving API key details.
     * @param apiKey The ID of the API key to be retrieved.
     */
    public getApiKey (apiKey: string) : Promise<{ response: http.IncomingMessage; body: ApiKeyInfoResp;  }> {
        const localVarPath = this.basePath + '/v3/api-keys/{apiKey}'
            .replace('{' + 'apiKey' + '}', String(apiKey));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'apiKey' is not null or undefined
        if (apiKey === null || apiKey === undefined) {
            throw new Error('Required parameter apiKey was null or undefined when calling getApiKey.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ApiKeyInfoResp;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get account info.
     * Returns detailed information about the account.
     * @param include Comma separated additional data to return. Currently supported: limits
     */
    public getMyAccountInfo (include?: string) : Promise<{ response: http.IncomingMessage; body: AccountInfo;  }> {
        const localVarPath = this.basePath + '/v3/accounts/me';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (include !== undefined) {
            queryParameters['include'] = include;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AccountInfo;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get API key details.
     * An endpoint for retrieving API key details.
     */
    public getMyApiKey () : Promise<{ response: http.IncomingMessage; body: ApiKeyInfoResp;  }> {
        const localVarPath = this.basePath + '/v3/api-keys/me';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ApiKeyInfoResp;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Details of the current user.
     * An endpoint for retrieving the details of the logged in user.
     */
    public getMyUser () : Promise<{ response: http.IncomingMessage; body: UserInfoResp;  }> {
        const localVarPath = this.basePath + '/v3/users/me';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: UserInfoResp;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update API key details.
     * An endpoint for updating API key details.
     * @param apiKey The ID of the API key to be updated.
     * @param body New API key attributes to be stored.
     */
    public updateApiKey (apiKey: string, body: ApiKeyUpdateReq) : Promise<{ response: http.IncomingMessage; body: ApiKeyInfoResp;  }> {
        const localVarPath = this.basePath + '/v3/api-keys/{apiKey}'
            .replace('{' + 'apiKey' + '}', String(apiKey));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'apiKey' is not null or undefined
        if (apiKey === null || apiKey === undefined) {
            throw new Error('Required parameter apiKey was null or undefined when calling updateApiKey.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateApiKey.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ApiKeyInfoResp;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update API key details.
     * An endpoint for updating API key details.
     * @param body New API key attributes to be stored.
     */
    public updateMyApiKey (body: ApiKeyUpdateReq) : Promise<{ response: http.IncomingMessage; body: ApiKeyInfoResp;  }> {
        const localVarPath = this.basePath + '/v3/api-keys/me';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateMyApiKey.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ApiKeyInfoResp;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update user details.
     * An endpoint for updating the details of the logged in user.
     * @param body New attributes for the logged in user.
     */
    public updateMyUser (body: UserInfoReq) : Promise<{ response: http.IncomingMessage; body: UserInfoResp;  }> {
        const localVarPath = this.basePath + '/v3/users/me';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateMyUser.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: UserInfoResp;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RootAdminApiApiKeys {
    Bearer,
}

export class RootAdminApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: RootAdminApiApiKeys, value: string) {
        this.authentications[RootAdminApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Create a new account template.
     * Endpoint for creating a new account template.
     * @param body Details of the account template to be created.
     */
    public createAccountTemplate (body: AccountTemplateReq) : Promise<{ response: http.IncomingMessage; body: AccountTemplateResp;  }> {
        const localVarPath = this.basePath + '/admin/v3/account-templates';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createAccountTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AccountTemplateResp;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete account template by ID.
     * Endpoint for deleting a account template by ID.
     * @param templateId The ID of the account template to be deleted.
     */
    public deleteAccountTemplate (templateId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/admin/v3/account-templates/{template-id}'
            .replace('{' + 'template-id' + '}', String(templateId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'templateId' is not null or undefined
        if (templateId === null || templateId === undefined) {
            throw new Error('Required parameter templateId was null or undefined when calling deleteAccountTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get account template by ID.
     * Endpoint for retrieving a account template by ID.
     * @param templateId The ID of the account template to be retrieved.
     */
    public getAccountTemplate (templateId: string) : Promise<{ response: http.IncomingMessage; body: AccountTemplateResp;  }> {
        const localVarPath = this.basePath + '/admin/v3/account-templates/{template-id}'
            .replace('{' + 'template-id' + '}', String(templateId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'templateId' is not null or undefined
        if (templateId === null || templateId === undefined) {
            throw new Error('Required parameter templateId was null or undefined when calling getAccountTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AccountTemplateResp;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all account templates.
     * Endpoint for retrieving account templates in an array.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity id to fetch after it
     * @param order The order of the records, ASC or DESC. Default value is ASC
     * @param include Comma separate additional data to return. Currently supported: total_count
     */
    public getAllAccountTemplates (limit?: number, after?: string, order?: string, include?: string) : Promise<{ response: http.IncomingMessage; body: AccountTemplateRespList;  }> {
        const localVarPath = this.basePath + '/admin/v3/account-templates';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (after !== undefined) {
            queryParameters['after'] = after;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        if (include !== undefined) {
            queryParameters['include'] = include;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AccountTemplateRespList;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an existing account template.
     * Endpoint for updating an existing account template.
     * @param templateId The ID of the account template to be updated.
     * @param body Details of the account template to be updated.
     */
    public updateAccountTemplate (templateId: string, body: AccountTemplateReq) : Promise<{ response: http.IncomingMessage; body: AccountTemplateResp;  }> {
        const localVarPath = this.basePath + '/admin/v3/account-templates/{template-id}'
            .replace('{' + 'template-id' + '}', String(templateId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'templateId' is not null or undefined
        if (templateId === null || templateId === undefined) {
            throw new Error('Required parameter templateId was null or undefined when calling updateAccountTemplate.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateAccountTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AccountTemplateResp;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
