/**
 * Device Catalog API
 * This is the API Documentation for the mbed device catalog update service.
 *
 * OpenAPI spec version: 0.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import request = require('request');
import http = require('http');

let defaultBasePath = 'http://api.mbedcloud.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

export class DeviceDetail {
    'bootstrappedTimestamp': string;
    /**
    * The time the object was updated
    */
    'updatedAt': Date;
    /**
    * Up to 5 custom JSON attributes
    */
    'customAttributes': string;
    /**
    * The device class
    */
    'deviceClass': string;
    /**
    * The ID of the device
    */
    'id': string;
    /**
    * The description of the object
    */
    'description': string;
    /**
    * Mark this device for auto firmware update
    */
    'autoUpdate': boolean;
    /**
    * The ID of the channel used to communicate with the device
    */
    'mechanism': DeviceDetail.MechanismEnum;
    /**
    * The current state of the device
    */
    'state': DeviceDetail.StateEnum;
    /**
    * The entity instance signature
    */
    'etag': Date;
    /**
    * The key used to provision the device
    */
    'provisionKey': string;
    /**
    * The serial number of the device
    */
    'serialNumber': string;
    /**
    * The device vendor ID
    */
    'vendorId': string;
    /**
    * The owning IAM account ID
    */
    'accountId': string;
    /**
    * The state of the device's deployment
    */
    'deployedState': DeviceDetail.DeployedStateEnum;
    /**
    * The API resource entity
    */
    'object': string;
    /**
    * The device trust class
    */
    'trustClass': number;
    /**
    * The last deployment used on the device
    */
    'deployment': string;
    /**
    * The address of the connector to use
    */
    'mechanismUrl': string;
    /**
    * The device trust level
    */
    'trustLevel': number;
    /**
    * DEPRECATED: The ID of the device
    */
    'deviceId': string;
    /**
    * The name of the object
    */
    'name': string;
    /**
    * The time the object was created
    */
    'createdAt': Date;
    /**
    * URL for the current device manifest
    */
    'manifest': string;
}

export namespace DeviceDetail {
    export enum MechanismEnum {
        Connector = <any> 'connector',
        Direct = <any> 'direct'
    }
    export enum StateEnum {
        Unenrolled = <any> 'unenrolled',
        CloudEnrolling = <any> 'cloud_enrolling',
        Bootstrapped = <any> 'bootstrapped',
        Registered = <any> 'registered'
    }
    export enum DeployedStateEnum {
        Development = <any> 'development',
        Production = <any> 'production'
    }
}
export class DeviceListResp {
    /**
    * API Resource name
    */
    'object': string;
    /**
    * Whether there are more results to display
    */
    'hasMore': boolean;
    /**
    * Total number of records
    */
    'totalCount': number;
    /**
    * Entity id for fetch after it
    */
    'after': string;
    /**
    * The number of results to return
    */
    'limit': number;
    'data': Array<DeviceDetail>;
    /**
    * Order of returned records
    */
    'order': string;
}

export class DeviceLogSerializer {
    /**
    * API Resource name
    */
    'object': string;
    /**
    * Whether there are more results to display
    */
    'hasMore': boolean;
    /**
    * Total number of records
    */
    'totalCount': number;
    /**
    * Entity id for fetch after it
    */
    'after': string;
    /**
    * The number of results to return
    */
    'limit': number;
    'data': Array<DeviceLogSerializerData>;
    /**
    * Order of returned records
    */
    'order': string;
}

export class DeviceLogSerializerData {
    'dateTime': Date;
    'stateChange': boolean;
    'description': string;
    'changes': string;
    'eventTypeDescription': string;
    'deviceLogId': string;
    'eventType': DeviceLogSerializerData.EventTypeEnum;
    'data': string;
    'deviceId': string;
}

export namespace DeviceLogSerializerData {
    export enum EventTypeEnum {
        DeviceDeviceCreated = <any> 'update.device.device-created',
        DeviceDeviceUpdated = <any> 'update.device.device-updated',
        DeploymentCampaignDeviceMetadataCreated = <any> 'update.deployment.campaign-device-metadata-created',
        DeploymentCampaignDeviceMetadataUpdated = <any> 'update.deployment.campaign-device-metadata-updated',
        DeploymentCampaignDeviceMetadataRemoved = <any> 'update.deployment.campaign-device-metadata-removed',
        ConnectorConnectorDeviceFirmwareUpdateState = <any> 'update.connector.connector-device.firmware-update.state',
        ConnectorConnectorDeviceFirmwareUpdateResult = <any> 'update.connector.connector-device.firmware-update.result'
    }
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: request.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: request.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header") {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: request.Options): void {
        requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
    }
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        // Do nothing
    }
}

export enum DefaultApiApiKeys {
    Bearer,
}

export class DefaultApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: DefaultApiApiKeys, value: string) {
        this.authentications[DefaultApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * &lt;p&gt;The APIs for creating and manipulating devices.  &lt;/p&gt; &lt;p&gt;Create device&lt;/p&gt;
     * @param mechanism The ID of the channel used to communicate with the device
     * @param provisionKey The key used to provision the device
     * @param accountId The owning IAM account ID
     * @param autoUpdate Mark this device for auto firmware update
     * @param bootstrappedTimestamp 
     * @param createdAt 
     * @param customAttributes Up to 5 custom JSON attributes
     * @param deployedState The state of the device&#39;s deployment
     * @param deployment The last deployment used on the device
     * @param description The description of the object
     * @param deviceClass 
     * @param deviceId DEPRECATED: The ID of the device
     * @param etag The entity instance signature
     * @param id The ID of the device
     * @param manifest URL for the current device manifest
     * @param mechanismUrl The address of the connector to use
     * @param name The name of the object
     * @param object The API resource entity
     * @param serialNumber The serial number of the device
     * @param state The current state of the device
     * @param trustClass The device trust class
     * @param trustLevel The device trust level
     * @param updatedAt The time the object was updated
     * @param vendorId The device vendor ID
     */
    public deviceCreate (mechanism: string, provisionKey: string, accountId?: string, autoUpdate?: boolean, bootstrappedTimestamp?: string, createdAt?: Date, customAttributes?: string, deployedState?: string, deployment?: string, description?: string, deviceClass?: string, deviceId?: string, etag?: Date, id?: string, manifest?: string, mechanismUrl?: string, name?: string, object?: string, serialNumber?: string, state?: string, trustClass?: number, trustLevel?: number, updatedAt?: Date, vendorId?: string) : Promise<{ response: http.IncomingMessage; body: DeviceDetail;  }> {
        const localVarPath = this.basePath + '/v3/devices/';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'mechanism' is not null or undefined
        if (mechanism === null || mechanism === undefined) {
            throw new Error('Required parameter mechanism was null or undefined when calling deviceCreate.');
        }

        // verify required parameter 'provisionKey' is not null or undefined
        if (provisionKey === null || provisionKey === undefined) {
            throw new Error('Required parameter provisionKey was null or undefined when calling deviceCreate.');
        }

        let useFormData = false;

        if (accountId !== undefined) {
            formParams['account_id'] = accountId;
        }

        if (autoUpdate !== undefined) {
            formParams['auto_update'] = autoUpdate;
        }

        if (bootstrappedTimestamp !== undefined) {
            formParams['bootstrapped_timestamp'] = bootstrappedTimestamp;
        }

        if (createdAt !== undefined) {
            formParams['created_at'] = createdAt;
        }

        if (customAttributes !== undefined) {
            formParams['custom_attributes'] = customAttributes;
        }

        if (deployedState !== undefined) {
            formParams['deployed_state'] = deployedState;
        }

        if (deployment !== undefined) {
            formParams['deployment'] = deployment;
        }

        if (description !== undefined) {
            formParams['description'] = description;
        }

        if (deviceClass !== undefined) {
            formParams['device_class'] = deviceClass;
        }

        if (deviceId !== undefined) {
            formParams['device_id'] = deviceId;
        }

        if (etag !== undefined) {
            formParams['etag'] = etag;
        }

        if (id !== undefined) {
            formParams['id'] = id;
        }

        if (manifest !== undefined) {
            formParams['manifest'] = manifest;
        }

        if (mechanism !== undefined) {
            formParams['mechanism'] = mechanism;
        }

        if (mechanismUrl !== undefined) {
            formParams['mechanism_url'] = mechanismUrl;
        }

        if (name !== undefined) {
            formParams['name'] = name;
        }

        if (object !== undefined) {
            formParams['object'] = object;
        }

        if (provisionKey !== undefined) {
            formParams['provision_key'] = provisionKey;
        }

        if (serialNumber !== undefined) {
            formParams['serial_number'] = serialNumber;
        }

        if (state !== undefined) {
            formParams['state'] = state;
        }

        if (trustClass !== undefined) {
            formParams['trust_class'] = trustClass;
        }

        if (trustLevel !== undefined) {
            formParams['trust_level'] = trustLevel;
        }

        if (updatedAt !== undefined) {
            formParams['updated_at'] = updatedAt;
        }

        if (vendorId !== undefined) {
            formParams['vendor_id'] = vendorId;
        }

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DeviceDetail;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * &lt;p&gt;The APIs for creating and manipulating devices.  &lt;/p&gt; &lt;p&gt;Delete device&lt;/p&gt;
     * @param deviceId 
     */
    public deviceDestroy (deviceId: string) : Promise<{ response: http.IncomingMessage; body: DeviceListResp;  }> {
        const localVarPath = this.basePath + '/v3/devices/{device_id}/'
            .replace('{' + 'device_id' + '}', String(deviceId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling deviceDestroy.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DeviceListResp;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * &lt;p&gt;The APIs for creating and manipulating devices.  &lt;/p&gt; &lt;p&gt;List all update devices. The result is paged into pages of 100.&lt;/p&gt;
     * @param limit 
     * @param order 
     * @param after 
     * @param filter 
     * @param include 
     */
    public deviceList (limit?: number, order?: string, after?: string, filter?: string, include?: string) : Promise<{ response: http.IncomingMessage; body: DeviceListResp;  }> {
        const localVarPath = this.basePath + '/v3/devices/';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        if (after !== undefined) {
            queryParameters['after'] = after;
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (include !== undefined) {
            queryParameters['include'] = include;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DeviceListResp;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * &lt;p&gt;The APIs for creating and manipulating devices.  &lt;/p&gt; &lt;p&gt;List all device logs.&lt;/p&gt;
     * @param limit 
     * @param order 
     * @param after 
     * @param filter 
     * @param include 
     */
    public deviceLogList (limit?: number, order?: string, after?: string, filter?: string, include?: string) : Promise<{ response: http.IncomingMessage; body: DeviceLogSerializer;  }> {
        const localVarPath = this.basePath + '/v3/devicelog/';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        if (after !== undefined) {
            queryParameters['after'] = after;
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (include !== undefined) {
            queryParameters['include'] = include;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DeviceLogSerializer;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * &lt;p&gt;The APIs for creating and manipulating devices.  &lt;/p&gt; &lt;p&gt;Retrieve device log.&lt;/p&gt;
     * @param deviceLogId 
     */
    public deviceLogRetrieve (deviceLogId: string) : Promise<{ response: http.IncomingMessage; body: DeviceLogSerializer;  }> {
        const localVarPath = this.basePath + '/v3/devicelog/{device_log_id}/'
            .replace('{' + 'device_log_id' + '}', String(deviceLogId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'deviceLogId' is not null or undefined
        if (deviceLogId === null || deviceLogId === undefined) {
            throw new Error('Required parameter deviceLogId was null or undefined when calling deviceLogRetrieve.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DeviceLogSerializer;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * &lt;p&gt;The APIs for creating and manipulating devices.  &lt;/p&gt; &lt;p&gt;Update device fields&lt;/p&gt;
     * @param deviceId The ID of the device
     */
    public devicePartialUpdate (deviceId: string) : Promise<{ response: http.IncomingMessage; body: DeviceListResp;  }> {
        const localVarPath = this.basePath + '/v3/devices/{device_id}/'
            .replace('{' + 'device_id' + '}', String(deviceId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling devicePartialUpdate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DeviceListResp;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * &lt;p&gt;The APIs for creating and manipulating devices.  &lt;/p&gt; &lt;p&gt;Retrieve device.&lt;/p&gt;
     * @param deviceId 
     */
    public deviceRetrieve (deviceId: string) : Promise<{ response: http.IncomingMessage; body: DeviceListResp;  }> {
        const localVarPath = this.basePath + '/v3/devices/{device_id}/'
            .replace('{' + 'device_id' + '}', String(deviceId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling deviceRetrieve.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DeviceListResp;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * &lt;p&gt;The APIs for creating and manipulating devices.  &lt;/p&gt; &lt;p&gt;Update device.&lt;/p&gt;
     * @param deviceId The ID of the device
     */
    public deviceUpdate (deviceId: string) : Promise<{ response: http.IncomingMessage; body: DeviceListResp;  }> {
        const localVarPath = this.basePath + '/v3/devices/{device_id}/'
            .replace('{' + 'device_id' + '}', String(deviceId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling deviceUpdate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DeviceListResp;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
