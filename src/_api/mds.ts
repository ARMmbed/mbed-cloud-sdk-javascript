/**
 * mbed Cloud Connect REST API
 * mbed Cloud Connect REST API allows web applications to communicate with devices.
 *
 * OpenAPI spec version: 2
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import superagent = require('superagent');

let defaultBasePath = 'https://api.mbedcloud.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

export interface RequestOptions {
    auth?:{username?:string, password?:string};
    form?:any;
    formData?:any;
    method?:string;
    qs?:any;
    headers?:any;
    uri?:string;
    useQuerystring?: boolean;
    json?: boolean;
    encoding?: string | null;
    body?:any;
}

export function request(options:any, callback?:Function): superagent.SuperAgentRequest {
    var url = options.uri;
    var request = superagent(options.method, url);

    if (options.auth && (options.auth.username || options.auth.password)) {
        request.auth(options.auth.username || '', options.auth.password || '');
    }

    // set query parameters
    request.query(normalizeParams(options.qs));

    // set header parameters
    request.set(normalizeParams(options.headers));

    // set request timeout
    request.timeout(60000);

    if (options.json) {
        request.type("application/json");
        request.accept("application/json");
    }

    if (options.form) {
        request.type("application/x-www-form-urlencoded");
        request.send(normalizeParams(options.form));
    } else if (options.formData) {
        request.type("multipart/form-data");
        var formParams = normalizeParams(options.formData);
        for (var key in formParams) {
            if (formParams.hasOwnProperty(key)) {
                if (isFileParam(formParams[key])) {
                    // file field
                    request.attach(key, formParams[key]);
                } else {
                    request.field(key, formParams[key]);
                }
            }
        }
    } else if (options.body) {
        request.send(options.body);
    }

    request.end(function(error, response) {
        if (callback) {
            callback(error, response);
        }
    });

    return request;
}

/**
* Normalizes parameter values:
* <ul>
* <li>remove nils</li>
* <li>keep files and arrays</li>
* <li>format to string with `paramToString` for other cases</li>
* </ul>
* @param {Object.<String, Object>} params The parameters as object properties.
* @returns {Object.<String, Object>} normalized parameters.
*/
export function normalizeParams(params:any) {
    var newParams = {};

    for (var key in params) {
        if (params.hasOwnProperty(key) && params[key] != undefined && params[key] != null) {
            var value = params[key];
            if (isFileParam(value) || Array.isArray(value)) {
                newParams[key] = value;
            } else {
                newParams[key] = paramToString(value);
            }
        }
    }

    return newParams;
}

/**
* Checks whether the given parameter value represents file-like content.
* @param param The parameter to check.
* @returns {Boolean} <code>true</code> if <code>param</code> represents a file.
*/
export function isFileParam(param:any) {
    // fs.ReadStream in Node.js (but not in runtime like browserify)
    if (typeof window === 'undefined' &&
        typeof require === 'function' &&
        require('fs') &&
        param instanceof require('fs').ReadStream) {
        return true;
    }

    // Buffer in Node.js
    if (typeof Buffer === 'function' && param instanceof Buffer) {
        return true;
    }

    // Blob in browser
    if (typeof Blob === 'function' && param instanceof Blob) {
        return true;
    }

    // File in browser (it seems File object is also instance of Blob, but keep this for safe)
    if (typeof File === 'function' && param instanceof File) {
        return true;
    }

    return false;
}

/**
* Returns a string representation for an actual parameter.
* @param param The actual parameter.
* @returns {String} The string representation of <code>param</code>.
*/
export function paramToString(param:any) {
    if (param == undefined || param == null) {
        return '';
    }

    if (param instanceof Date) {
        return param.toJSON();
    }

    return param.toString();
}

export class AsyncID {
    /**
    * Asynchronous response unique ID.
    */
    'async-response-id': string;
}

export class AsyncIDResponse {
    /**
    * HTTP status code, for example 200 for OK.
    */
    'status': number;
    /**
    * Requested data, base64 encoded.
    */
    'payload': string;
    /**
    * Determines how long this value will be valid in cache, in seconds. 0 means that value won't be stored in cache.
    */
    'max-age': string;
    /**
    * Optional error message, describing error.
    */
    'error': string;
    /**
    * Asynchronous response unique ID.
    */
    'id': string;
    /**
    * Content type
    */
    'ct': string;
}

export class Endpoint {
    /**
    * Possible values ACTIVE, STALE.
    */
    'status': string;
    /**
    * Determines whether the device is in queue mode. <br/><br/><b>Queue mode</b><br/> When an endpoint is in queue mode, messages sent to the endpoint do not wake up the physical device. The messages are queued and delivered when the device wakes up and connects to mbed Cloud Connect itself. You can also use the Queue mode when the device is behind a NAT and cannot be reached directly by mbed Cloud Connect. 
    */
    'q': boolean;
    /**
    * Type of endpoint. (Free text)
    */
    'type': string;
    /**
    * Unique identifier representing the endpoint.
    */
    'name': string;
}

export class EndpointData {
    /**
    * Queue mode (default value is false)
    */
    'q': boolean;
    /**
    * Endpoint type
    */
    'ept': string;
    /**
    * Endpoint name
    */
    'ep': string;
    'resources': Array<ResourcesData>;
}

export class NotificationData {
    /**
    * Timestamp
    */
    'timestamp': string;
    /**
    * Base64 encoded payload
    */
    'payload': string;
    /**
    * URI path
    */
    'path': string;
    /**
    * Max age
    */
    'max-age': string;
    /**
    * Endpoint name
    */
    'ep': string;
    /**
    * Content type
    */
    'ct': string;
}

export class NotificationMessage {
    'async-responses': Array<AsyncIDResponse>;
    'de-registrations': Array<string>;
    'reg-updates': Array<EndpointData>;
    'registrations': Array<EndpointData>;
    'notifications': Array<NotificationData>;
    'registrations-expired': Array<string>;
}

export class Presubscription {
    'endpoint-name': string;
    'endpoint-type': string;
    'resource-path': Array<ResourcePath>;
}

export class PresubscriptionArray extends Array<Presubscription> {
}

export class Resource {
    /**
    * Resource's type
    */
    'rt': string;
    /**
    * The content type of the resource. <br/><br/><b>Important</b><br/> You are encouraged to use the resource types listed in the LWM2M specification: http://technical.openmobilealliance.org/Technical/technical-information/omna/lightweight-m2m-lwm2m-object-registry 
    */
    'type': string;
    /**
    * Resource's url.
    */
    'uri': string;
    /**
    * Observable determines whether you can subscribe to changes for this resource. It can have values \"true\" or \"false\". 
    */
    'obs': boolean;
}

export class ResourcePath {
}

export class ResourcesData {
    /**
    * Resource's URI path
    */
    'path': string;
    /**
    * Resource type
    */
    'rf': string;
    /**
    * Content type
    */
    'ct': string;
    /**
    * Whether the resource is observable or not (true/false)
    */
    'obs': boolean;
    /**
    * Interface description
    */
    'if': string;
}

export class Webhook {
    /**
    * The URL to which the notifications must be sent. We recommend that you serve this URL over HTTPS.
    */
    'url': string;
    /**
    * Headers (key/value) that must be sent with the request. Optional.
    */
    'headers': any;
}


export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: RequestOptions): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: RequestOptions): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: RequestOptions): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: RequestOptions): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(_: RequestOptions): void {
        // Do nothing
    }
}

export enum DefaultApiApiKeys {
    Bearer,
}

export class DefaultApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: DefaultApiApiKeys, value: string) {
        this.authentications[DefaultApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Delete callback URL
     * Deletes the callback URL.
     */
    public v2NotificationCallbackDelete (callback?: Function): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/v2/notification/callback';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, response) => {
            if (callback) {
                if (error) {
                    return callback(error);
                }

                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    return callback(null, response);
                }

                callback(response);
            }
        });
    }
    /**
     * Check callback URL
     * Shows the current callback URL if exists.
     */
    public v2NotificationCallbackGet (callback?: Function): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/v2/notification/callback';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, response) => {
            if (callback) {
                if (error) {
                    return callback(error);
                }

                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    return callback(null, response);
                }

                callback(response);
            }
        });
    }
}
export enum EndpointsApiApiKeys {
    Bearer,
}

export class EndpointsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: EndpointsApiApiKeys, value: string) {
        this.authentications[EndpointsApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * List the resources on an endpoint
     * The list of resources is cached by mbed Cloud Connect, so this call does not create a message to the device. 
     * @param endpointName A unique identifier for an endpoint. Note that the endpoint name needs to be an exact match. You cannot use wildcards here. 
     */
    public v2EndpointsEndpointNameGet (endpointName: string, callback?: Function): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/v2/endpoints/{endpointName}'
            .replace('{' + 'endpointName' + '}', String(endpointName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'endpointName' is not null or undefined
        if (endpointName === null || endpointName === undefined) {
            throw new Error('Required parameter endpointName was null or undefined when calling v2EndpointsEndpointNameGet.');
        }

        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, response) => {
            if (callback) {
                if (error) {
                    return callback(error);
                }

                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    return callback(null, response);
                }

                callback(response);
            }
        });
    }
    /**
     * List all endpoints
     * Endpoints are physical devices running mbed Cloud Client. 
     * @param type Filter endpoints by endpoint-type.
     */
    public v2EndpointsGet (type?: string, callback?: Function): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/v2/endpoints';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (type !== undefined) {
            queryParameters['type'] = type;
        }

        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, response) => {
            if (callback) {
                if (error) {
                    return callback(error);
                }

                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    return callback(null, response);
                }

                callback(response);
            }
        });
    }
}
export enum NotificationsApiApiKeys {
    Bearer,
}

export class NotificationsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: NotificationsApiApiKeys, value: string) {
        this.authentications[NotificationsApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Register a callback URL
     * Register a URL to which the server should deliver notifications of the subscribed resource changes. To get notifications pushed you need to also place the subscriptions.  Notifications are delivered as PUT messages to the HTTP server defined by the client with a subscription server message. The given URL should be accessible and respond to the PUT request with response code of 200 or 204. mbed Cloud Connect tests the callback URL with empty payload when the URL is registered. For more information on callback notification, see NotificationData.  **Note**: Only one callback URL per access-key can be active. If you register a new URL when another one is already active, the old URL is replaced by the new. 
     * @param webhook A json object that contains the URL to which notifications need to be sent, and the optional headers. 
     */
    public v2NotificationCallbackPut (webhook: Webhook, callback?: Function): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/v2/notification/callback';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webhook' is not null or undefined
        if (webhook === null || webhook === undefined) {
            throw new Error('Required parameter webhook was null or undefined when calling v2NotificationCallbackPut.');
        }

        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: webhook,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, response) => {
            if (callback) {
                if (error) {
                    return callback(error);
                }

                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    return callback(null, response);
                }

                callback(response);
            }
        });
    }
    /**
     * Get notifications using Long Poll
     * In this case, notifications are delivered through HTTP long-poll requests. The HTTP request is kept open until an event notification or a batch of event notifications are delivered to the client or the request times out (response code 204). In both cases, the client should open a new polling connection after the previous one closes. You must have a persistent connection (Connection keep-alive header in the request) to avoid excess TLS handshakes.  **Note:** If it is not possible to have a public facing callback URL, for example when developing on your local machine, you can use long polling to check for new messages. However, to reduce network traffic and to increase performance we recommend that you use callback URLs (webhooks) whenever possible. 
     */
    public v2NotificationPullGet (callback?: Function): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/v2/notification/pull';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, response) => {
            if (callback) {
                if (error) {
                    return callback(error);
                }

                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    return callback(null, response);
                }

                callback(response);
            }
        });
    }
}
export enum ResourcesApiApiKeys {
    Bearer,
}

export class ResourcesApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: ResourcesApiApiKeys, value: string) {
        this.authentications[ResourcesApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Delete a resource
     * A request to delete a resource must be handled by both mbed Cloud Client and mbed Cloud Connect. The resource is not deleted from mbed Cloud Connect until the delete is handled by mbed Cloud Client.  All resource APIs are asynchronous. Note that these APIs respond only if the device is turned on and connected to mbed Cloud Connect. 
     * @param endpointName A unique identifier for the endpoint. Note that the endpoint-name must be an exact match. You cannot use wildcards here. 
     * @param resourcePath Resource&#39;s url. 
     * @param noResp **Non-confirmable requests**  All resource APIs have the parameter noResp. If you make a request with noResp&#x3D;true, mbed Cloud Connect makes a CoAP non-confirmable request to the device. Such requests are not guaranteed to arrive in the device, and you do not get back an async-response-id.  If calls with this parameter enabled succeed, they return with the status code 204 No Content. If the underlying protocol does not support non-confirmable requests, or if the endpoint is registered in queue mode, the response is status code 409 Conflict. 
     */
    public v2EndpointsEndpointNameResourcePathDelete (endpointName: string, resourcePath: string, noResp?: boolean, callback?: Function): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/v2/endpoints/{endpointName}/{resourcePath}'
            .replace('{' + 'endpointName' + '}', String(endpointName))
            .replace('{' + 'resourcePath' + '}', String(resourcePath));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'endpointName' is not null or undefined
        if (endpointName === null || endpointName === undefined) {
            throw new Error('Required parameter endpointName was null or undefined when calling v2EndpointsEndpointNameResourcePathDelete.');
        }

        // verify required parameter 'resourcePath' is not null or undefined
        if (resourcePath === null || resourcePath === undefined) {
            throw new Error('Required parameter resourcePath was null or undefined when calling v2EndpointsEndpointNameResourcePathDelete.');
        }

        if (noResp !== undefined) {
            queryParameters['noResp'] = noResp;
        }

        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, response) => {
            if (callback) {
                if (error) {
                    return callback(error);
                }

                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    return callback(null, response);
                }

                callback(response);
            }
        });
    }
    /**
     * Read from a resource
     * Requests the resource value and when the response is available, a json AsycResponse object (AsyncIDResponse object) is received in the notification channel. Note that you can also receive notifications when a resource changes. The preferred way to get resource values is to use subscribe and callback methods.  All resource APIs are asynchronous. Note that these APIs will only respond if the device is turned on and connected to mbed Cloud Connect. 
     * @param endpointName Unique identifier for the endpoint. Note that the endpoint name needs to be an exact match. You cannot use wildcards here. 
     * @param resourcePath Resource&#39;s url. 
     * @param cacheOnly If true, the response comes only from the cache. Default: false. 
     * @param noResp **Non-confirmable requests**  All resource APIs have the parameter noResp. If a request is made with noResp&#x3D;true, mbed Cloud Connect makes a CoAP non-confirmable request to the device. Such requests are not guaranteed to arrive in the device, and you do not get back an async-response-id.  If calls with this parameter enabled succeed, they return with the status code 204 No Content. If the underlying protocol does not support non-confirmable requests, or if the endpoint is registered in queue mode, the response is status code 409 Conflict. 
     */
    public v2EndpointsEndpointNameResourcePathGet (endpointName: string, resourcePath: string, cacheOnly?: boolean, noResp?: boolean, callback?: Function): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/v2/endpoints/{endpointName}/{resourcePath}'
            .replace('{' + 'endpointName' + '}', String(endpointName))
            .replace('{' + 'resourcePath' + '}', String(resourcePath));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'endpointName' is not null or undefined
        if (endpointName === null || endpointName === undefined) {
            throw new Error('Required parameter endpointName was null or undefined when calling v2EndpointsEndpointNameResourcePathGet.');
        }

        // verify required parameter 'resourcePath' is not null or undefined
        if (resourcePath === null || resourcePath === undefined) {
            throw new Error('Required parameter resourcePath was null or undefined when calling v2EndpointsEndpointNameResourcePathGet.');
        }

        if (cacheOnly !== undefined) {
            queryParameters['cacheOnly'] = cacheOnly;
        }

        if (noResp !== undefined) {
            queryParameters['noResp'] = noResp;
        }

        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, response) => {
            if (callback) {
                if (error) {
                    return callback(error);
                }

                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    return callback(null, response);
                }

                callback(response);
            }
        });
    }
    /**
     * Execute a function on a resource
     * With this API, you can execute a function on an existing resource.  All resource APIs are asynchronous. Note that these APIs respond only if the device is turned on and connected to mbed Cloud Connect. 
     * @param endpointName A unique identifier for the endpoint. Note that the endpoint-name must be an exact match. You cannot use wildcards here. 
     * @param resourcePath Resource&#39;s url.
     * @param resourceFunction This value is not needed. Most of the time resources do not accept a function but they have their own functions predefined. You can use this to trigger them.  If a function is included, the body of this request is passed as a char* to the function in mbed Cloud Client. 
     * @param noResp **Non-confirmable requests**  All resource APIs have the parameter noResp. If you make a request with noResp&#x3D;true, mbed Cloud Connect makes a CoAP non-confirmable request to the device. Such requests are not guaranteed to arrive in the device, and you do not get back an async-response-id.  If calls with this parameter enabled succeed, they return with the status code 204 No Content. If the underlying protocol does not support non-confirmable requests, or if the endpoint is registered in queue mode, the response is status code 409 Conflict. 
     */
    public v2EndpointsEndpointNameResourcePathPost (endpointName: string, resourcePath: string, resourceFunction?: string, noResp?: boolean, callback?: Function): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/v2/endpoints/{endpointName}/{resourcePath}'
            .replace('{' + 'endpointName' + '}', String(endpointName))
            .replace('{' + 'resourcePath' + '}', String(resourcePath));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'endpointName' is not null or undefined
        if (endpointName === null || endpointName === undefined) {
            throw new Error('Required parameter endpointName was null or undefined when calling v2EndpointsEndpointNameResourcePathPost.');
        }

        // verify required parameter 'resourcePath' is not null or undefined
        if (resourcePath === null || resourcePath === undefined) {
            throw new Error('Required parameter resourcePath was null or undefined when calling v2EndpointsEndpointNameResourcePathPost.');
        }

        if (noResp !== undefined) {
            queryParameters['noResp'] = noResp;
        }

        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: resourceFunction,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, response) => {
            if (callback) {
                if (error) {
                    return callback(error);
                }

                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    return callback(null, response);
                }

                callback(response);
            }
        });
    }
    /**
     * Write to a resource
     * With this API, you can write new values to existing resources, or create new resources on the device. The resource-path does not have to exist - it can be created by the call.  All resource APIs are asynchronous. Note that these APIs respond only if the device is turned on and connected to mbed Cloud Connect. 
     * @param endpointName A unique identifier for the endpoint. Note that the endpoint name must be an exact match. You cannot use wildcards here. 
     * @param resourcePath Resource&#39;s url.
     * @param resourceValue Value to be set to the resource. (Check accceptable content-types) 
     * @param noResp **Non-confirmable requests**  All resource APIs have the parameter noResp. If you make a request with noResp&#x3D;true, mbed Cloud Connect makes a CoAP non-confirmable request to the device. Such requests are not guaranteed to arrive in the device, and you do not get back an async-response-id.  If calls with this parameter enabled succeed, they return with the status code 204 No Content. If the underlying protocol does not support non-confirmable requests, or if the endpoint is registered in queue mode, the response is status code 409 Conflict. 
     */
    public v2EndpointsEndpointNameResourcePathPut (endpointName: string, resourcePath: string, resourceValue: string, noResp?: boolean, callback?: Function): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/v2/endpoints/{endpointName}/{resourcePath}'
            .replace('{' + 'endpointName' + '}', String(endpointName))
            .replace('{' + 'resourcePath' + '}', String(resourcePath));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'endpointName' is not null or undefined
        if (endpointName === null || endpointName === undefined) {
            throw new Error('Required parameter endpointName was null or undefined when calling v2EndpointsEndpointNameResourcePathPut.');
        }

        // verify required parameter 'resourcePath' is not null or undefined
        if (resourcePath === null || resourcePath === undefined) {
            throw new Error('Required parameter resourcePath was null or undefined when calling v2EndpointsEndpointNameResourcePathPut.');
        }

        // verify required parameter 'resourceValue' is not null or undefined
        if (resourceValue === null || resourceValue === undefined) {
            throw new Error('Required parameter resourceValue was null or undefined when calling v2EndpointsEndpointNameResourcePathPut.');
        }

        if (noResp !== undefined) {
            queryParameters['noResp'] = noResp;
        }

        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: resourceValue,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, response) => {
            if (callback) {
                if (error) {
                    return callback(error);
                }

                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    return callback(null, response);
                }

                callback(response);
            }
        });
    }
}
export enum SubscriptionsApiApiKeys {
    Bearer,
}

export class SubscriptionsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: SubscriptionsApiApiKeys, value: string) {
        this.authentications[SubscriptionsApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Remove all subscriptions
     * Removes subscriptions from every endpoint and resource. Note that this does not remove pre-subscriptions.
     */
    public v2SubscriptionsDelete (callback?: Function): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/v2/subscriptions';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, response) => {
            if (callback) {
                if (error) {
                    return callback(error);
                }

                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    return callback(null, response);
                }

                callback(response);
            }
        });
    }
    /**
     * Delete subscriptions from an endpoint
     * Deletes all resource subscriptions in a single endpoint.
     * @param endpointName A unique identifier for the endpoint. Note that the endpoint name must be an exact match. You cannot use wildcards here. 
     */
    public v2SubscriptionsEndpointNameDelete (endpointName: string, callback?: Function): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/v2/subscriptions/{endpointName}'
            .replace('{' + 'endpointName' + '}', String(endpointName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'endpointName' is not null or undefined
        if (endpointName === null || endpointName === undefined) {
            throw new Error('Required parameter endpointName was null or undefined when calling v2SubscriptionsEndpointNameDelete.');
        }

        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, response) => {
            if (callback) {
                if (error) {
                    return callback(error);
                }

                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    return callback(null, response);
                }

                callback(response);
            }
        });
    }
    /**
     * Read endpoints subscriptions
     * Lists all subscribed resources from a single endpoint.
     * @param endpointName A unique identifier for the endpoint. Note that endpoint name must be an exact match. You cannot use wildcards here. 
     */
    public v2SubscriptionsEndpointNameGet (endpointName: string, callback?: Function): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/v2/subscriptions/{endpointName}'
            .replace('{' + 'endpointName' + '}', String(endpointName));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'endpointName' is not null or undefined
        if (endpointName === null || endpointName === undefined) {
            throw new Error('Required parameter endpointName was null or undefined when calling v2SubscriptionsEndpointNameGet.');
        }

        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, response) => {
            if (callback) {
                if (error) {
                    return callback(error);
                }

                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    return callback(null, response);
                }

                callback(response);
            }
        });
    }
    /**
     * Remove a subscription
     * To remove an existing subscription from a resource path. 
     * @param endpointName A unique identifier for the endpoint. Note that the endpoint name must be an exact match. You cannot use wildcards here. 
     * @param resourcePath Resource&#39;s url. 
     */
    public v2SubscriptionsEndpointNameResourcePathDelete (endpointName: string, resourcePath: string, callback?: Function): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/v2/subscriptions/{endpointName}/{resourcePath}'
            .replace('{' + 'endpointName' + '}', String(endpointName))
            .replace('{' + 'resourcePath' + '}', String(resourcePath));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'endpointName' is not null or undefined
        if (endpointName === null || endpointName === undefined) {
            throw new Error('Required parameter endpointName was null or undefined when calling v2SubscriptionsEndpointNameResourcePathDelete.');
        }

        // verify required parameter 'resourcePath' is not null or undefined
        if (resourcePath === null || resourcePath === undefined) {
            throw new Error('Required parameter resourcePath was null or undefined when calling v2SubscriptionsEndpointNameResourcePathDelete.');
        }

        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, response) => {
            if (callback) {
                if (error) {
                    return callback(error);
                }

                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    return callback(null, response);
                }

                callback(response);
            }
        });
    }
    /**
     * Read subscription status
     * 
     * @param endpointName A unique identifier for the endpoint. Note that the endpoint name must be an exact match. You cannot use wildcards here. 
     * @param resourcePath Resource&#39;s url. 
     */
    public v2SubscriptionsEndpointNameResourcePathGet (endpointName: string, resourcePath: string, callback?: Function): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/v2/subscriptions/{endpointName}/{resourcePath}'
            .replace('{' + 'endpointName' + '}', String(endpointName))
            .replace('{' + 'resourcePath' + '}', String(resourcePath));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'endpointName' is not null or undefined
        if (endpointName === null || endpointName === undefined) {
            throw new Error('Required parameter endpointName was null or undefined when calling v2SubscriptionsEndpointNameResourcePathGet.');
        }

        // verify required parameter 'resourcePath' is not null or undefined
        if (resourcePath === null || resourcePath === undefined) {
            throw new Error('Required parameter resourcePath was null or undefined when calling v2SubscriptionsEndpointNameResourcePathGet.');
        }

        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, response) => {
            if (callback) {
                if (error) {
                    return callback(error);
                }

                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    return callback(null, response);
                }

                callback(response);
            }
        });
    }
    /**
     * Subscribe to a resource path
     * The mbed Cloud Connect eventing model consists of observable resources.  This means that endpoints can deliver updated resource content, periodically or with a more sophisticated solution-dependent logic. The OMA LWM2M resource model including objects, object instances, resources and resource instances is also supported.  Applications can subscribe to objects, object instances or individual resources to make the device to provide value change notifications to mbed Cloud Connect service. An application needs to call a /notification/callback method to get mbed Cloud Connect to push a notification of the resource changes. You can also use /subscriptions to set a pre-subscription. 
     * @param endpointName A unique identifier for the endpoint. Note that the endpoint name must be an exact match. You cannot use wildcards here. 
     * @param resourcePath Resource&#39;s URL. 
     */
    public v2SubscriptionsEndpointNameResourcePathPut (endpointName: string, resourcePath: string, callback?: Function): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/v2/subscriptions/{endpointName}/{resourcePath}'
            .replace('{' + 'endpointName' + '}', String(endpointName))
            .replace('{' + 'resourcePath' + '}', String(resourcePath));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'endpointName' is not null or undefined
        if (endpointName === null || endpointName === undefined) {
            throw new Error('Required parameter endpointName was null or undefined when calling v2SubscriptionsEndpointNameResourcePathPut.');
        }

        // verify required parameter 'resourcePath' is not null or undefined
        if (resourcePath === null || resourcePath === undefined) {
            throw new Error('Required parameter resourcePath was null or undefined when calling v2SubscriptionsEndpointNameResourcePathPut.');
        }

        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, response) => {
            if (callback) {
                if (error) {
                    return callback(error);
                }

                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    return callback(null, response);
                }

                callback(response);
            }
        });
    }
    /**
     * Get pre-subscriptions
     * You can retrieve the pre-subscription data by using a GET operation. The server returns with the same JSON structure as described above. If there are no pre-subscribed resources, it returns with an empty array. 
     */
    public v2SubscriptionsGet (callback?: Function): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/v2/subscriptions';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, response) => {
            if (callback) {
                if (error) {
                    return callback(error);
                }

                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    return callback(null, response);
                }

                callback(response);
            }
        });
    }
    /**
     * Set pre-subscriptions
     * Pre-subscription is a set of rules and patterns put by the application. When an endpoint registers and its name, type and registered resources match the pre-subscription data, mbed Cloud Connect sends subscription requests to the device automatically. The pattern may include the endpoint name (optionally having an \\* character at the end), endpoint type, a list of resources or expressions with an \\* character at the end. The pre-subscription concerns all the endpoints that are already registered and the server sends subscription requests to the devices immediately when the patterns are set. There is only one pre-subscribe array, so changing the pre-subscription data removes all the previous subscriptions. To remove the pre-subscription data, put an empty array as a rule. 
     * @param presubsription Array of pre-subscriptions.
     */
    public v2SubscriptionsPut (presubsription: PresubscriptionArray, callback?: Function): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/v2/subscriptions';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'presubsription' is not null or undefined
        if (presubsription === null || presubsription === undefined) {
            throw new Error('Required parameter presubsription was null or undefined when calling v2SubscriptionsPut.');
        }

        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: presubsription,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, response) => {
            if (callback) {
                if (error) {
                    return callback(error);
                }

                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    return callback(null, response);
                }

                callback(response);
            }
        });
    }
}
