/**
 * IAM Identities REST API
 * REST API to manage accounts, groups, users and API keys
 *
 * OpenAPI spec version: v3
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

// ===============================================
// This file is autogenerated - Please do not edit
// Tracks base typescript-fetch mustache 01/02/17
// ===============================================

/* tslint:disable:no-unused-variable */

import superagent = require('superagent');
import { ApiBase } from "../common/apiBase";

/**
 * This object represents an account enrollment request.
 */
export interface AccountEnrollmentReq {
    /**
     * A username for the new account admin containing alphanumerical letters and -,._@+= characters.
     */
    "username": string;
    /**
     * Verification code.
     */
    "code": string;
    /**
     * A flag indicating that the General Terms and Conditions has been accepted.
     */
    "is_gtc_accepted"?: boolean;
    /**
     * A flag indicating that receiving marketing information has been accepted.
     */
    "is_marketing_accepted"?: boolean;
    /**
     * The password for the new account admin.
     */
    "password": string;
    /**
     * An array of aliases.
     */
    "aliases"?: Array<string>;
}

/**
 * This object represents an account creation response.
 */
export type AccountEnrollmentRespStatusEnum = "ENROLLING" | "INVITED" | "ACTIVE" | "RESET" | "INACTIVE";
export type AccountEnrollmentRespObjectEnum = "user" | "api-key" | "group" | "account" | "account-template" | "trusted-cert" | "list" | "error";
export interface AccountEnrollmentResp {
    /**
     * The status of the user. INVITED means that the user has not accepted the invitation request. RESET means that the password must be changed immediately.
     */
    "status": AccountEnrollmentRespStatusEnum;
    /**
     * A username containing alphanumerical letters and -,._@+= characters.
     */
    "username": string;
    /**
     * A flag indicating whether the user's email address has been verified or not.
     */
    "email_verified"?: boolean;
    /**
     * The UUID of the account.
     */
    "account_id": string;
    /**
     * A timestamp of the latest change of the user password, in milliseconds.
     */
    "password_changed_time"?: number;
    /**
     * An array of aliases.
     */
    "aliases": Array<string>;
    /**
     * A list of IDs of the groups this user belongs to.
     */
    "groups"?: Array<string>;
    /**
     * Creation UTC time RFC3339.
     */
    "created_at"?: string;
    /**
     * Entity name: always 'user'
     */
    "object": AccountEnrollmentRespObjectEnum;
    /**
     * A flag indicating that the General Terms and Conditions has been accepted.
     */
    "is_gtc_accepted"?: boolean;
    /**
     * The email address.
     */
    "email": string;
    /**
     * A flag indicating that receiving marketing information has been accepted.
     */
    "is_marketing_accepted"?: boolean;
    /**
     * API resource entity version.
     */
    "etag": string;
    /**
     * The full name of the user.
     */
    "full_name"?: string;
    /**
     * Address.
     */
    "address"?: string;
    "creationTimeMillis"?: number;
    /**
     * A timestamp of the user creation in the storage, in milliseconds.
     */
    "creation_time"?: number;
    /**
     * The password when creating a new user. It will will generated when not present in the request.
     */
    "password"?: string;
    /**
     * Phone number.
     */
    "phone_number"?: string;
    /**
     * The UUID of the user.
     */
    "id": string;
    /**
     * A timestamp of the latest login of the user, in milliseconds.
     */
    "last_login_time"?: number;
}

/**
 * This object represents an account in requests and responses.
 */
export type AccountInfoObjectEnum = "user" | "api-key" | "group" | "account" | "account-template" | "trusted-cert" | "list" | "error";
export interface AccountInfo {
    /**
     * The status of the account.
     */
    "status": string;
    /**
     * The postal code part of the postal address.
     */
    "postal_code"?: string;
    /**
     * Account ID.
     */
    "id": string;
    /**
     * An array of aliases.
     */
    "aliases": Array<string>;
    /**
     * Postal address line 2.
     */
    "address_line2"?: string;
    /**
     * The city part of the postal address.
     */
    "city"?: string;
    /**
     * Postal address line 1.
     */
    "address_line1"?: string;
    /**
     * The display name for the account.
     */
    "display_name"?: string;
    /**
     * The ID of the parent account, if it has any.
     */
    "parent_id"?: string;
    /**
     * The state part of the postal address.
     */
    "state"?: string;
    /**
     * API resource entity version.
     */
    "etag": string;
    /**
     * Flag (true/false) indicating whether Factory Tool is allowed to download or not.
     */
    "is_provisioning_allowed": boolean;
    "creationTimeMillis"?: number;
    /**
     * The company email address for this account.
     */
    "email"?: string;
    /**
     * The phone number of the company.
     */
    "phone_number"?: string;
    /**
     * The name of the company.
     */
    "company"?: string;
    /**
     * Entity name: always 'account'
     */
    "object": AccountInfoObjectEnum;
    /**
     * Time when upgraded to commercial account in UTC format RFC3339.
     */
    "upgraded_at"?: string;
    /**
     * The tier level of the account; '0': free tier, '1': commercial account. Other values are reserved for the future.
     */
    "tier": string;
    /**
     * List of sub accounts.
     */
    "sub_accounts"?: Array<AccountInfo>;
    /**
     * List of limits as key-value pairs if requested.
     */
    "limits"?: { [key: string]: string; };
    /**
     * The country part of the postal address.
     */
    "country"?: string;
    /**
     * Creation UTC time RFC3339.
     */
    "created_at"?: string;
    /**
     * The name of the contact person for this account.
     */
    "contact"?: string;
    /**
     * List of policies if requested.
     */
    "policies"?: Array<Policy>;
    /**
     * Account template ID.
     */
    "template_id"?: string;
}

/**
 * This object represents a service sign-up request.
 */
export interface AccountSignupReq {
    /**
     * The phone number of the user.
     */
    "phone_number"?: string;
    /**
     * The country for the company.
     */
    "country": string;
    /**
     * The name of the company.
     */
    "company": string;
    /**
     * The email address of the user.
     */
    "email": string;
    /**
     * The full name of the user.
     */
    "full_name": string;
}

/**
 * This object represents a service sign-up request.
 */
export interface AccountSignupResp {
    /**
     * The email address of the user.
     */
    "email": string;
    /**
     * The UUID of the account enrolling.
     */
    "account_id": string;
    /**
     * The sign-up ID.
     */
    "id": string;
}

/**
 * This object represents a verify request during service sign-up process.
 */
export interface AccountSignupVerify {
    /**
     * Verification code, also required while checking account aliases.
     */
    "code": string;
    /**
     * Account alias array to be checked for being unique.
     */
    "aliases"?: Array<string>;
}

/**
 * This object represents an account creation request.
 */
export interface AccountUpdateReq {
    /**
     * Postal address line 2.
     */
    "address_line2"?: string;
    /**
     * The city part of the postal address.
     */
    "city"?: string;
    /**
     * Postal address line 1.
     */
    "address_line1"?: string;
    /**
     * The display name for the account.
     */
    "display_name"?: string;
    /**
     * The country part of the postal address.
     */
    "country"?: string;
    /**
     * The name of the company.
     */
    "company"?: string;
    /**
     * The state part of the postal address.
     */
    "state"?: string;
    /**
     * The name of the contact person for this account.
     */
    "contact"?: string;
    /**
     * The postal code part of the postal address.
     */
    "postal_code"?: string;
    /**
     * The ID of the parent account, if it has any.
     */
    "parentID"?: string;
    /**
     * The phone number of the company.
     */
    "phone_number"?: string;
    /**
     * The company email address for this account.
     */
    "email"?: string;
    /**
     * An array of aliases.
     */
    "aliases"?: Array<string>;
}

/**
 * This object represents an API key in requests towards mbed Cloud.
 */
export interface ApiKeyInfoReq {
    /**
     * The owner of this API key, who is the creator by default.
     */
    "owner"?: string;
    /**
     * The display name for the API key.
     */
    "name": string;
    /**
     * A list of group IDs this API key belongs to.
     */
    "groups"?: Array<string>;
}

/**
 * This object represents an API key in mbed Cloud.
 */
export type ApiKeyInfoRespStatusEnum = "ACTIVE" | "INACTIVE";
export type ApiKeyInfoRespObjectEnum = "user" | "api-key" | "group" | "account" | "account-template" | "trusted-cert" | "list" | "error";
export interface ApiKeyInfoResp {
    /**
     * A list of group IDs this API key belongs to.
     */
    "groups"?: Array<string>;
    /**
     * The status of the API key.
     */
    "status"?: ApiKeyInfoRespStatusEnum;
    /**
     * The display name for the API key.
     */
    "name": string;
    /**
     * Creation UTC time RFC3339.
     */
    "created_at"?: string;
    /**
     * Entity name: always 'api-key'
     */
    "object": ApiKeyInfoRespObjectEnum;
    /**
     * The timestamp of the API key creation in the storage, in milliseconds.
     */
    "creation_time"?: number;
    "creationTimeMillis"?: number;
    /**
     * API resource entity version.
     */
    "etag": string;
    /**
     * The API key.
     */
    "key": string;
    /**
     * The owner of this API key, who is the creator by default.
     */
    "owner"?: string;
    /**
     * The UUID of the API key.
     */
    "id": string;
    /**
     * The timestamp of the latest API key usage, in milliseconds.
     */
    "last_login_time"?: number;
}

export type ApiKeyInfoRespListObjectEnum = "user" | "api-key" | "group" | "account" | "account-template" | "trusted-cert" | "list" | "error";
export type ApiKeyInfoRespListOrderEnum = "ASC" | "DESC";
export interface ApiKeyInfoRespList {
    /**
     * The entity ID to fetch after the given one.
     */
    "after"?: string;
    /**
     * Flag indicating whether there is more results.
     */
    "has_more": boolean;
    /**
     * The total number or records, if requested. It might be returned also for small lists.
     */
    "total_count": number;
    /**
     * Entity name: always 'list'
     */
    "object": ApiKeyInfoRespListObjectEnum;
    /**
     * The number of results to return, (range: 2-1000), or equals to `total_count`
     */
    "limit": number;
    /**
     * A list of entities.
     */
    "data": Array<ApiKeyInfoResp>;
    /**
     * The order of the records to return. Available values: ASC, DESC; by default ASC.
     */
    "order"?: ApiKeyInfoRespListOrderEnum;
}

/**
 * This object represents an API key in requests towards mbed Cloud.
 */
export interface ApiKeyUpdateReq {
    /**
     * The owner of this API key, who is the creator by default.
     */
    "owner"?: string;
    /**
     * The display name for the API key.
     */
    "name": string;
}

/**
 * This object represents an error message.
 */
export type ErrorResponseObjectEnum = "user" | "api-key" | "group" | "account" | "account-template" | "trusted-cert" | "list" | "error";
export type ErrorResponseTypeEnum = "success" | "created" | "accepted" | "permanently_deleted" | "validation_error" | "invalid_token" | "access_denied" | "account_limit_exceeded" | "not_found" | "method_not_supported" | "not_acceptable" | "duplicate" | "precondition_failed" | "unsupported_media_type" | "rate_limit_exceeded" | "internal_server_error" | "system_unavailable";
export interface ErrorResponse {
    /**
     * Response code.
     */
    "code": number;
    /**
     * Failed input fields during request object validation.
     */
    "fields"?: Array<Field>;
    /**
     * Entity name, always 'error'.
     */
    "object": ErrorResponseObjectEnum;
    /**
     * Request ID.
     */
    "request_id": string;
    /**
     * A human readable message with detailed info.
     */
    "message": string;
    /**
     * Error type.
     */
    "type": ErrorResponseTypeEnum;
}

export interface Field {
    "message"?: string;
    "name"?: string;
}

/**
 * This object represents a password recovery request.
 */
export interface PasswordRecoveryReq {
    /**
     * The new password to be set.
     */
    "password": string;
    /**
     * The hash code for the password recovery.
     */
    "hash": string;
}

/**
 * This object represents a password recovery request.
 */
export interface PasswordResetReq {
    /**
     * Email address.
     */
    "email": string;
}

/**
 * This object represents a policy. Either the feature or the resource must be specified.
 */
export interface Policy {
    /**
     * Comma separated list of actions, empty string represents all actions.
     */
    "action"?: string;
    /**
     * Resource that is protected by this policy.
     */
    "resource"?: string;
    /**
     * Feature name corresponding to this policy.
     */
    "feature"?: string;
    /**
     * True or false controlling whether an action is allowed or not.
     */
    "allow"?: boolean;
}

/**
 * This object represents a trusted certificate in requests.
 */
export type TrustedCertificateReqServiceEnum = "lwm2m" | "bootstrap" | "provisioning";
export interface TrustedCertificateReq {
    /**
     * Base64 encoded signature of the account ID signed by the certificate to be uploaded. Signature must be hashed with SHA256.
     */
    "signature": string;
    /**
     * X509.v3 trusted certificate in PEM or base64 encoded DER format.
     */
    "cert_data": string;
    /**
     * Certificate name.
     */
    "name": string;
    /**
     * Service name where the certificate must be used.
     */
    "service": TrustedCertificateReqServiceEnum;
    /**
     * Human readable description of this certificate.
     */
    "description"?: string;
}

/**
 * This object represents a trusted certificate in responses.
 */
export type TrustedCertificateRespServiceEnum = "lwm2m" | "bootstrap" | "provisioning";
export type TrustedCertificateRespObjectEnum = "user" | "api-key" | "group" | "account" | "account-template" | "trusted-cert" | "list" | "error";
export interface TrustedCertificateResp {
    /**
     * Human readable description of this certificate.
     */
    "description"?: string;
    /**
     * Service name where the certificate is to be used.
     */
    "service": TrustedCertificateRespServiceEnum;
    /**
     * Device execution mode where 1 means a developer certificate.
     */
    "device_execution_mode": number;
    /**
     * Creation UTC time RFC3339.
     */
    "created_at"?: string;
    /**
     * Entity name: always 'trusted-cert'
     */
    "object": TrustedCertificateRespObjectEnum;
    /**
     * Subject of the certificate.
     */
    "subject": string;
    /**
     * The UUID of the account.
     */
    "account_id": string;
    /**
     * API resource entity version.
     */
    "etag": string;
    /**
     * Expiration time in UTC formatted as RFC3339.
     */
    "validity": string;
    "creationTimeMillis"?: number;
    /**
     * Issuer of the certificate.
     */
    "issuer": string;
    /**
     * X509.v3 trusted certificate in PEM or base64 encoded DER format.
     */
    "cert_data": string;
    /**
     * Entity ID.
     */
    "id": string;
    /**
     * Certificate name.
     */
    "name": string;
}

export type TrustedCertificateRespListObjectEnum = "user" | "api-key" | "group" | "account" | "account-template" | "trusted-cert" | "list" | "error";
export type TrustedCertificateRespListOrderEnum = "ASC" | "DESC";
export interface TrustedCertificateRespList {
    /**
     * The entity ID to fetch after the given one.
     */
    "after"?: string;
    /**
     * Flag indicating whether there is more results.
     */
    "has_more": boolean;
    /**
     * The total number or records, if requested. It might be returned also for small lists.
     */
    "total_count": number;
    /**
     * Entity name: always 'list'
     */
    "object": TrustedCertificateRespListObjectEnum;
    /**
     * The number of results to return, (range: 2-1000), or equals to `total_count`
     */
    "limit": number;
    /**
     * A list of entities.
     */
    "data": Array<TrustedCertificateResp>;
    /**
     * The order of the records to return. Available values: ASC, DESC; by default ASC.
     */
    "order"?: TrustedCertificateRespListOrderEnum;
}

/**
 * This object represents a user in requests towards mbed Cloud.
 */
export interface UserInfoReq {
    /**
     * A username containing alphanumerical letters and -,._@+= characters.
     */
    "username": string;
    /**
     * Phone number.
     */
    "phone_number"?: string;
    /**
     * A flag indicating that receiving marketing information has been accepted.
     */
    "is_marketing_accepted"?: boolean;
    /**
     * A list of IDs of the groups this user belongs to.
     */
    "groups"?: Array<string>;
    /**
     * A flag indicating that the General Terms and Conditions has been accepted.
     */
    "is_gtc_accepted"?: boolean;
    /**
     * ID of the user to be adopted, not used in create or invite cases.
     */
    "id": string;
    /**
     * The full name of the user.
     */
    "full_name"?: string;
    /**
     * Address.
     */
    "address"?: string;
    /**
     * The password when creating a new user. It will will generated when not present in the request.
     */
    "password"?: string;
    /**
     * The email address.
     */
    "email": string;
}

/**
 * This object represents a user in mbed Cloud.
 */
export type UserInfoRespStatusEnum = "ENROLLING" | "INVITED" | "ACTIVE" | "RESET" | "INACTIVE";
export type UserInfoRespObjectEnum = "user" | "api-key" | "group" | "account" | "account-template" | "trusted-cert" | "list" | "error";
export interface UserInfoResp {
    /**
     * The status of the user. INVITED means that the user has not accepted the invitation request. RESET means that the password must be changed immediately.
     */
    "status": UserInfoRespStatusEnum;
    /**
     * A username containing alphanumerical letters and -,._@+= characters.
     */
    "username": string;
    /**
     * A flag indicating whether the user's email address has been verified or not.
     */
    "email_verified"?: boolean;
    /**
     * The UUID of the account.
     */
    "account_id": string;
    /**
     * A timestamp of the latest change of the user password, in milliseconds.
     */
    "password_changed_time"?: number;
    /**
     * A list of IDs of the groups this user belongs to.
     */
    "groups"?: Array<string>;
    /**
     * Creation UTC time RFC3339.
     */
    "created_at"?: string;
    /**
     * Entity name: always 'user'
     */
    "object": UserInfoRespObjectEnum;
    /**
     * A flag indicating that the General Terms and Conditions has been accepted.
     */
    "is_gtc_accepted"?: boolean;
    /**
     * The email address.
     */
    "email": string;
    /**
     * A flag indicating that receiving marketing information has been accepted.
     */
    "is_marketing_accepted"?: boolean;
    /**
     * API resource entity version.
     */
    "etag": string;
    /**
     * The full name of the user.
     */
    "full_name"?: string;
    /**
     * Address.
     */
    "address"?: string;
    "creationTimeMillis"?: number;
    /**
     * A timestamp of the user creation in the storage, in milliseconds.
     */
    "creation_time"?: number;
    /**
     * The password when creating a new user. It will will generated when not present in the request.
     */
    "password"?: string;
    /**
     * Phone number.
     */
    "phone_number"?: string;
    /**
     * The UUID of the user.
     */
    "id": string;
    /**
     * A timestamp of the latest login of the user, in milliseconds.
     */
    "last_login_time"?: number;
}

export type UserInfoRespListObjectEnum = "user" | "api-key" | "group" | "account" | "account-template" | "trusted-cert" | "list" | "error";
export type UserInfoRespListOrderEnum = "ASC" | "DESC";
export interface UserInfoRespList {
    /**
     * The entity ID to fetch after the given one.
     */
    "after"?: string;
    /**
     * Flag indicating whether there is more results.
     */
    "has_more": boolean;
    /**
     * The total number or records, if requested. It might be returned also for small lists.
     */
    "total_count": number;
    /**
     * Entity name: always 'list'
     */
    "object": UserInfoRespListObjectEnum;
    /**
     * The number of results to return, (range: 2-1000), or equals to `total_count`
     */
    "limit": number;
    /**
     * A list of entities.
     */
    "data": Array<UserInfoResp>;
    /**
     * The order of the records to return. Available values: ASC, DESC; by default ASC.
     */
    "order"?: UserInfoRespListOrderEnum;
}

/**
 * This object represents a user in requests towards mbed Cloud.
 */
export interface UserUpdateReq {
    /**
     * A username containing alphanumerical letters and -,._@+= characters.
     */
    "username": string;
    /**
     * Phone number.
     */
    "phone_number"?: string;
    /**
     * A flag indicating that receiving marketing information has been accepted.
     */
    "is_marketing_accepted"?: boolean;
    /**
     * A flag indicating that the General Terms and Conditions has been accepted.
     */
    "is_gtc_accepted"?: boolean;
    /**
     * The full name of the user.
     */
    "full_name"?: string;
    /**
     * Address.
     */
    "address"?: string;
    /**
     * The password when creating a new user. It will will generated when not present in the request.
     */
    "password"?: string;
    /**
     * The email address.
     */
    "email": string;
}

/**
 * AccountAdminApi
 */
export class AccountAdminApi extends ApiBase {

    /** 
     * Upload a new trusted certificate.
     * An endpoint for uploading new trusted certificates.
     * @param body A trusted certificate object with attributes.
     */
    addCertificate (body: TrustedCertificateReq, callback?: (error:any, data?:TrustedCertificateResp, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new Error("Required parameter 'body' missing when calling 'addCertificate'."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request({
            url: '/v3/trusted-certificates',
            method: 'POST',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
            body: body,
        }, callback);
    }
    /** 
     * Create a new user.
     * An endpoint for creating a new user.
     * @param body A user object with attributes.
     * @param action Action, either &#39;create&#39; or &#39;invite&#39;.
     */
    createUser (body: UserInfoReq, action?: string, callback?: (error:any, data?:UserInfoResp, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new Error("Required parameter 'body' missing when calling 'createUser'."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};
        if (action !== undefined) {
            queryParameters['action'] = action;
        }

        let useFormData = false;
        let formParams: any = {};

        return this.request({
            url: '/v3/users',
            method: 'POST',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
            body: body,
        }, callback);
    }
    /** 
     * Delete a trusted certificate by ID.
     * An endpoint for deleting a trusted certificate.
     * @param certId The ID of the trusted certificate to be deleted.
     */
    deleteCertificate (certId: string, callback?: (error:any, data?:any, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "certId" is set
        if (certId === null || certId === undefined) {
            if (callback) {
                callback(new Error("Required parameter 'certId' missing when calling 'deleteCertificate'."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request({
            url: '/v3/trusted-certificates/{cert-id}'.replace('{' + 'cert-id' + '}', String(certId)),
            method: 'DELETE',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /** 
     * Delete a user.
     * An endpoint for deleting a user.
     * @param userId The ID of the user to be deleted.
     * @param force A flag indicating that the user is forced to be deleted.
     */
    deleteUser (userId: string, force?: string, callback?: (error:any, data?:any, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "userId" is set
        if (userId === null || userId === undefined) {
            if (callback) {
                callback(new Error("Required parameter 'userId' missing when calling 'deleteUser'."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};
        if (force !== undefined) {
            queryParameters['force'] = force;
        }

        let useFormData = false;
        let formParams: any = {};

        return this.request({
            url: '/v3/users/{user-id}'.replace('{' + 'user-id' + '}', String(userId)),
            method: 'DELETE',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /** 
     * Get all trusted certificates.
     * An endpoint for retrieving trusted certificates in an array.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     * @param serviceEq Service filter, either lwm2m or bootstrap
     * @param expireEq Expire filter in days
     * @param deviceExecutionModeEq Device execution mode, as 1 for developer certificates or as another natural integer value
     */
    getAllCertificates (limit?: number, after?: string, order?: string, include?: string, serviceEq?: string, expireEq?: number, deviceExecutionModeEq?: number, callback?: (error:any, data?:TrustedCertificateRespList, response?: superagent.Response) => any): superagent.SuperAgentRequest {

        let headerParams: any = {};

        let queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (after !== undefined) {
            queryParameters['after'] = after;
        }
        if (order !== undefined) {
            queryParameters['order'] = order;
        }
        if (include !== undefined) {
            queryParameters['include'] = include;
        }
        if (serviceEq !== undefined) {
            queryParameters['service__eq'] = serviceEq;
        }
        if (expireEq !== undefined) {
            queryParameters['expire__eq'] = expireEq;
        }
        if (deviceExecutionModeEq !== undefined) {
            queryParameters['device_execution_mode__eq'] = deviceExecutionModeEq;
        }

        let useFormData = false;
        let formParams: any = {};

        return this.request({
            url: '/v3/trusted-certificates',
            method: 'GET',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /** 
     * Get the details of all users.
     * An endpoint for retrieving the details of all users.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     * @param statusEq Filter for status, for example active or reset
     */
    getAllUsers (limit?: number, after?: string, order?: string, include?: string, statusEq?: string, callback?: (error:any, data?:UserInfoRespList, response?: superagent.Response) => any): superagent.SuperAgentRequest {

        let headerParams: any = {};

        let queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (after !== undefined) {
            queryParameters['after'] = after;
        }
        if (order !== undefined) {
            queryParameters['order'] = order;
        }
        if (include !== undefined) {
            queryParameters['include'] = include;
        }
        if (statusEq !== undefined) {
            queryParameters['status__eq'] = statusEq;
        }

        let useFormData = false;
        let formParams: any = {};

        return this.request({
            url: '/v3/users',
            method: 'GET',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /** 
     * Get trusted certificate by ID.
     * An endpoint for retrieving a trusted certificate by ID.
     * @param certId The ID or name of the trusted certificate to be retrieved.
     */
    getCertificate (certId: string, callback?: (error:any, data?:TrustedCertificateResp, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "certId" is set
        if (certId === null || certId === undefined) {
            if (callback) {
                callback(new Error("Required parameter 'certId' missing when calling 'getCertificate'."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request({
            url: '/v3/trusted-certificates/{cert-id}'.replace('{' + 'cert-id' + '}', String(certId)),
            method: 'GET',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /** 
     * Details of a user.
     * An endpoint for retrieving the details of a user.
     * @param userId The ID or name of the user whose details are retrieved.
     */
    getUser (userId: string, callback?: (error:any, data?:UserInfoResp, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "userId" is set
        if (userId === null || userId === undefined) {
            if (callback) {
                callback(new Error("Required parameter 'userId' missing when calling 'getUser'."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request({
            url: '/v3/users/{user-id}'.replace('{' + 'user-id' + '}', String(userId)),
            method: 'GET',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /** 
     * Update trusted certificate.
     * An endpoint for updating existing trusted certificates.
     * @param certId The ID of the trusted certificate to be updated.
     * @param body A trusted certificate object with attributes.
     */
    updateCertificate (certId: string, body: TrustedCertificateReq, callback?: (error:any, data?:TrustedCertificateResp, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "certId" is set
        if (certId === null || certId === undefined) {
            if (callback) {
                callback(new Error("Required parameter 'certId' missing when calling 'updateCertificate'."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new Error("Required parameter 'body' missing when calling 'updateCertificate'."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request({
            url: '/v3/trusted-certificates/{cert-id}'.replace('{' + 'cert-id' + '}', String(certId)),
            method: 'PUT',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
            body: body,
        }, callback);
    }
    /** 
     * Updates attributes of the account.
     * An endpoint for updating the account.
     * @param body Details of the account to be updated.
     */
    updateMyAccount (body: AccountUpdateReq, callback?: (error:any, data?:AccountInfo, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new Error("Required parameter 'body' missing when calling 'updateMyAccount'."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request({
            url: '/v3/accounts/me',
            method: 'PUT',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
            body: body,
        }, callback);
    }
    /** 
     * Update user details.
     * An endpoint for updating user details.
     * @param userId The ID of the user whose details are updated.
     * @param body A user object with attributes.
     */
    updateUser (userId: string, body: UserUpdateReq, callback?: (error:any, data?:UserInfoResp, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "userId" is set
        if (userId === null || userId === undefined) {
            if (callback) {
                callback(new Error("Required parameter 'userId' missing when calling 'updateUser'."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new Error("Required parameter 'body' missing when calling 'updateUser'."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request({
            url: '/v3/users/{user-id}'.replace('{' + 'user-id' + '}', String(userId)),
            method: 'PUT',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
            body: body,
        }, callback);
    }
}

/**
 * DefaultApi
 */
export class DefaultApi extends ApiBase {

    /** 
     * Accept invitation.
     * Accepting pending invitation and providing missing details.
     * @param invitationId Invitation ID received in email.
     * @param body Details of the user accepting the invitation.
     */
    activateUser (invitationId: string, body: UserUpdateReq, callback?: (error:any, data?:UserInfoResp, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "invitationId" is set
        if (invitationId === null || invitationId === undefined) {
            if (callback) {
                callback(new Error("Required parameter 'invitationId' missing when calling 'activateUser'."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new Error("Required parameter 'body' missing when calling 'activateUser'."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request({
            url: '/auth/invitations/{invitation-id}'.replace('{' + 'invitation-id' + '}', String(invitationId)),
            method: 'PUT',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
            body: body,
        }, callback);
    }
    /** 
     * Apply password recovery.
     * Applying password recovery by providing a secret hash code.
     * @param body Hash received by email and new password.
     * @param xForwardedFor 
     */
    applyPasswordRecovery (body: PasswordRecoveryReq, xForwardedFor?: string, callback?: (error:any, data?:any, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new Error("Required parameter 'body' missing when calling 'applyPasswordRecovery'."));
            }
            return;
        }

        let headerParams: any = {};
        headerParams['X-Forwarded-For'] = xForwardedFor;

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request({
            url: '/auth/recover',
            method: 'PUT',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
            body: body,
        }, callback);
    }
    /** 
     * Get invited user.
     * Returns information about the user being invited.
     * @param invitationId Invitation ID received in email.
     */
    getInvitedUser (invitationId: string, callback?: (error:any, data?:UserInfoResp, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "invitationId" is set
        if (invitationId === null || invitationId === undefined) {
            if (callback) {
                callback(new Error("Required parameter 'invitationId' missing when calling 'getInvitedUser'."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request({
            url: '/auth/invitations/{invitation-id}'.replace('{' + 'invitation-id' + '}', String(invitationId)),
            method: 'GET',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /** 
     * Get registering user.
     * Retrieving the details of a user to register.
     * @param signupId ID received while signing up.
     */
    getSelfEnrollingUser (signupId: string, callback?: (error:any, data?:AccountSignupResp, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "signupId" is set
        if (signupId === null || signupId === undefined) {
            if (callback) {
                callback(new Error("Required parameter 'signupId' missing when calling 'getSelfEnrollingUser'."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request({
            url: '/auth/register/{signup-id}'.replace('{' + 'signup-id' + '}', String(signupId)),
            method: 'GET',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /** 
     * Register a new account.
     * An endpoint for registering a new account.
     * @param signupId ID received while signing up.
     * @param body Details of the account to be created.
     */
    registerAccount (signupId: string, body: AccountEnrollmentReq, callback?: (error:any, data?:AccountEnrollmentResp, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "signupId" is set
        if (signupId === null || signupId === undefined) {
            if (callback) {
                callback(new Error("Required parameter 'signupId' missing when calling 'registerAccount'."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new Error("Required parameter 'body' missing when calling 'registerAccount'."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request({
            url: '/auth/register/{signup-id}'.replace('{' + 'signup-id' + '}', String(signupId)),
            method: 'PUT',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
            body: body,
        }, callback);
    }
    /** 
     * Request password recovery.
     * Requesting password recovery by email address.
     * @param body Email address of the user whose password needs to be recovered.
     * @param xForwardedFor 
     */
    requestPasswordRecovery (body: PasswordResetReq, xForwardedFor?: string, callback?: (error:any, data?:any, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new Error("Required parameter 'body' missing when calling 'requestPasswordRecovery'."));
            }
            return;
        }

        let headerParams: any = {};
        headerParams['X-Forwarded-For'] = xForwardedFor;

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request({
            url: '/auth/recover',
            method: 'POST',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
            body: body,
        }, callback);
    }
    /** 
     * Sign up for a new account.
     * Signing up for a new free tier account with email address.
     * @param body Email address of the user to be signed up.
     */
    signup (body: AccountSignupReq, callback?: (error:any, data?:AccountSignupResp, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new Error("Required parameter 'body' missing when calling 'signup'."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request({
            url: '/auth/register',
            method: 'POST',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
            body: body,
        }, callback);
    }
    /** 
     * Verify self-enrollment code and aliases.
     * Verifying whether the code received by email is valid. Optionally, it also verifies whether an account with the given aliases exists.
     * @param signupId ID received while signing up.
     * @param body Verification code received by email and aliases to be checked.
     */
    verifySelfEnrollment (signupId: string, body?: AccountSignupVerify, callback?: (error:any, data?:any, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "signupId" is set
        if (signupId === null || signupId === undefined) {
            if (callback) {
                callback(new Error("Required parameter 'signupId' missing when calling 'verifySelfEnrollment'."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request({
            url: '/auth/register/{signup-id}'.replace('{' + 'signup-id' + '}', String(signupId)),
            method: 'POST',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
            body: body,
        }, callback);
    }
}

/**
 * DeveloperApi
 */
export class DeveloperApi extends ApiBase {

    /** 
     * Create a new API key.
     * An endpoint for creating a new API key.
     * @param body The details of the API key to be created.
     */
    createApiKey (body: ApiKeyInfoReq, callback?: (error:any, data?:ApiKeyInfoResp, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new Error("Required parameter 'body' missing when calling 'createApiKey'."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request({
            url: '/v3/api-keys',
            method: 'POST',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
            body: body,
        }, callback);
    }
    /** 
     * Delete API key.
     * An endpoint for deleting the API key.
     * @param apiKey The ID of the API key to be deleted.
     */
    deleteApiKey (apiKey: string, callback?: (error:any, data?:any, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "apiKey" is set
        if (apiKey === null || apiKey === undefined) {
            if (callback) {
                callback(new Error("Required parameter 'apiKey' missing when calling 'deleteApiKey'."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request({
            url: '/v3/api-keys/{apiKey}'.replace('{' + 'apiKey' + '}', String(apiKey)),
            method: 'DELETE',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /** 
     * Get all API keys
     * An endpoint for retrieving API keys in an array, optionally filtered by the owner.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     * @param ownerEq Owner name filter.
     */
    getAllApiKeys (limit?: number, after?: string, order?: string, include?: string, ownerEq?: string, callback?: (error:any, data?:ApiKeyInfoRespList, response?: superagent.Response) => any): superagent.SuperAgentRequest {

        let headerParams: any = {};

        let queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (after !== undefined) {
            queryParameters['after'] = after;
        }
        if (order !== undefined) {
            queryParameters['order'] = order;
        }
        if (include !== undefined) {
            queryParameters['include'] = include;
        }
        if (ownerEq !== undefined) {
            queryParameters['owner__eq'] = ownerEq;
        }

        let useFormData = false;
        let formParams: any = {};

        return this.request({
            url: '/v3/api-keys',
            method: 'GET',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /** 
     * Get API key details.
     * An endpoint for retrieving API key details.
     * @param apiKey The ID of the API key to be retrieved.
     */
    getApiKey (apiKey: string, callback?: (error:any, data?:ApiKeyInfoResp, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "apiKey" is set
        if (apiKey === null || apiKey === undefined) {
            if (callback) {
                callback(new Error("Required parameter 'apiKey' missing when calling 'getApiKey'."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request({
            url: '/v3/api-keys/{apiKey}'.replace('{' + 'apiKey' + '}', String(apiKey)),
            method: 'GET',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /** 
     * Get account info.
     * Returns detailed information about the account.
     * @param include Comma separated additional data to return. Currently supported: limits, policies, sub_accounts
     */
    getMyAccountInfo (include?: string, callback?: (error:any, data?:AccountInfo, response?: superagent.Response) => any): superagent.SuperAgentRequest {

        let headerParams: any = {};

        let queryParameters: any = {};
        if (include !== undefined) {
            queryParameters['include'] = include;
        }

        let useFormData = false;
        let formParams: any = {};

        return this.request({
            url: '/v3/accounts/me',
            method: 'GET',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /** 
     * Get API key details.
     * An endpoint for retrieving API key details.
     */
    getMyApiKey (callback?: (error:any, data?:ApiKeyInfoResp, response?: superagent.Response) => any): superagent.SuperAgentRequest {

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request({
            url: '/v3/api-keys/me',
            method: 'GET',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /** 
     * Details of the current user.
     * An endpoint for retrieving the details of the logged in user.
     */
    getMyUser (callback?: (error:any, data?:UserInfoResp, response?: superagent.Response) => any): superagent.SuperAgentRequest {

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request({
            url: '/v3/users/me',
            method: 'GET',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /** 
     * Update API key details.
     * An endpoint for updating API key details.
     * @param apiKey The ID of the API key to be updated.
     * @param body New API key attributes to be stored.
     */
    updateApiKey (apiKey: string, body: ApiKeyUpdateReq, callback?: (error:any, data?:ApiKeyInfoResp, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "apiKey" is set
        if (apiKey === null || apiKey === undefined) {
            if (callback) {
                callback(new Error("Required parameter 'apiKey' missing when calling 'updateApiKey'."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new Error("Required parameter 'body' missing when calling 'updateApiKey'."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request({
            url: '/v3/api-keys/{apiKey}'.replace('{' + 'apiKey' + '}', String(apiKey)),
            method: 'PUT',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
            body: body,
        }, callback);
    }
    /** 
     * Update API key details.
     * An endpoint for updating API key details.
     * @param body New API key attributes to be stored.
     */
    updateMyApiKey (body: ApiKeyUpdateReq, callback?: (error:any, data?:ApiKeyInfoResp, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new Error("Required parameter 'body' missing when calling 'updateMyApiKey'."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request({
            url: '/v3/api-keys/me',
            method: 'PUT',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
            body: body,
        }, callback);
    }
    /** 
     * Update user details.
     * An endpoint for updating the details of the logged in user.
     * @param body New attributes for the logged in user.
     */
    updateMyUser (body: UserUpdateReq, callback?: (error:any, data?:UserInfoResp, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new Error("Required parameter 'body' missing when calling 'updateMyUser'."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request({
            url: '/v3/users/me',
            method: 'PUT',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
            body: body,
        }, callback);
    }
}

