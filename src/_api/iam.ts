/**
 * IAM Identities REST API
 * REST API to manage accounts, groups, users and API keys
 *
 * OpenAPI spec version: v3
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import superagent = require('superagent');

let defaultBasePath = 'https://api.mbedcloud.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

export interface RequestOptions {
    auth?:{username?:string, password?:string};
    form?:any;
    formData?:any;
    method?:string;
    qs?:any;
    headers?:any;
    uri?:string;
    useQuerystring?: boolean;
    json?: boolean;
    encoding?: string | null;
    body?:any;
}

export function request(options:any, callback?:Function): superagent.SuperAgentRequest {
    var url = options.uri;

    // Normalize slashes in url
    url = url.replace(/([:])?\/+/g, function($0, $1) {
        return $1 ? $0: "/";
    });

    var request = superagent(options.method, url);

    if (options.auth && (options.auth.username || options.auth.password)) {
        request.auth(options.auth.username || '', options.auth.password || '');
    }

    // set query parameters
    request.query(normalizeParams(options.qs));

    // set header parameters
    request.set(normalizeParams(options.headers));

    // set request timeout
    request.timeout(60000);

    if (options.json) {
        request.type("application/json");
        request.accept("application/json");
    }

    if (options.form) {
        request.type("application/x-www-form-urlencoded");
        request.send(normalizeParams(options.form));
    } else if (options.formData) {
        request.type("multipart/form-data");
        var formParams = normalizeParams(options.formData);
        for (var key in formParams) {
            if (formParams.hasOwnProperty(key)) {
                if (isFileParam(formParams[key])) {
                    // file field
                    request.attach(key, formParams[key]);
                } else {
                    request.field(key, formParams[key]);
                }
            }
        }
    } else if (options.body) {
        request.send(options.body);
    }

    request.end(function(error, response) {
        if (callback) {
            var data = null;

            if (response && !error) {
                data = response.body || response.text;
            }

            callback(error, data, response);
        }
    });

    return request;
}

/**
* Normalizes parameter values:
* <ul>
* <li>remove nils</li>
* <li>keep files and arrays</li>
* <li>format to string with `paramToString` for other cases</li>
* </ul>
* @param {Object.<String, Object>} params The parameters as object properties.
* @returns {Object.<String, Object>} normalized parameters.
*/
export function normalizeParams(params:any) {
    var newParams = {};

    for (var key in params) {
        if (params.hasOwnProperty(key) && params[key] != undefined && params[key] != null) {
            var value = params[key];
            if (isFileParam(value) || Array.isArray(value)) {
                newParams[key] = value;
            } else {
                newParams[key] = paramToString(value);
            }
        }
    }

    return newParams;
}

/**
* Checks whether the given parameter value represents file-like content.
* @param param The parameter to check.
* @returns {Boolean} <code>true</code> if <code>param</code> represents a file.
*/
export function isFileParam(param:any) {
    // fs.ReadStream in Node.js (but not in runtime like browserify)
    if (typeof window === 'undefined' &&
        typeof require === 'function' &&
        require('fs') &&
        param instanceof require('fs').ReadStream) {
        return true;
    }

    // Buffer in Node.js
    if (typeof Buffer === 'function' && param instanceof Buffer) {
        return true;
    }

    // Blob in browser
    if (typeof Blob === 'function' && param instanceof Blob) {
        return true;
    }

    // File in browser (it seems File object is also instance of Blob, but keep this for safe)
    if (typeof File === 'function' && param instanceof File) {
        return true;
    }

    return false;
}

/**
* Returns a string representation for an actual parameter.
* @param param The actual parameter.
* @returns {String} The string representation of <code>param</code>.
*/
export function paramToString(param:any) {
    if (param == undefined || param == null) {
        return '';
    }

    if (param instanceof Date) {
        return param.toJSON();
    }

    return param.toString();
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: RequestOptions): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: RequestOptions): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: RequestOptions): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: RequestOptions): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(_: RequestOptions): void {
        // Do nothing
    }
}

/**
 * This object represents an account creation response.
 */
export interface AccountEnrollmentReq {
    /**
     * A username for the new account admin containing alphanumerical letters and -,._@+= characters.
     */
    "username": string;
    /**
     * The password for the new account admin.
     */
    "password": string;
    /**
     * Verification code.
     */
    "code": string;
    /**
     * An array of aliases.
     */
    "aliases"?: Array<string>;
}

/**
 * This object represents an account creation response.
 */
export interface AccountEnrollmentResp {
    /**
     * The status of the user. INVITED means that the user has not accepted the invitation request. RESET means that the password must be changed immediately.
     */
    "status": AccountEnrollmentRespStatusEnum;
    /**
     * A username containing alphanumerical letters and -,._@+= characters.
     */
    "username": string;
    /**
     * A flag indicating whether the user's email address has been verified or not.
     */
    "email_verified"?: boolean;
    /**
     * The UUID of the account.
     */
    "account_id": string;
    /**
     * A timestamp of the latest change of the user password, in milliseconds.
     */
    "password_changed_time"?: number;
    /**
     * An array of aliases.
     */
    "aliases": Array<string>;
    /**
     * A list of IDs of the groups this user belongs to.
     */
    "groups"?: Array<string>;
    /**
     * Creation UTC time RFC3339.
     */
    "created_at"?: string;
    /**
     * Entity name: always 'user'
     */
    "object": AccountEnrollmentRespObjectEnum;
    /**
     * A flag indicating that the General Terms and Conditions has been accepted.
     */
    "is_gtc_accepted"?: boolean;
    /**
     * The email address.
     */
    "email": string;
    /**
     * A flag indicating that receiving marketing information has been accepted.
     */
    "is_marketing_accepted"?: boolean;
    /**
     * API resource entity version.
     */
    "etag": string;
    /**
     * The full name of the user.
     */
    "full_name"?: string;
    /**
     * Address.
     */
    "address"?: string;
    "creationTimeMillis"?: number;
    /**
     * A timestamp of the user creation in the storage, in milliseconds.
     */
    "creation_time"?: number;
    /**
     * The password when creating a new user. It will will generated when not present in the request.
     */
    "password"?: string;
    /**
     * Phone number.
     */
    "phone_number"?: string;
    /**
     * The UUID of the user.
     */
    "id": string;
    /**
     * A timestamp of the latest login of the user, in milliseconds.
     */
    "last_login_time"?: number;
}

export type AccountEnrollmentRespStatusEnum = "INVITED" | "ACTIVE" | "RESET" | "INACTIVE";
export type AccountEnrollmentRespObjectEnum = "user" | "api_key" | "group" | "account" | "account_template" | "ca_cert" | "list" | "error";
/**
 * This object represents an account in requests and responses.
 */
export interface AccountInfo {
    /**
     * The status of the account.
     */
    "status": AccountInfoStatusEnum;
    /**
     * The postal code part of the postal address.
     */
    "postal_code"?: string;
    /**
     * The ID of the parent account, if it has any.
     */
    "parentID"?: string;
    /**
     * Account ID.
     */
    "id": string;
    /**
     * An array of aliases.
     */
    "aliases": Array<string>;
    /**
     * Postal address line 2.
     */
    "address_line2"?: string;
    /**
     * The city part of the postal address.
     */
    "city"?: string;
    /**
     * Postal address line 1.
     */
    "address_line1"?: string;
    /**
     * The display name for the account.
     */
    "display_name"?: string;
    /**
     * The state part of the postal address.
     */
    "state"?: string;
    /**
     * API resource entity version.
     */
    "etag": string;
    /**
     * Flag (true/false) indicating whether Factory Tool is allowed to download or not.
     */
    "is_provisioning_allowed": boolean;
    "creationTimeMillis"?: number;
    /**
     * The company email address for this account.
     */
    "email"?: string;
    /**
     * The phone number of the company.
     */
    "phone_number"?: string;
    /**
     * The name of the company.
     */
    "company"?: string;
    /**
     * Entity name: always 'account'
     */
    "object": AccountInfoObjectEnum;
    /**
     * Time when upgraded to commercial account in UTC format RFC3339.
     */
    "upgraded_at"?: string;
    /**
     * The tier level of the account; '0': free tier, '1': commercial account. Other values are reserved for the future.
     */
    "tier": string;
    /**
     * List of limits as key-value pairs if requested.
     */
    "limits"?: { [key: string]: string; };
    /**
     * The country part of the postal address.
     */
    "country"?: string;
    /**
     * Creation UTC time RFC3339.
     */
    "created_at"?: string;
    /**
     * The name of the contact person for this account.
     */
    "contact"?: string;
    /**
     * List of policies if requested.
     */
    "policies"?: Array<Policy>;
    /**
     * Account template ID.
     */
    "template_id"?: string;
}

export type AccountInfoStatusEnum = "ENROLLING" | "ACTIVE" | "SUSPENDED" | "DISABLED";
export type AccountInfoObjectEnum = "user" | "api_key" | "group" | "account" | "account_template" | "ca_cert" | "list" | "error";
/**
 * This object represents a service sign-up request.
 */
export interface AccountSignupReq {
    /**
     * The phone number of the user.
     */
    "phone_number"?: string;
    /**
     * A flag indicating that receiving marketing information has been accepted.
     */
    "is_marketing_accepted"?: boolean;
    /**
     * The country for the company.
     */
    "country": string;
    /**
     * The name of the company.
     */
    "company": string;
    /**
     * A flag indicating that the General Terms and Conditions has been accepted.
     */
    "is_gtc_accepted"?: boolean;
    /**
     * The full name of the user.
     */
    "full_name": string;
    /**
     * The email address of the user.
     */
    "email": string;
}

/**
 * This object represents a service sign-up request.
 */
export interface AccountSignupResp {
    /**
     * The email address of the user.
     */
    "email": string;
    /**
     * The UUID of the account enrolling.
     */
    "account_id": string;
    /**
     * The sign-up ID.
     */
    "id": string;
}

/**
 * This object represents a verify request during service sign-up process.
 */
export interface AccountSignupVerify {
    /**
     * Verification code, also required while checking account aliases.
     */
    "code": string;
    /**
     * Account alias array to be checked for being unique.
     */
    "aliases"?: Array<string>;
}

/**
 * This object represents an account update request.
 */
export interface AccountUpdateReq {
    /**
     * Postal address line 2.
     */
    "address_line2"?: string;
    /**
     * The city part of the postal address.
     */
    "city"?: string;
    /**
     * Postal address line 1.
     */
    "address_line1"?: string;
    /**
     * The display name for the account.
     */
    "display_name"?: string;
    /**
     * The country part of the postal address.
     */
    "country"?: string;
    /**
     * The name of the company.
     */
    "company"?: string;
    /**
     * Account template ID. Manageable by the root admin only.
     */
    "template_id"?: string;
    /**
     * The status of the account. Manageable by the root admin only.
     */
    "status"?: string;
    /**
     * The state part of the postal address.
     */
    "state"?: string;
    /**
     * The name of the contact person for this account.
     */
    "contact"?: string;
    /**
     * The postal code part of the postal address.
     */
    "postal_code"?: string;
    /**
     * Flag (true/false) indicating whether Factory Tool is allowed to download or not. Manageable by the root admin only.
     */
    "is_provisioning_allowed"?: boolean;
    /**
     * The ID of the parent account, if it has any.
     */
    "parentID"?: string;
    /**
     * The tier level of the account; '0': free tier, '1': commercial account. Other values are reserved for the future. Manageable by the root admin only.
     */
    "tier"?: string;
    /**
     * The phone number of the company.
     */
    "phone_number"?: string;
    /**
     * The company email address for this account.
     */
    "email"?: string;
    /**
     * An array of aliases.
     */
    "aliases"?: Array<string>;
}

/**
 * This object represents an API key in requests towards mbed Cloud.
 */
export interface ApiKeyInfoReq {
    /**
     * The owner of this API key, who is the creator by default.
     */
    "owner"?: string;
    /**
     * The display name for the API key.
     */
    "name": string;
    /**
     * A list of group IDs this API key belongs to.
     */
    "groups"?: Array<string>;
}

/**
 * This object represents an API key in mbed Cloud.
 */
export interface ApiKeyInfoResp {
    /**
     * A list of group IDs this API key belongs to.
     */
    "groups"?: Array<string>;
    /**
     * The status of the API key.
     */
    "status"?: ApiKeyInfoRespStatusEnum;
    /**
     * The display name for the API key.
     */
    "name": string;
    /**
     * Creation UTC time RFC3339.
     */
    "created_at"?: string;
    /**
     * Entity name: always 'api-key'
     */
    "object": ApiKeyInfoRespObjectEnum;
    /**
     * The timestamp of the API key creation in the storage, in milliseconds.
     */
    "creation_time"?: number;
    "creationTimeMillis"?: number;
    /**
     * API resource entity version.
     */
    "etag": string;
    /**
     * The API key.
     */
    "key": string;
    /**
     * The owner of this API key, who is the creator by default.
     */
    "owner"?: string;
    /**
     * The UUID of the API key.
     */
    "id": string;
    /**
     * The timestamp of the latest API key usage, in milliseconds.
     */
    "last_login_time"?: number;
}

export type ApiKeyInfoRespStatusEnum = "ACTIVE" | "INACTIVE";
export type ApiKeyInfoRespObjectEnum = "user" | "api_key" | "group" | "account" | "account_template" | "ca_cert" | "list" | "error";
export interface ApiKeyInfoRespList {
    /**
     * The entity ID to fetch after the given one.
     */
    "after"?: string;
    /**
     * Flag indicating whether there is more results.
     */
    "has_more": boolean;
    /**
     * The total number or records, if requested. It might be returned also for small lists.
     */
    "total_count": number;
    /**
     * Entity name: always 'list'
     */
    "object": ApiKeyInfoRespListObjectEnum;
    /**
     * The number of results to return, (range: 2-1000), or equals to `total_count`
     */
    "limit": number;
    /**
     * A list of entities.
     */
    "data": Array<ApiKeyInfoResp>;
    /**
     * The order of the records to return. Available values: ASC, DESC; by default ASC.
     */
    "order"?: ApiKeyInfoRespListOrderEnum;
}

export type ApiKeyInfoRespListObjectEnum = "user" | "api_key" | "group" | "account" | "account_template" | "ca_cert" | "list" | "error";
export type ApiKeyInfoRespListOrderEnum = "ASC" | "DESC";
/**
 * This object represents an API key in requests towards mbed Cloud.
 */
export interface ApiKeyUpdateReq {
    /**
     * The owner of this API key, who is the creator by default.
     */
    "owner"?: string;
    /**
     * The display name for the API key.
     */
    "name": string;
}

/**
 * This object represents an CA Certificate in requests.
 */
export interface CACertificateReq {
    /**
     * X509.v3 CA certificate in PEM or base64 encoded DER format.
     */
    "cert_data": string;
    /**
     * Certificate name.
     */
    "name": string;
    /**
     * Service name where the certificate must be used.
     */
    "service": CACertificateReqServiceEnum;
    /**
     * Base64 encoded signature of the account ID signed by the certificate to be uploaded. Signature must be hashed with SHA256.
     */
    "signature": string;
}

export type CACertificateReqServiceEnum = "lwm2m" | "bootstrap" | "provisioning";
/**
 * This object represents an CA Certificate in responses.
 */
export interface CACertificateResp {
    /**
     * The UUID of the account.
     */
    "account_id": string;
    /**
     * Service name where the certificate is to be used.
     */
    "service": CACertificateRespServiceEnum;
    /**
     * Creation UTC time RFC3339.
     */
    "created_at"?: string;
    /**
     * Entity name: always 'ca-cert'
     */
    "object": CACertificateRespObjectEnum;
    /**
     * Subject of the certificate.
     */
    "subject": string;
    /**
     * Expiration time in UTC formatted as RFC3339.
     */
    "validity": string;
    /**
     * API resource entity version.
     */
    "etag": string;
    "creationTimeMillis"?: number;
    /**
     * Issuer of the certificate.
     */
    "issuer": string;
    /**
     * X509.v3 CA certificate in PEM or base64 encoded DER format.
     */
    "cert_data": string;
    /**
     * Entity ID.
     */
    "id": string;
    /**
     * Certificate name.
     */
    "name": string;
}

export type CACertificateRespServiceEnum = "lwm2m" | "bootstrap" | "provisioning";
export type CACertificateRespObjectEnum = "user" | "api_key" | "group" | "account" | "account_template" | "ca_cert" | "list" | "error";
export interface CACertificateRespList {
    /**
     * The entity ID to fetch after the given one.
     */
    "after"?: string;
    /**
     * Flag indicating whether there is more results.
     */
    "has_more": boolean;
    /**
     * The total number or records, if requested. It might be returned also for small lists.
     */
    "total_count": number;
    /**
     * Entity name: always 'list'
     */
    "object": CACertificateRespListObjectEnum;
    /**
     * The number of results to return, (range: 2-1000), or equals to `total_count`
     */
    "limit": number;
    /**
     * A list of entities.
     */
    "data": Array<CACertificateResp>;
    /**
     * The order of the records to return. Available values: ASC, DESC; by default ASC.
     */
    "order"?: CACertificateRespListOrderEnum;
}

export type CACertificateRespListObjectEnum = "user" | "api_key" | "group" | "account" | "account_template" | "ca_cert" | "list" | "error";
export type CACertificateRespListOrderEnum = "ASC" | "DESC";
/**
 * This object represents an error message.
 */
export interface ErrorResponse {
    /**
     * Response code.
     */
    "code": number;
    /**
     * Failed input fields during request object validation.
     */
    "fields"?: Array<Field>;
    /**
     * Entity name, always 'error'.
     */
    "object": ErrorResponseObjectEnum;
    /**
     * Request ID.
     */
    "request_id": string;
    /**
     * A human readable message with detailed info.
     */
    "message": string;
    /**
     * Error type.
     */
    "type": ErrorResponseTypeEnum;
}

export type ErrorResponseObjectEnum = "user" | "api_key" | "group" | "account" | "account_template" | "ca_cert" | "list" | "error";
export type ErrorResponseTypeEnum = "success" | "created" | "accepted" | "permanently_deleted" | "validation_error" | "invalid_token" | "access_denied" | "account_limit_exceeded" | "not_found" | "method_not_supported" | "not_acceptable" | "duplicate" | "precondition_failed" | "unsupported_media_type" | "rate_limit_exceeded" | "internal_server_error" | "system_unavailable";
export interface Field {
    "message"?: string;
    "name"?: string;
}

/**
 * This object contains basic information about groups.
 */
export interface GroupSummary {
    /**
     * The name of the group.
     */
    "name": string;
    /**
     * A timestamp of the latest group update, in milliseconds.
     */
    "lastUpdateTime"?: number;
    /**
     * The number of API keys in this group.
     */
    "apiKeyCount": number;
    /**
     * Creation UTC time RFC3339.
     */
    "created_at"?: string;
    /**
     * Entity name: always 'group'
     */
    "object": GroupSummaryObjectEnum;
    /**
     * A timestamp of the group creation in the storage, in milliseconds.
     */
    "creationTime"?: number;
    /**
     * API resource entity version.
     */
    "etag": string;
    "creationTimeMillis"?: number;
    /**
     * The UUID of the group.
     */
    "id": string;
    /**
     * The number of users in this group.
     */
    "userCount": number;
}

export type GroupSummaryObjectEnum = "user" | "api_key" | "group" | "account" | "account_template" | "ca_cert" | "list" | "error";
export interface GroupSummaryList {
    /**
     * The entity ID to fetch after the given one.
     */
    "after"?: string;
    /**
     * Flag indicating whether there is more results.
     */
    "has_more": boolean;
    /**
     * The total number or records, if requested. It might be returned also for small lists.
     */
    "total_count": number;
    /**
     * Entity name: always 'list'
     */
    "object": GroupSummaryListObjectEnum;
    /**
     * The number of results to return, (range: 2-1000), or equals to `total_count`
     */
    "limit": number;
    /**
     * A list of entities.
     */
    "data": Array<GroupSummary>;
    /**
     * The order of the records to return. Available values: ASC, DESC; by default ASC.
     */
    "order"?: GroupSummaryListOrderEnum;
}

export type GroupSummaryListObjectEnum = "user" | "api_key" | "group" | "account" | "account_template" | "ca_cert" | "list" | "error";
export type GroupSummaryListOrderEnum = "ASC" | "DESC";
/**
 * This object represents a password recovery request.
 */
export interface PasswordRecoveryReq {
    /**
     * The new password to be set.
     */
    "password": string;
    /**
     * The hash code for the password recovery.
     */
    "hash": string;
}

/**
 * This object represents a password recovery request.
 */
export interface PasswordResetReq {
    /**
     * Email address.
     */
    "email": string;
}

/**
 * This object represents a policy.
 */
export interface Policy {
    /**
     * Comma separated list of actions, empty string represents all actions.
     */
    "action"?: string;
    /**
     * Resource that is protected by this policy.
     */
    "resource"?: string;
    /**
     * True or false controlling whether an action is allowed or not.
     */
    "allow"?: boolean;
}

/**
 * This object represents a user in requests towards mbed Cloud.
 */
export interface UserInfoReq {
    /**
     * A username containing alphanumerical letters and -,._@+= characters.
     */
    "username": string;
    /**
     * Phone number.
     */
    "phone_number"?: string;
    /**
     * A flag indicating that receiving marketing information has been accepted.
     */
    "is_marketing_accepted"?: boolean;
    /**
     * A list of IDs of the groups this user belongs to.
     */
    "groups"?: Array<string>;
    /**
     * A flag indicating that the General Terms and Conditions has been accepted.
     */
    "is_gtc_accepted"?: boolean;
    /**
     * The full name of the user.
     */
    "full_name"?: string;
    /**
     * Address.
     */
    "address"?: string;
    /**
     * The password when creating a new user. It will will generated when not present in the request.
     */
    "password"?: string;
    /**
     * The email address.
     */
    "email": string;
}

/**
 * This object represents a user in mbed Cloud.
 */
export interface UserInfoResp {
    /**
     * The status of the user. INVITED means that the user has not accepted the invitation request. RESET means that the password must be changed immediately.
     */
    "status": UserInfoRespStatusEnum;
    /**
     * A username containing alphanumerical letters and -,._@+= characters.
     */
    "username": string;
    /**
     * A flag indicating whether the user's email address has been verified or not.
     */
    "email_verified"?: boolean;
    /**
     * The UUID of the account.
     */
    "account_id": string;
    /**
     * A timestamp of the latest change of the user password, in milliseconds.
     */
    "password_changed_time"?: number;
    /**
     * A list of IDs of the groups this user belongs to.
     */
    "groups"?: Array<string>;
    /**
     * Creation UTC time RFC3339.
     */
    "created_at"?: string;
    /**
     * Entity name: always 'user'
     */
    "object": UserInfoRespObjectEnum;
    /**
     * A flag indicating that the General Terms and Conditions has been accepted.
     */
    "is_gtc_accepted"?: boolean;
    /**
     * The email address.
     */
    "email": string;
    /**
     * A flag indicating that receiving marketing information has been accepted.
     */
    "is_marketing_accepted"?: boolean;
    /**
     * API resource entity version.
     */
    "etag": string;
    /**
     * The full name of the user.
     */
    "full_name"?: string;
    /**
     * Address.
     */
    "address"?: string;
    "creationTimeMillis"?: number;
    /**
     * A timestamp of the user creation in the storage, in milliseconds.
     */
    "creation_time"?: number;
    /**
     * The password when creating a new user. It will will generated when not present in the request.
     */
    "password"?: string;
    /**
     * Phone number.
     */
    "phone_number"?: string;
    /**
     * The UUID of the user.
     */
    "id": string;
    /**
     * A timestamp of the latest login of the user, in milliseconds.
     */
    "last_login_time"?: number;
}

export type UserInfoRespStatusEnum = "INVITED" | "ACTIVE" | "RESET" | "INACTIVE";
export type UserInfoRespObjectEnum = "user" | "api_key" | "group" | "account" | "account_template" | "ca_cert" | "list" | "error";
export interface UserInfoRespList {
    /**
     * The entity ID to fetch after the given one.
     */
    "after"?: string;
    /**
     * Flag indicating whether there is more results.
     */
    "has_more": boolean;
    /**
     * The total number or records, if requested. It might be returned also for small lists.
     */
    "total_count": number;
    /**
     * Entity name: always 'list'
     */
    "object": UserInfoRespListObjectEnum;
    /**
     * The number of results to return, (range: 2-1000), or equals to `total_count`
     */
    "limit": number;
    /**
     * A list of entities.
     */
    "data": Array<UserInfoResp>;
    /**
     * The order of the records to return. Available values: ASC, DESC; by default ASC.
     */
    "order"?: UserInfoRespListOrderEnum;
}

export type UserInfoRespListObjectEnum = "user" | "api_key" | "group" | "account" | "account_template" | "ca_cert" | "list" | "error";
export type UserInfoRespListOrderEnum = "ASC" | "DESC";
/**
 * This object represents a user in requests towards mbed Cloud.
 */
export interface UserUpdateReq {
    /**
     * A username containing alphanumerical letters and -,._@+= characters.
     */
    "username": string;
    /**
     * Phone number.
     */
    "phone_number"?: string;
    /**
     * A flag indicating that receiving marketing information has been accepted.
     */
    "is_marketing_accepted"?: boolean;
    /**
     * A flag indicating that the General Terms and Conditions has been accepted.
     */
    "is_gtc_accepted"?: boolean;
    /**
     * The full name of the user.
     */
    "full_name"?: string;
    /**
     * Address.
     */
    "address"?: string;
    /**
     * The password when creating a new user. It will will generated when not present in the request.
     */
    "password"?: string;
    /**
     * The email address.
     */
    "email": string;
}


export enum AccountAdminApiApiKeys {
    Bearer,
}

export class AccountAdminApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: AccountAdminApiApiKeys, value: string) {
        this.authentications[AccountAdminApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Upload a new CA certificate.
     * An endpoint for uploading new CA certificates.
     * @param body A CA certificate object with attributes.
     */
    public addCertificate (body: CACertificateReq, callback?: (error:any, data:CACertificateResp, response: superagent.Response) => any): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/v3/ca-certificates';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addCertificate.');
        }

        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, data, response) => {
            if (callback) {
                callback(error, data, response);
            }
        });
    }
    /**
     * Create a new user.
     * An endpoint for creating a new user.
     * @param body A user object with attributes.
     * @param action Action, either &#39;create&#39; or &#39;invite&#39;.
     */
    public createUser (body: UserInfoReq, action?: string, callback?: (error:any, data:UserInfoResp, response: superagent.Response) => any): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/v3/users';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createUser.');
        }

        if (action !== undefined) {
            queryParameters['action'] = action;
        }

        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, data, response) => {
            if (callback) {
                callback(error, data, response);
            }
        });
    }
    /**
     * Delete a CA certificate by ID.
     * An endpoint for deleting a CA certificate.
     * @param caCertId The ID of the CA certificate to be deleted.
     */
    public deleteCertificate (caCertId: string, callback?: (error:any, data:any, response: superagent.Response) => any): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/v3/ca-certificates/{ca-cert-id}'
            .replace('{' + 'ca-cert-id' + '}', String(caCertId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'caCertId' is not null or undefined
        if (caCertId === null || caCertId === undefined) {
            throw new Error('Required parameter caCertId was null or undefined when calling deleteCertificate.');
        }

        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, data, response) => {
            if (callback) {
                callback(error, data, response);
            }
        });
    }
    /**
     * Delete a user.
     * An endpoint for deleting a user.
     * @param userId The ID of the user to be deleted.
     * @param force A flag indicating that the user is forced to be deleted.
     */
    public deleteUser (userId: string, force?: string, callback?: (error:any, data:any, response: superagent.Response) => any): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/v3/users/{user-id}'
            .replace('{' + 'user-id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling deleteUser.');
        }

        if (force !== undefined) {
            queryParameters['force'] = force;
        }

        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, data, response) => {
            if (callback) {
                callback(error, data, response);
            }
        });
    }
    /**
     * Get all CA certificates.
     * An endpoint for retrieving CA certificates in an array.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     * @param filter Filter by service or expiring days, for example filter&#x3D;service%3Dlwm2m,expire%3D180
     */
    public getAllCertificates (limit?: number, after?: string, order?: string, include?: string, filter?: string, callback?: (error:any, data:CACertificateRespList, response: superagent.Response) => any): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/v3/ca-certificates';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (after !== undefined) {
            queryParameters['after'] = after;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        if (include !== undefined) {
            queryParameters['include'] = include;
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, data, response) => {
            if (callback) {
                callback(error, data, response);
            }
        });
    }
    /**
     * Get the details of all users.
     * An endpoint for retrieving the details of all users.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     * @param filter Filter for the query, for example filter&#x3D;status%3Dactive,status%3Dreset.
     */
    public getAllUsers (limit?: number, after?: string, order?: string, include?: string, filter?: string, callback?: (error:any, data:UserInfoRespList, response: superagent.Response) => any): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/v3/users';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (after !== undefined) {
            queryParameters['after'] = after;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        if (include !== undefined) {
            queryParameters['include'] = include;
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, data, response) => {
            if (callback) {
                callback(error, data, response);
            }
        });
    }
    /**
     * Get CA certificate by ID.
     * An endpoint for retrieving a CA certificate by ID.
     * @param caCertId The ID or name of the CA certificate to be retrieved.
     */
    public getCertificate (caCertId: string, callback?: (error:any, data:CACertificateResp, response: superagent.Response) => any): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/v3/ca-certificates/{ca-cert-id}'
            .replace('{' + 'ca-cert-id' + '}', String(caCertId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'caCertId' is not null or undefined
        if (caCertId === null || caCertId === undefined) {
            throw new Error('Required parameter caCertId was null or undefined when calling getCertificate.');
        }

        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, data, response) => {
            if (callback) {
                callback(error, data, response);
            }
        });
    }
    /**
     * Details of a user.
     * An endpoint for retrieving the details of a user.
     * @param userId The ID or name of the user whose details are retrieved.
     */
    public getUser (userId: string, callback?: (error:any, data:UserInfoResp, response: superagent.Response) => any): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/v3/users/{user-id}'
            .replace('{' + 'user-id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUser.');
        }

        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, data, response) => {
            if (callback) {
                callback(error, data, response);
            }
        });
    }
    /**
     * Update CA certificate.
     * An endpoint for updating existing CA certificates.
     * @param caCertId The ID of the CA certificate to be updated.
     * @param body A CA certificate object with attributes.
     */
    public updateCertificate (caCertId: string, body: CACertificateReq, callback?: (error:any, data:CACertificateResp, response: superagent.Response) => any): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/v3/ca-certificates/{ca-cert-id}'
            .replace('{' + 'ca-cert-id' + '}', String(caCertId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'caCertId' is not null or undefined
        if (caCertId === null || caCertId === undefined) {
            throw new Error('Required parameter caCertId was null or undefined when calling updateCertificate.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateCertificate.');
        }

        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, data, response) => {
            if (callback) {
                callback(error, data, response);
            }
        });
    }
    /**
     * Updates attributes of the account.
     * An endpoint for updating the account.
     * @param body Details of the account to be updated.
     */
    public updateMyAccount (body: AccountUpdateReq, callback?: (error:any, data:AccountInfo, response: superagent.Response) => any): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/v3/accounts/me';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateMyAccount.');
        }

        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, data, response) => {
            if (callback) {
                callback(error, data, response);
            }
        });
    }
    /**
     * Update user details.
     * An endpoint for updating user details.
     * @param userId The ID of the user whose details are updated.
     * @param body A user object with attributes.
     */
    public updateUser (userId: string, body: UserUpdateReq, callback?: (error:any, data:UserInfoResp, response: superagent.Response) => any): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/v3/users/{user-id}'
            .replace('{' + 'user-id' + '}', String(userId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling updateUser.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateUser.');
        }

        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, data, response) => {
            if (callback) {
                callback(error, data, response);
            }
        });
    }
}
export enum DefaultApiApiKeys {
    Bearer,
}

export class DefaultApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: DefaultApiApiKeys, value: string) {
        this.authentications[DefaultApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Accept invitation.
     * Accepting pending invitation and providing missing details.
     * @param invitationId Invitation ID received in email.
     * @param body Details of the user accepting the invitation.
     */
    public activateUser (invitationId: string, body: UserUpdateReq, callback?: (error:any, data:UserInfoResp, response: superagent.Response) => any): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/auth/invitations/{invitation-id}'
            .replace('{' + 'invitation-id' + '}', String(invitationId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'invitationId' is not null or undefined
        if (invitationId === null || invitationId === undefined) {
            throw new Error('Required parameter invitationId was null or undefined when calling activateUser.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling activateUser.');
        }

        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, data, response) => {
            if (callback) {
                callback(error, data, response);
            }
        });
    }
    /**
     * Apply password recovery.
     * Applying password recovery by providing a secret hash code.
     * @param body Hash received by email and new password.
     * @param xForwardedFor 
     */
    public applyPasswordRecovery (body: PasswordRecoveryReq, xForwardedFor?: string, callback?: (error:any, data:any, response: superagent.Response) => any): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/auth/recover';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling applyPasswordRecovery.');
        }

        headerParams['X-Forwarded-For'] = xForwardedFor;

        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, data, response) => {
            if (callback) {
                callback(error, data, response);
            }
        });
    }
    /**
     * Get invited user.
     * Returns information about the user being invited.
     * @param invitationId Invitation ID received in email.
     */
    public getInvitedUser (invitationId: string, callback?: (error:any, data:UserInfoResp, response: superagent.Response) => any): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/auth/invitations/{invitation-id}'
            .replace('{' + 'invitation-id' + '}', String(invitationId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'invitationId' is not null or undefined
        if (invitationId === null || invitationId === undefined) {
            throw new Error('Required parameter invitationId was null or undefined when calling getInvitedUser.');
        }

        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, data, response) => {
            if (callback) {
                callback(error, data, response);
            }
        });
    }
    /**
     * Get registering user.
     * Retrieving the details of a user to register.
     * @param signupId ID received while signing up.
     */
    public getSelfEnrollingUser (signupId: string, callback?: (error:any, data:AccountSignupResp, response: superagent.Response) => any): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/auth/register/{signup-id}'
            .replace('{' + 'signup-id' + '}', String(signupId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'signupId' is not null or undefined
        if (signupId === null || signupId === undefined) {
            throw new Error('Required parameter signupId was null or undefined when calling getSelfEnrollingUser.');
        }

        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, data, response) => {
            if (callback) {
                callback(error, data, response);
            }
        });
    }
    /**
     * Register a new account.
     * An endpoint for registering a new account.
     * @param signupId ID received while signing up.
     * @param body Details of the account to be created.
     */
    public registerAccount (signupId: string, body: AccountEnrollmentReq, callback?: (error:any, data:AccountEnrollmentResp, response: superagent.Response) => any): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/auth/register/{signup-id}'
            .replace('{' + 'signup-id' + '}', String(signupId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'signupId' is not null or undefined
        if (signupId === null || signupId === undefined) {
            throw new Error('Required parameter signupId was null or undefined when calling registerAccount.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling registerAccount.');
        }

        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, data, response) => {
            if (callback) {
                callback(error, data, response);
            }
        });
    }
    /**
     * Request password recovery.
     * Requesting password recovery by email address.
     * @param body Email address of the user whose password needs to be recovered.
     * @param xForwardedFor 
     */
    public requestPasswordRecovery (body: PasswordResetReq, xForwardedFor?: string, callback?: (error:any, data:any, response: superagent.Response) => any): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/auth/recover';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling requestPasswordRecovery.');
        }

        headerParams['X-Forwarded-For'] = xForwardedFor;

        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, data, response) => {
            if (callback) {
                callback(error, data, response);
            }
        });
    }
    /**
     * Sign up for a new account.
     * Signing up for a new free tier account with email address.
     * @param body Email address of the user to be signed up.
     */
    public signup (body: AccountSignupReq, callback?: (error:any, data:AccountSignupResp, response: superagent.Response) => any): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/auth/register';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling signup.');
        }

        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, data, response) => {
            if (callback) {
                callback(error, data, response);
            }
        });
    }
    /**
     * Verify self-enrollment code and aliases.
     * Verifying whether the code received by email is valid. Optionally, it also verifies whether an account with the given aliases exists.
     * @param signupId ID received while signing up.
     * @param body Verification code received by email and aliases to be checked.
     */
    public verifySelfEnrollment (signupId: string, body?: AccountSignupVerify, callback?: (error:any, data:any, response: superagent.Response) => any): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/auth/register/{signup-id}'
            .replace('{' + 'signup-id' + '}', String(signupId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'signupId' is not null or undefined
        if (signupId === null || signupId === undefined) {
            throw new Error('Required parameter signupId was null or undefined when calling verifySelfEnrollment.');
        }

        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, data, response) => {
            if (callback) {
                callback(error, data, response);
            }
        });
    }
}
export enum DeveloperApiApiKeys {
    Bearer,
}

export class DeveloperApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: DeveloperApiApiKeys, value: string) {
        this.authentications[DeveloperApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Create a new API key.
     * An endpoint for creating a new API key.
     * @param body The details of the API key to be created.
     */
    public createApiKey (body: ApiKeyInfoReq, callback?: (error:any, data:ApiKeyInfoResp, response: superagent.Response) => any): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/v3/api-keys';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createApiKey.');
        }

        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, data, response) => {
            if (callback) {
                callback(error, data, response);
            }
        });
    }
    /**
     * Delete API key.
     * An endpoint for deleting the API key.
     * @param apiKey The ID of the API key to be deleted.
     */
    public deleteApiKey (apiKey: string, callback?: (error:any, data:any, response: superagent.Response) => any): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/v3/api-keys/{apiKey}'
            .replace('{' + 'apiKey' + '}', String(apiKey));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'apiKey' is not null or undefined
        if (apiKey === null || apiKey === undefined) {
            throw new Error('Required parameter apiKey was null or undefined when calling deleteApiKey.');
        }

        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, data, response) => {
            if (callback) {
                callback(error, data, response);
            }
        });
    }
    /**
     * Get all API keys
     * An endpoint for retrieving API keys in an array, optionally filtered by the owner.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     * @param filter A filter for the query, for example filter&#x3D;owner%3Duuid.
     * @param owner Owner name filter.
     */
    public getAllApiKeys (limit?: number, after?: string, order?: string, include?: string, filter?: string, owner?: string, callback?: (error:any, data:ApiKeyInfoRespList, response: superagent.Response) => any): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/v3/api-keys';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (after !== undefined) {
            queryParameters['after'] = after;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        if (include !== undefined) {
            queryParameters['include'] = include;
        }

        if (filter !== undefined) {
            queryParameters['filter'] = filter;
        }

        if (owner !== undefined) {
            queryParameters['owner'] = owner;
        }

        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, data, response) => {
            if (callback) {
                callback(error, data, response);
            }
        });
    }
    /**
     * Get all group information.
     * An endpoint for retrieving all group information.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     */
    public getAllGroups (limit?: number, after?: string, order?: string, include?: string, callback?: (error:any, data:GroupSummaryList, response: superagent.Response) => any): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/v3/policy-groups';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (after !== undefined) {
            queryParameters['after'] = after;
        }

        if (order !== undefined) {
            queryParameters['order'] = order;
        }

        if (include !== undefined) {
            queryParameters['include'] = include;
        }

        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, data, response) => {
            if (callback) {
                callback(error, data, response);
            }
        });
    }
    /**
     * Get API key details.
     * An endpoint for retrieving API key details.
     * @param apiKey The ID of the API key to be retrieved.
     */
    public getApiKey (apiKey: string, callback?: (error:any, data:ApiKeyInfoResp, response: superagent.Response) => any): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/v3/api-keys/{apiKey}'
            .replace('{' + 'apiKey' + '}', String(apiKey));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'apiKey' is not null or undefined
        if (apiKey === null || apiKey === undefined) {
            throw new Error('Required parameter apiKey was null or undefined when calling getApiKey.');
        }

        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, data, response) => {
            if (callback) {
                callback(error, data, response);
            }
        });
    }
    /**
     * Get account info.
     * Returns detailed information about the account.
     * @param include Comma separated additional data to return. Currently supported: limits
     */
    public getMyAccountInfo (include?: string, callback?: (error:any, data:AccountInfo, response: superagent.Response) => any): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/v3/accounts/me';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (include !== undefined) {
            queryParameters['include'] = include;
        }

        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, data, response) => {
            if (callback) {
                callback(error, data, response);
            }
        });
    }
    /**
     * Get API key details.
     * An endpoint for retrieving API key details.
     */
    public getMyApiKey (callback?: (error:any, data:ApiKeyInfoResp, response: superagent.Response) => any): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/v3/api-keys/me';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, data, response) => {
            if (callback) {
                callback(error, data, response);
            }
        });
    }
    /**
     * Details of the current user.
     * An endpoint for retrieving the details of the logged in user.
     */
    public getMyUser (callback?: (error:any, data:UserInfoResp, response: superagent.Response) => any): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/v3/users/me';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, data, response) => {
            if (callback) {
                callback(error, data, response);
            }
        });
    }
    /**
     * Update API key details.
     * An endpoint for updating API key details.
     * @param apiKey The ID of the API key to be updated.
     * @param body New API key attributes to be stored.
     */
    public updateApiKey (apiKey: string, body: ApiKeyUpdateReq, callback?: (error:any, data:ApiKeyInfoResp, response: superagent.Response) => any): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/v3/api-keys/{apiKey}'
            .replace('{' + 'apiKey' + '}', String(apiKey));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'apiKey' is not null or undefined
        if (apiKey === null || apiKey === undefined) {
            throw new Error('Required parameter apiKey was null or undefined when calling updateApiKey.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateApiKey.');
        }

        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, data, response) => {
            if (callback) {
                callback(error, data, response);
            }
        });
    }
    /**
     * Update API key details.
     * An endpoint for updating API key details.
     * @param body New API key attributes to be stored.
     */
    public updateMyApiKey (body: ApiKeyUpdateReq, callback?: (error:any, data:ApiKeyInfoResp, response: superagent.Response) => any): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/v3/api-keys/me';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateMyApiKey.');
        }

        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, data, response) => {
            if (callback) {
                callback(error, data, response);
            }
        });
    }
    /**
     * Update user details.
     * An endpoint for updating the details of the logged in user.
     * @param body New attributes for the logged in user.
     */
    public updateMyUser (body: UserUpdateReq, callback?: (error:any, data:UserInfoResp, response: superagent.Response) => any): superagent.SuperAgentRequest {
        const localVarPath = this.basePath + '/v3/users/me';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateMyUser.');
        }

        let useFormData = false;

        let requestOptions: RequestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.Bearer.applyToRequest(requestOptions);
        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        return request(requestOptions, (error, data, response) => {
            if (callback) {
                callback(error, data, response);
            }
        });
    }
}
