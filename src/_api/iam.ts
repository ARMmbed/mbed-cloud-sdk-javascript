// ===============================================
// This file is autogenerated - Please do not edit
// Tracks base typescript-fetch mustache 01/02/17
// ===============================================
/**
 * Account Management API
 * API for managing accounts, users, creating API keys, uploading trusted certificates
 *
 * OpenAPI spec version: v3
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-variable */
/* tslint:disable:no-implicit-any */

import superagent = require('superagent');
import { ApiBase } from "../common/apiBase";
import { SDKError } from "../common/sdkError";

/**
 * This object represents an account in requests and responses.
 */
export type AccountInfoStatusEnum = "ENROLLING" | "ACTIVE" | "RESTRICTED" | "SUSPENDED";
export type AccountInfoObjectEnum = "user" | "api-key" | "group" | "account" | "account-template" | "trusted-cert" | "list" | "error";
export interface AccountInfo {
    /**
     * The status of the account.
     */
    "status": AccountInfoStatusEnum;
    /**
     * The postal code part of the postal address.
     */
    "postal_code"?: string;
    /**
     * Account ID.
     */
    "id": string;
    /**
     * An array of aliases.
     */
    "aliases": Array<string>;
    /**
     * Postal address line 2.
     */
    "address_line2"?: string;
    /**
     * The city part of the postal address.
     */
    "city"?: string;
    /**
     * Postal address line 1.
     */
    "address_line1"?: string;
    /**
     * The display name for the account.
     */
    "display_name"?: string;
    /**
     * The ID of the parent account, if it has any.
     */
    "parent_id"?: string;
    /**
     * The state part of the postal address.
     */
    "state"?: string;
    /**
     * API resource entity version.
     */
    "etag": string;
    /**
     * Flag (true/false) indicating whether Factory Tool is allowed to download or not.
     */
    "is_provisioning_allowed": boolean;
    /**
     * The company email address for this account.
     */
    "email"?: string;
    /**
     * The phone number of the company.
     */
    "phone_number"?: string;
    /**
     * The name of the company.
     */
    "company"?: string;
    /**
     * Entity name: always 'account'
     */
    "object": AccountInfoObjectEnum;
    /**
     * A reason note for updating the status of the account
     */
    "reason"?: string;
    /**
     * Time when upgraded to commercial account in UTC format RFC3339.
     */
    "upgraded_at"?: Date;
    /**
     * The tier level of the account; '0': free tier, '1': commercial account. Other values are reserved for the future.
     */
    "tier": string;
    /**
     * List of sub accounts.
     */
    "sub_accounts"?: Array<AccountInfo>;
    /**
     * List of limits as key-value pairs if requested.
     */
    "limits"?: { [key: string]: string; };
    /**
     * The country part of the postal address.
     */
    "country"?: string;
    /**
     * Creation UTC time RFC3339.
     */
    "created_at"?: Date;
    /**
     * The name of the contact person for this account.
     */
    "contact"?: string;
    /**
     * List of policies if requested.
     */
    "policies"?: Array<FeaturePolicy>;
    /**
     * Account template ID.
     */
    "template_id"?: string;
}

/**
 * This object represents an account creation request.
 */
export interface AccountUpdateReq {
    /**
     * Postal address line 2, not longer than 100 characters.
     */
    "address_line2"?: string;
    /**
     * The city part of the postal address, not longer than 100 characters. Required for commercial accounts only.
     */
    "city"?: string;
    /**
     * Postal address line 1, not longer than 100 characters. Required for commercial accounts only.
     */
    "address_line1"?: string;
    /**
     * The display name for the account, not longer than 100 characters.
     */
    "display_name"?: string;
    /**
     * The country part of the postal address, not longer than 100 characters. Required for commercial accounts only.
     */
    "country"?: string;
    /**
     * The name of the company, not longer than 100 characters. Required for commercial accounts only.
     */
    "company"?: string;
    /**
     * The state part of the postal address, not longer than 100 characters.
     */
    "state"?: string;
    /**
     * The name of the contact person for this account, not longer than 100 characters. Required for commercial accounts only.
     */
    "contact"?: string;
    /**
     * The postal code part of the postal address, not longer than 100 characters.
     */
    "postal_code"?: string;
    /**
     * The phone number of the company, not longer than 100 characters.
     */
    "phone_number"?: string;
    /**
     * The company email address for this account, not longer than 100 characters. Required for commercial accounts only.
     */
    "email"?: string;
    /**
     * An array of aliases, not more than 10.
     */
    "aliases"?: Array<string>;
}

/**
 * This object represents an API key in requests towards mbed Cloud.
 */
export interface ApiKeyInfoReq {
    /**
     * The owner of this API key, who is the creator by default.
     */
    "owner"?: string;
    /**
     * The display name for the API key, not longer than 100 characters.
     */
    "name": string;
    /**
     * A list of group IDs this API key belongs to.
     */
    "groups"?: Array<string>;
}

/**
 * This object represents an API key in mbed Cloud.
 */
export type ApiKeyInfoRespStatusEnum = "ACTIVE" | "INACTIVE";
export type ApiKeyInfoRespObjectEnum = "user" | "api-key" | "group" | "account" | "account-template" | "trusted-cert" | "list" | "error";
export interface ApiKeyInfoResp {
    /**
     * A list of group IDs this API key belongs to.
     */
    "groups"?: Array<string>;
    /**
     * The status of the API key.
     */
    "status"?: ApiKeyInfoRespStatusEnum;
    /**
     * The display name for the API key.
     */
    "name": string;
    /**
     * Creation UTC time RFC3339.
     */
    "created_at"?: Date;
    /**
     * Entity name: always 'api-key'
     */
    "object": ApiKeyInfoRespObjectEnum;
    /**
     * The timestamp of the API key creation in the storage, in milliseconds.
     */
    "creation_time"?: number;
    /**
     * API resource entity version.
     */
    "etag": string;
    /**
     * The API key.
     */
    "key": string;
    /**
     * The owner of this API key, who is the creator by default.
     */
    "owner"?: string;
    /**
     * The UUID of the API key.
     */
    "id": string;
    /**
     * The timestamp of the latest API key usage, in milliseconds.
     */
    "last_login_time"?: number;
}

export type ApiKeyInfoRespListObjectEnum = "user" | "api-key" | "group" | "account" | "account-template" | "trusted-cert" | "list" | "error";
export type ApiKeyInfoRespListOrderEnum = "ASC" | "DESC";
export interface ApiKeyInfoRespList {
    /**
     * The entity ID to fetch after the given one.
     */
    "after"?: string;
    /**
     * Flag indicating whether there is more results.
     */
    "has_more": boolean;
    /**
     * The total number or records, if requested. It might be returned also for small lists.
     */
    "total_count": number;
    /**
     * Entity name: always 'list'
     */
    "object": ApiKeyInfoRespListObjectEnum;
    /**
     * The number of results to return, (range: 2-1000), or equals to `total_count`
     */
    "limit": number;
    /**
     * A list of entities.
     */
    "data": Array<ApiKeyInfoResp>;
    /**
     * The order of the records to return. Available values: ASC, DESC; by default ASC.
     */
    "order"?: ApiKeyInfoRespListOrderEnum;
}

/**
 * This object represents an API key in requests towards mbed Cloud.
 */
export interface ApiKeyUpdateReq {
    /**
     * The owner of this API key, who is the creator by default.
     */
    "owner"?: string;
    /**
     * The display name for the API key, not longer than 100 characters.
     */
    "name": string;
}

/**
 * This object represents an error message.
 */
export type ErrorResponseObjectEnum = "user" | "api-key" | "group" | "account" | "account-template" | "trusted-cert" | "list" | "error";
export type ErrorResponseTypeEnum = "success" | "created" | "accepted" | "permanently_deleted" | "validation_error" | "invalid_token" | "access_denied" | "account_limit_exceeded" | "not_found" | "method_not_supported" | "not_acceptable" | "duplicate" | "precondition_failed" | "unsupported_media_type" | "rate_limit_exceeded" | "internal_server_error" | "system_unavailable";
export interface ErrorResponse {
    /**
     * Response code.
     */
    "code": number;
    /**
     * Failed input fields during request object validation.
     */
    "fields"?: Array<Field>;
    /**
     * Entity name, always 'error'.
     */
    "object": ErrorResponseObjectEnum;
    /**
     * Request ID.
     */
    "request_id": string;
    /**
     * A human readable message with detailed info.
     */
    "message": string;
    /**
     * Error type.
     */
    "type": ErrorResponseTypeEnum;
}

/**
 * This object represents a feature policy. Either the feature or the resource must be specified.
 */
export interface FeaturePolicy {
    /**
     * Comma separated list of actions, empty string represents all actions.
     */
    "action"?: string;
    /**
     * Resource that is protected by this policy.
     */
    "resource"?: string;
    /**
     * Feature name corresponding to this policy.
     */
    "feature"?: string;
    /**
     * True or false controlling whether an action is allowed or not.
     */
    "allow"?: boolean;
}

export interface Field {
    "message"?: string;
    "name"?: string;
}

/**
 * This object contains basic information about groups.
 */
export type GroupSummaryObjectEnum = "user" | "api-key" | "group" | "account" | "account-template" | "trusted-cert" | "list" | "error";
export interface GroupSummary {
    /**
     * A timestamp of the latest group update, in milliseconds.
     */
    "last_update_time"?: number;
    /**
     * The number of users in this group.
     */
    "user_count": number;
    /**
     * The name of the group.
     */
    "name": string;
    /**
     * Creation UTC time RFC3339.
     */
    "created_at"?: Date;
    /**
     * Entity name: always 'group'
     */
    "object": GroupSummaryObjectEnum;
    /**
     * A timestamp of the group creation in the storage, in milliseconds.
     */
    "creation_time"?: number;
    /**
     * API resource entity version.
     */
    "etag": string;
    /**
     * The number of API keys in this group.
     */
    "apikey_count": number;
    /**
     * The UUID of the group.
     */
    "id": string;
    /**
     * The UUID of the account this group belongs to.
     */
    "account_id": string;
}

export type GroupSummaryListObjectEnum = "user" | "api-key" | "group" | "account" | "account-template" | "trusted-cert" | "list" | "error";
export type GroupSummaryListOrderEnum = "ASC" | "DESC";
export interface GroupSummaryList {
    /**
     * The entity ID to fetch after the given one.
     */
    "after"?: string;
    /**
     * Flag indicating whether there is more results.
     */
    "has_more": boolean;
    /**
     * The total number or records, if requested. It might be returned also for small lists.
     */
    "total_count": number;
    /**
     * Entity name: always 'list'
     */
    "object": GroupSummaryListObjectEnum;
    /**
     * The number of results to return, (range: 2-1000), or equals to `total_count`
     */
    "limit": number;
    /**
     * A list of entities.
     */
    "data": Array<GroupSummary>;
    /**
     * The order of the records to return. Available values: ASC, DESC; by default ASC.
     */
    "order"?: GroupSummaryListOrderEnum;
}

/**
 * This object represents an array of users and API keys.
 */
export interface SubjectList {
    /**
     * An array of API keys.
     */
    "apikeys"?: Array<string>;
    /**
     * An array of user names.
     */
    "users"?: Array<string>;
}

/**
 * This object represents a trusted certificate in requests.
 */
export type TrustedCertificateReqStatusEnum = "ACTIVE" | "INACTIVE";
export type TrustedCertificateReqServiceEnum = "lwm2m" | "bootstrap";
export interface TrustedCertificateReq {
    /**
     * Status of the certificate.
     */
    "status"?: TrustedCertificateReqStatusEnum;
    /**
     * X509.v3 trusted certificate in PEM format.
     */
    "certificate": string;
    /**
     * Certificate name, not longer than 100 characters.
     */
    "name": string;
    /**
     * Service name where the certificate must be used.
     */
    "service": TrustedCertificateReqServiceEnum;
    /**
     * Base64 encoded signature of the account ID signed by the certificate to be uploaded. Signature must be hashed with SHA256.
     */
    "signature": string;
    /**
     * Human readable description of this certificate, not longer than 500 characters.
     */
    "description"?: string;
}

/**
 * This object represents a trusted certificate in responses.
 */
export type TrustedCertificateRespServiceEnum = "lwm2m" | "bootstrap";
export type TrustedCertificateRespStatusEnum = "ACTIVE" | "INACTIVE";
export type TrustedCertificateRespObjectEnum = "user" | "api-key" | "group" | "account" | "account-template" | "trusted-cert" | "list" | "error";
export interface TrustedCertificateResp {
    /**
     * Service name where the certificate is to be used.
     */
    "service": TrustedCertificateRespServiceEnum;
    /**
     * Status of the certificate.
     */
    "status"?: TrustedCertificateRespStatusEnum;
    /**
     * Human readable description of this certificate.
     */
    "description"?: string;
    /**
     * X509.v3 trusted certificate in PEM format.
     */
    "certificate": string;
    /**
     * Issuer of the certificate.
     */
    "issuer": string;
    /**
     * Device execution mode where 1 means a developer certificate.
     */
    "device_execution_mode"?: number;
    /**
     * Creation UTC time RFC3339.
     */
    "created_at"?: Date;
    /**
     * Entity name: always 'trusted-cert'
     */
    "object": TrustedCertificateRespObjectEnum;
    /**
     * Subject of the certificate.
     */
    "subject": string;
    /**
     * The UUID of the account.
     */
    "account_id": string;
    /**
     * API resource entity version.
     */
    "etag": string;
    /**
     * Expiration time in UTC formatted as RFC3339.
     */
    "validity": Date;
    /**
     * The UUID of the owner.
     */
    "owner_id"?: string;
    /**
     * Entity ID.
     */
    "id": string;
    /**
     * Certificate name.
     */
    "name": string;
}

export type TrustedCertificateRespListObjectEnum = "user" | "api-key" | "group" | "account" | "account-template" | "trusted-cert" | "list" | "error";
export type TrustedCertificateRespListOrderEnum = "ASC" | "DESC";
export interface TrustedCertificateRespList {
    /**
     * The entity ID to fetch after the given one.
     */
    "after"?: string;
    /**
     * Flag indicating whether there is more results.
     */
    "has_more": boolean;
    /**
     * The total number or records, if requested. It might be returned also for small lists.
     */
    "total_count": number;
    /**
     * Entity name: always 'list'
     */
    "object": TrustedCertificateRespListObjectEnum;
    /**
     * The number of results to return, (range: 2-1000), or equals to `total_count`
     */
    "limit": number;
    /**
     * A list of entities.
     */
    "data": Array<TrustedCertificateResp>;
    /**
     * The order of the records to return. Available values: ASC, DESC; by default ASC.
     */
    "order"?: TrustedCertificateRespListOrderEnum;
}

/**
 * This object represents a response to an update request.
 */
export type UpdatedResponseObjectEnum = "user" | "api-key" | "group" | "account" | "account-template" | "trusted-cert" | "list" | "error";
export type UpdatedResponseTypeEnum = "success" | "created" | "accepted" | "permanently_deleted" | "validation_error" | "invalid_token" | "access_denied" | "account_limit_exceeded" | "not_found" | "method_not_supported" | "not_acceptable" | "duplicate" | "precondition_failed" | "unsupported_media_type" | "rate_limit_exceeded" | "internal_server_error" | "system_unavailable";
export interface UpdatedResponse {
    /**
     * Response code.
     */
    "code": number;
    /**
     * Entity name: 'user', 'apikey', 'group' or 'account'.
     */
    "object": UpdatedResponseObjectEnum;
    /**
     * Request ID.
     */
    "request_id": string;
    /**
     * A human readable message with detailed info.
     */
    "message": string;
    /**
     * Response type: success.
     */
    "type": UpdatedResponseTypeEnum;
    /**
     * Entity ID.
     */
    "id": string;
}

/**
 * This object represents a user in requests towards mbed Cloud.
 */
export interface UserInfoReq {
    /**
     * Phone number, not longer than 100 characters.
     */
    "phone_number"?: string;
    /**
     * A username containing alphanumerical letters and -,._@+= characters. It must be at least 4 but not more than 30 character long.
     */
    "username"?: string;
    /**
     * A list of IDs of the groups this user belongs to.
     */
    "groups"?: Array<string>;
    /**
     * A flag indicating that the General Terms and Conditions has been accepted.
     */
    "is_gtc_accepted"?: boolean;
    /**
     * The full name of the user, not longer than 100 characters.
     */
    "full_name"?: string;
    /**
     * A flag indicating that receiving marketing information has been accepted.
     */
    "is_marketing_accepted"?: boolean;
    /**
     * Address, not longer than 100 characters.
     */
    "address"?: string;
    /**
     * The password when creating a new user. It will will generated when not present in the request.
     */
    "password"?: string;
    /**
     * The email address, not longer than 254 characters.
     */
    "email": string;
}

/**
 * This object represents a user in mbed Cloud.
 */
export type UserInfoRespStatusEnum = "ENROLLING" | "INVITED" | "ACTIVE" | "RESET" | "INACTIVE";
export type UserInfoRespObjectEnum = "user" | "api-key" | "group" | "account" | "account-template" | "trusted-cert" | "list" | "error";
export interface UserInfoResp {
    /**
     * The status of the user. INVITED means that the user has not accepted the invitation request. RESET means that the password must be changed immediately.
     */
    "status": UserInfoRespStatusEnum;
    /**
     * A username containing alphanumerical letters and -,._@+= characters.
     */
    "username"?: string;
    /**
     * A list of IDs of the groups this user belongs to.
     */
    "groups"?: Array<string>;
    /**
     * A timestamp of the latest change of the user password, in milliseconds.
     */
    "password_changed_time"?: number;
    /**
     * A flag indicating whether the user's email address has been verified or not.
     */
    "email_verified"?: boolean;
    /**
     * Creation UTC time RFC3339.
     */
    "created_at"?: Date;
    /**
     * Entity name: always 'user'
     */
    "object": UserInfoRespObjectEnum;
    /**
     * A flag indicating that the General Terms and Conditions has been accepted.
     */
    "is_gtc_accepted"?: boolean;
    /**
     * The UUID of the account.
     */
    "account_id": string;
    /**
     * The email address.
     */
    "email": string;
    /**
     * A flag indicating that receiving marketing information has been accepted.
     */
    "is_marketing_accepted"?: boolean;
    /**
     * API resource entity version.
     */
    "etag": string;
    /**
     * The full name of the user.
     */
    "full_name"?: string;
    /**
     * Address.
     */
    "address"?: string;
    /**
     * A timestamp of the user creation in the storage, in milliseconds.
     */
    "creation_time"?: number;
    /**
     * The password when creating a new user. It will will generated when not present in the request.
     */
    "password"?: string;
    /**
     * Phone number.
     */
    "phone_number"?: string;
    /**
     * The UUID of the user.
     */
    "id": string;
    /**
     * A timestamp of the latest login of the user, in milliseconds.
     */
    "last_login_time"?: number;
}

export type UserInfoRespListObjectEnum = "user" | "api-key" | "group" | "account" | "account-template" | "trusted-cert" | "list" | "error";
export type UserInfoRespListOrderEnum = "ASC" | "DESC";
export interface UserInfoRespList {
    /**
     * The entity ID to fetch after the given one.
     */
    "after"?: string;
    /**
     * Flag indicating whether there is more results.
     */
    "has_more": boolean;
    /**
     * The total number or records, if requested. It might be returned also for small lists.
     */
    "total_count": number;
    /**
     * Entity name: always 'list'
     */
    "object": UserInfoRespListObjectEnum;
    /**
     * The number of results to return, (range: 2-1000), or equals to `total_count`
     */
    "limit": number;
    /**
     * A list of entities.
     */
    "data": Array<UserInfoResp>;
    /**
     * The order of the records to return. Available values: ASC, DESC; by default ASC.
     */
    "order"?: UserInfoRespListOrderEnum;
}

/**
 * This object represents a user in requests towards mbed Cloud.
 */
export interface UserUpdateReq {
    /**
     * Phone number, not longer than 100 characters.
     */
    "phone_number"?: string;
    /**
     * A username containing alphanumerical letters and -,._@+= characters. It must be at least 4 but not more than 30 character long.
     */
    "username"?: string;
    /**
     * A flag indicating that receiving marketing information has been accepted.
     */
    "is_marketing_accepted"?: boolean;
    /**
     * A flag indicating that the General Terms and Conditions has been accepted.
     */
    "is_gtc_accepted"?: boolean;
    /**
     * The full name of the user, not longer than 100 characters.
     */
    "full_name"?: string;
    /**
     * Address, not longer than 100 characters.
     */
    "address"?: string;
    /**
     * The password when creating a new user. It will will generated when not present in the request.
     */
    "password"?: string;
    /**
     * The email address, not longer than 254 characters.
     */
    "email": string;
}

/**
 * AccountAdminApi
 */
export class AccountAdminApi extends ApiBase {

    /** 
     * Upload a new trusted certificate.
     * An endpoint for uploading new trusted certificates.
     * @param body A trusted certificate object with attributes.
     */
    addCertificate (body: TrustedCertificateReq, callback?: (error:any, data?:TrustedCertificateResp, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request<TrustedCertificateResp>({
            url: '/v3/trusted-certificates',
            method: 'POST',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
            body: body,
        }, callback);
    }
    /** 
     * Add members to a group.
     * An endpoint for adding users and API keys to groups.
     * @param groupID The ID of the group to be updated.
     * @param body A list of users and API keys to be added to the group.
     */
    addSubjectsToGroup (groupID: string, body: SubjectList, callback?: (error:any, data?:UpdatedResponse, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "groupID" is set
        if (groupID === null || groupID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'groupID' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request<UpdatedResponse>({
            url: '/v3/policy-groups/{groupID}'.replace('{' + 'groupID' + '}', String(groupID)),
            method: 'POST',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
            body: body,
        }, callback);
    }
    /** 
     * Create a new user.
     * An endpoint for creating or inviting a new user to the account. In case of invitation email address is used only, other attributes are set in the 2nd step.
     * @param body A user object with attributes.
     * @param action Action, either &#39;create&#39; or &#39;invite&#39;.
     */
    createUser (body: UserInfoReq, action?: string, callback?: (error:any, data?:UserInfoResp, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};
        if (action !== undefined) {
            queryParameters['action'] = action;
        }

        let useFormData = false;
        let formParams: any = {};

        return this.request<UserInfoResp>({
            url: '/v3/users',
            method: 'POST',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
            body: body,
        }, callback);
    }
    /** 
     * Delete a trusted certificate by ID.
     * An endpoint for deleting a trusted certificate.
     * @param certId The ID of the trusted certificate to be deleted.
     */
    deleteCertificate (certId: string, callback?: (error:any, data?:any, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "certId" is set
        if (certId === null || certId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'certId' missing."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request<null>({
            url: '/v3/trusted-certificates/{cert-id}'.replace('{' + 'cert-id' + '}', String(certId)),
            method: 'DELETE',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /** 
     * Delete a user.
     * An endpoint for deleting a user.
     * @param userId The ID of the user to be deleted.
     */
    deleteUser (userId: string, callback?: (error:any, data?:any, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "userId" is set
        if (userId === null || userId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'userId' missing."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request<null>({
            url: '/v3/users/{user-id}'.replace('{' + 'user-id' + '}', String(userId)),
            method: 'DELETE',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /** 
     * Get all trusted certificates.
     * An endpoint for retrieving trusted certificates in an array.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     * @param serviceEq Service filter, either lwm2m or bootstrap
     * @param expireEq Expire filter in days
     * @param deviceExecutionModeEq Device execution mode, as 1 for developer certificates or as another natural integer value
     * @param ownerEq Owner ID filter
     */
    getAllCertificates (limit?: number, after?: string, order?: string, include?: string, serviceEq?: string, expireEq?: number, deviceExecutionModeEq?: number, ownerEq?: string, callback?: (error:any, data?:TrustedCertificateRespList, response?: superagent.Response) => any): superagent.SuperAgentRequest {

        let headerParams: any = {};

        let queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (after !== undefined) {
            queryParameters['after'] = after;
        }
        if (order !== undefined) {
            queryParameters['order'] = order;
        }
        if (include !== undefined) {
            queryParameters['include'] = include;
        }
        if (serviceEq !== undefined) {
            queryParameters['service__eq'] = serviceEq;
        }
        if (expireEq !== undefined) {
            queryParameters['expire__eq'] = expireEq;
        }
        if (deviceExecutionModeEq !== undefined) {
            queryParameters['device_execution_mode__eq'] = deviceExecutionModeEq;
        }
        if (ownerEq !== undefined) {
            queryParameters['owner__eq'] = ownerEq;
        }

        let useFormData = false;
        let formParams: any = {};

        return this.request<TrustedCertificateRespList>({
            url: '/v3/trusted-certificates',
            method: 'GET',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /** 
     * Get the details of all users.
     * An endpoint for retrieving the details of all users.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     * @param statusEq Filter for status, for example active or reset
     */
    getAllUsers (limit?: number, after?: string, order?: string, include?: string, statusEq?: string, callback?: (error:any, data?:UserInfoRespList, response?: superagent.Response) => any): superagent.SuperAgentRequest {

        let headerParams: any = {};

        let queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (after !== undefined) {
            queryParameters['after'] = after;
        }
        if (order !== undefined) {
            queryParameters['order'] = order;
        }
        if (include !== undefined) {
            queryParameters['include'] = include;
        }
        if (statusEq !== undefined) {
            queryParameters['status__eq'] = statusEq;
        }

        let useFormData = false;
        let formParams: any = {};

        return this.request<UserInfoRespList>({
            url: '/v3/users',
            method: 'GET',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /** 
     * Get trusted certificate by ID.
     * An endpoint for retrieving a trusted certificate by ID.
     * @param certId The ID or name of the trusted certificate to be retrieved.
     */
    getCertificate (certId: string, callback?: (error:any, data?:TrustedCertificateResp, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "certId" is set
        if (certId === null || certId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'certId' missing."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request<TrustedCertificateResp>({
            url: '/v3/trusted-certificates/{cert-id}'.replace('{' + 'cert-id' + '}', String(certId)),
            method: 'GET',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /** 
     * Details of a user.
     * An endpoint for retrieving the details of a user.
     * @param userId The ID or name of the user whose details are retrieved.
     */
    getUser (userId: string, callback?: (error:any, data?:UserInfoResp, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "userId" is set
        if (userId === null || userId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'userId' missing."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request<UserInfoResp>({
            url: '/v3/users/{user-id}'.replace('{' + 'user-id' + '}', String(userId)),
            method: 'GET',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /** 
     * Get users of a group.
     * An endpoint for listing the users of a group with details.
     * @param groupID The ID of the group whose users are retrieved.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     */
    getUsersOfGroup (groupID: string, limit?: number, after?: string, order?: string, include?: string, callback?: (error:any, data?:UserInfoRespList, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "groupID" is set
        if (groupID === null || groupID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'groupID' missing."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (after !== undefined) {
            queryParameters['after'] = after;
        }
        if (order !== undefined) {
            queryParameters['order'] = order;
        }
        if (include !== undefined) {
            queryParameters['include'] = include;
        }

        let useFormData = false;
        let formParams: any = {};

        return this.request<UserInfoRespList>({
            url: '/v3/policy-groups/{groupID}/users'.replace('{' + 'groupID' + '}', String(groupID)),
            method: 'GET',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /** 
     * Remove users from a group.
     * An endpoint for removing users from groups.
     * @param groupID The ID of the group whose users are removed.
     * @param body A list of users to be removed from the group.
     */
    removeUsersFromGroup (groupID: string, body: SubjectList, callback?: (error:any, data?:UpdatedResponse, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "groupID" is set
        if (groupID === null || groupID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'groupID' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request<UpdatedResponse>({
            url: '/v3/policy-groups/{groupID}/users'.replace('{' + 'groupID' + '}', String(groupID)),
            method: 'DELETE',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
            body: body,
        }, callback);
    }
    /** 
     * Update trusted certificate.
     * An endpoint for updating existing trusted certificates.
     * @param certId The ID of the trusted certificate to be updated.
     * @param body A trusted certificate object with attributes.
     */
    updateCertificate (certId: string, body: TrustedCertificateReq, callback?: (error:any, data?:TrustedCertificateResp, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "certId" is set
        if (certId === null || certId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'certId' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request<TrustedCertificateResp>({
            url: '/v3/trusted-certificates/{cert-id}'.replace('{' + 'cert-id' + '}', String(certId)),
            method: 'PUT',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
            body: body,
        }, callback);
    }
    /** 
     * Updates attributes of the account.
     * An endpoint for updating the account.
     * @param body Details of the account to be updated.
     */
    updateMyAccount (body: AccountUpdateReq, callback?: (error:any, data?:AccountInfo, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request<AccountInfo>({
            url: '/v3/accounts/me',
            method: 'PUT',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
            body: body,
        }, callback);
    }
    /** 
     * Update user details.
     * An endpoint for updating user details.
     * @param userId The ID of the user whose details are updated.
     * @param body A user object with attributes.
     */
    updateUser (userId: string, body: UserUpdateReq, callback?: (error:any, data?:UserInfoResp, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "userId" is set
        if (userId === null || userId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'userId' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request<UserInfoResp>({
            url: '/v3/users/{user-id}'.replace('{' + 'user-id' + '}', String(userId)),
            method: 'PUT',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
            body: body,
        }, callback);
    }
}

/**
 * DeveloperApi
 */
export class DeveloperApi extends ApiBase {

    /** 
     * Create a new API key.
     * An endpoint for creating a new API key.
     * @param body The details of the API key to be created.
     */
    createApiKey (body: ApiKeyInfoReq, callback?: (error:any, data?:ApiKeyInfoResp, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request<ApiKeyInfoResp>({
            url: '/v3/api-keys',
            method: 'POST',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
            body: body,
        }, callback);
    }
    /** 
     * Delete API key.
     * An endpoint for deleting the API key.
     * @param apiKey The ID of the API key to be deleted.
     */
    deleteApiKey (apiKey: string, callback?: (error:any, data?:any, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "apiKey" is set
        if (apiKey === null || apiKey === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'apiKey' missing."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request<null>({
            url: '/v3/api-keys/{apiKey}'.replace('{' + 'apiKey' + '}', String(apiKey)),
            method: 'DELETE',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /** 
     * Get all API keys
     * An endpoint for retrieving API keys in an array, optionally filtered by the owner.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     * @param ownerEq Owner name filter.
     */
    getAllApiKeys (limit?: number, after?: string, order?: string, include?: string, ownerEq?: string, callback?: (error:any, data?:ApiKeyInfoRespList, response?: superagent.Response) => any): superagent.SuperAgentRequest {

        let headerParams: any = {};

        let queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (after !== undefined) {
            queryParameters['after'] = after;
        }
        if (order !== undefined) {
            queryParameters['order'] = order;
        }
        if (include !== undefined) {
            queryParameters['include'] = include;
        }
        if (ownerEq !== undefined) {
            queryParameters['owner__eq'] = ownerEq;
        }

        let useFormData = false;
        let formParams: any = {};

        return this.request<ApiKeyInfoRespList>({
            url: '/v3/api-keys',
            method: 'GET',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /** 
     * Get all group information.
     * An endpoint for retrieving all group information.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     */
    getAllGroups (limit?: number, after?: string, order?: string, include?: string, callback?: (error:any, data?:GroupSummaryList, response?: superagent.Response) => any): superagent.SuperAgentRequest {

        let headerParams: any = {};

        let queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (after !== undefined) {
            queryParameters['after'] = after;
        }
        if (order !== undefined) {
            queryParameters['order'] = order;
        }
        if (include !== undefined) {
            queryParameters['include'] = include;
        }

        let useFormData = false;
        let formParams: any = {};

        return this.request<GroupSummaryList>({
            url: '/v3/policy-groups',
            method: 'GET',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /** 
     * Get API key details.
     * An endpoint for retrieving API key details.
     * @param apiKey The ID of the API key to be retrieved.
     */
    getApiKey (apiKey: string, callback?: (error:any, data?:ApiKeyInfoResp, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "apiKey" is set
        if (apiKey === null || apiKey === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'apiKey' missing."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request<ApiKeyInfoResp>({
            url: '/v3/api-keys/{apiKey}'.replace('{' + 'apiKey' + '}', String(apiKey)),
            method: 'GET',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /** 
     * Get the API keys of a group.
     * An endpoint for listing the API keys of the group with details.
     * @param groupID The ID of the group whose API keys are retrieved.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     */
    getApiKeysOfGroup (groupID: string, limit?: number, after?: string, order?: string, include?: string, callback?: (error:any, data?:ApiKeyInfoRespList, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "groupID" is set
        if (groupID === null || groupID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'groupID' missing."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (after !== undefined) {
            queryParameters['after'] = after;
        }
        if (order !== undefined) {
            queryParameters['order'] = order;
        }
        if (include !== undefined) {
            queryParameters['include'] = include;
        }

        let useFormData = false;
        let formParams: any = {};

        return this.request<ApiKeyInfoRespList>({
            url: '/v3/policy-groups/{groupID}/api-keys'.replace('{' + 'groupID' + '}', String(groupID)),
            method: 'GET',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /** 
     * Get group information.
     * An endpoint for getting general information about the group.
     * @param groupID The ID or name of the group to be retrieved.
     */
    getGroupSummary (groupID: string, callback?: (error:any, data?:GroupSummary, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "groupID" is set
        if (groupID === null || groupID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'groupID' missing."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request<GroupSummary>({
            url: '/v3/policy-groups/{groupID}'.replace('{' + 'groupID' + '}', String(groupID)),
            method: 'GET',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /** 
     * Get account info.
     * Returns detailed information about the account.
     * @param include Comma separated additional data to return. Currently supported: limits, policies, sub_accounts
     */
    getMyAccountInfo (include?: string, callback?: (error:any, data?:AccountInfo, response?: superagent.Response) => any): superagent.SuperAgentRequest {

        let headerParams: any = {};

        let queryParameters: any = {};
        if (include !== undefined) {
            queryParameters['include'] = include;
        }

        let useFormData = false;
        let formParams: any = {};

        return this.request<AccountInfo>({
            url: '/v3/accounts/me',
            method: 'GET',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /** 
     * Get API key details.
     * An endpoint for retrieving API key details.
     */
    getMyApiKey (callback?: (error:any, data?:ApiKeyInfoResp, response?: superagent.Response) => any): superagent.SuperAgentRequest {

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request<ApiKeyInfoResp>({
            url: '/v3/api-keys/me',
            method: 'GET',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /** 
     * Details of the current user.
     * An endpoint for retrieving the details of the logged in user.
     */
    getMyUser (callback?: (error:any, data?:UserInfoResp, response?: superagent.Response) => any): superagent.SuperAgentRequest {

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request<UserInfoResp>({
            url: '/v3/users/me',
            method: 'GET',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /** 
     * Remove API keys from a group.
     * An endpoint for removing API keys from groups.
     * @param groupID The ID of the group whose API keys are removed.
     * @param body A list of API keys to be removed from the group.
     */
    removeApiKeysFromGroup (groupID: string, body: SubjectList, callback?: (error:any, data?:UpdatedResponse, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "groupID" is set
        if (groupID === null || groupID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'groupID' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request<UpdatedResponse>({
            url: '/v3/policy-groups/{groupID}/api-keys'.replace('{' + 'groupID' + '}', String(groupID)),
            method: 'DELETE',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
            body: body,
        }, callback);
    }
    /** 
     * Update API key details.
     * An endpoint for updating API key details.
     * @param apiKey The ID of the API key to be updated.
     * @param body New API key attributes to be stored.
     */
    updateApiKey (apiKey: string, body: ApiKeyUpdateReq, callback?: (error:any, data?:ApiKeyInfoResp, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "apiKey" is set
        if (apiKey === null || apiKey === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'apiKey' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request<ApiKeyInfoResp>({
            url: '/v3/api-keys/{apiKey}'.replace('{' + 'apiKey' + '}', String(apiKey)),
            method: 'PUT',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
            body: body,
        }, callback);
    }
    /** 
     * Update API key details.
     * An endpoint for updating API key details.
     * @param body New API key attributes to be stored.
     */
    updateMyApiKey (body: ApiKeyUpdateReq, callback?: (error:any, data?:ApiKeyInfoResp, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request<ApiKeyInfoResp>({
            url: '/v3/api-keys/me',
            method: 'PUT',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
            body: body,
        }, callback);
    }
    /** 
     * Update user details.
     * An endpoint for updating the details of the logged in user.
     * @param body New attributes for the logged in user.
     */
    updateMyUser (body: UserUpdateReq, callback?: (error:any, data?:UserInfoResp, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request<UserInfoResp>({
            url: '/v3/users/me',
            method: 'PUT',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
            body: body,
        }, callback);
    }
}

