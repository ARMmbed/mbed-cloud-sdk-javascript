/* tslint:disable:array-type */
/* tslint:disable:no-string-literal */
/* tslint:disable:max-classes-per-file */
/* tslint:disable:no-trailing-whitespace */

// ===============================================
// This file is autogenerated - Please do not edit
// Tracks base typescript-fetch mustache 01/02/17
// ===============================================
/**
 * Update Service API
 * This is the API documentation for the Mbed deployment service, which is part of the update service.
 *
 * OpenAPI spec version: 3
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import superagent = require("superagent");
import { ApiBase } from "../common/apiBase";
import { SDKError } from "../common/sdkError";

export type CampaignDeviceMetadataDeploymentStateEnum = "pending" | "updated_connector_channel" | "failed_connector_channel_update" | "deployed" | "manifestremoved";
export interface CampaignDeviceMetadata {
    /**
     * Description
     */
    "description"?: string;
    /**
     * The device's campaign ID
     */
    "campaign"?: string;
    /**
     * The time the campaign was created
     */
    "created_at"?: Date;
    /**
     * Entity name: always 'update-campaign-device-metadata'
     */
    "object"?: string;
    /**
     * This time this record was modified in the database format: date-time
     */
    "updated_at"?: Date;
    /**
     * How the firmware is delivered (connector or direct)
     */
    "mechanism"?: string;
    /**
     * The record name
     */
    "name"?: string;
    /**
     * API resource entity version
     */
    "etag"?: string;
    /**
     * The Cloud Connect URL
     */
    "mechanism_url"?: string;
    /**
     * The state of the update campaign on the device
     */
    "deployment_state"?: CampaignDeviceMetadataDeploymentStateEnum;
    /**
     * The metadata record ID
     */
    "id"?: string;
    /**
     * The device ID
     */
    "device_id"?: string;
}

export type CampaignDeviceMetadataPageOrderEnum = "ASC" | "DESC";
export interface CampaignDeviceMetadataPage {
    /**
     * The entity ID to fetch after the given one
     */
    "after"?: string;
    /**
     * Flag indicating whether there are more results
     */
    "has_more"?: boolean;
    /**
     * The total number or records, if requested. It might be returned also for small lists.
     */
    "total_count"?: number;
    /**
     * Entity name: always ‘list’
     */
    "object"?: string;
    /**
     * The number of results to return, (range: 2-1000), or equals to total_count
     */
    "limit"?: number;
    /**
     * A list of entities
     */
    "data"?: Array<CampaignDeviceMetadata>;
    /**
     * The order of the records to return. Acceptable values: ASC, DESC. Default: ASC
     */
    "order"?: CampaignDeviceMetadataPageOrderEnum;
}

export interface FirmwareImage {
    /**
     * The firmware image file URL
     */
    "datafile": string;
    /**
     * The description of the object
     */
    "description": string;
    /**
     * The time the object was created
     */
    "created_at": Date;
    /**
     * The API resource entity
     */
    "object": string;
    /**
     * The time the object was updated
     */
    "updated_at": Date;
    /**
     * The entity instance signature
     */
    "etag": Date;
    /**
     * Checksum generated for the datafile
     */
    "datafile_checksum": string;
    /**
     * Size of the datafile in bytes
     */
    "datafile_size"?: number;
    /**
     * The firmware image ID
     */
    "id": string;
    /**
     * The firmware image name
     */
    "name": string;
}

export type FirmwareImagePageOrderEnum = "ASC" | "DESC";
export interface FirmwareImagePage {
    "object"?: string;
    "has_more"?: boolean;
    "total_count"?: number;
    "after"?: string;
    "limit"?: number;
    "data"?: Array<FirmwareImage>;
    /**
     * The order of the records to return. Acceptable values: ASC, DESC. Default: ASC
     */
    "order"?: FirmwareImagePageOrderEnum;
}

export interface FirmwareManifest {
    /**
     * The URL of the firmware manifest binary
     */
    "datafile": string;
    /**
     * The description of the firmware manifest
     */
    "description": string;
    /**
     * The firmware manifest version as a timestamp
     */
    "timestamp": Date;
    /**
     * The time the object was created
     */
    "created_at": Date;
    /**
     * The API resource entity
     */
    "object": string;
    /**
     * The time the object was updated
     */
    "updated_at": Date;
    "manifest_contents": ManifestContents;
    /**
     * The entity instance signature
     */
    "etag": Date;
    /**
     * The class of the device
     */
    "device_class": string;
    /**
     * Checksum generated for the datafile
     */
    "datafile_checksum"?: string;
    /**
     * Size of the datafile in bytes
     */
    "datafile_size"?: number;
    /**
     * The firmware manifest ID
     */
    "id": string;
    /**
     * The name of the object
     */
    "name": string;
}

export type FirmwareManifestPageOrderEnum = "ASC" | "DESC";
export interface FirmwareManifestPage {
    "object"?: string;
    "has_more"?: boolean;
    "total_count"?: number;
    "after"?: string;
    "limit"?: number;
    "data"?: Array<FirmwareManifest>;
    /**
     * The order of the records to return. Acceptable values: ASC, DESC. Default: ASC
     */
    "order"?: FirmwareManifestPageOrderEnum;
}

export interface ManifestContents {
    /**
     * The device class's 128-bit RFC4122 GUID as a hexidecimal digit string
     */
    "classId"?: string;
    /**
     * The vendor's 128-bit RFC4122 GUID as a hexidecimal digit string
     */
    "vendorId"?: string;
    /**
     * The manifest format version
     */
    "manifestVersion"?: number;
    /**
     * A short description of the update
     */
    "description"?: string;
    /**
     * A 128-bit random field. This is provided by the manifest tool to ensure that the signing algorithm is safe from timing side-channel attacks.
     */
    "nonce"?: string;
    /**
     * The time the manifest was created. The timestamp is stored as Unix time.
     */
    "timestamp"?: number;
    "encryptionMode"?: ManifestContentsEncryptionMode;
    /**
     * A flag that indicates whether the update described by the manifest should be applied as soon as possible
     */
    "applyImmediately"?: boolean;
    /**
     * The device's 128-bit RFC4122 GUID as a hexidecimal digit string. Each device has a single, unique device ID.
     */
    "deviceId"?: string;
    "payload"?: ManifestContentsPayload;
}

export interface ManifestContentsEncryptionMode {
    /**
     * The kind of hashing, signing, and encryption to use. These modes are available: 1: none-ecc-secp256r1-sha256: SHA-256 hashing, ECDSA signatures, using the secp256r1 curve. No payload encryption is used. 2: aes-128-ctr-ecc-secp256r1-sha256: SHA-256 hashing, ECDSA signatures, using the secp256r1 curve. The payload is encrypted with AES-128 in CTR-mode. 3: none-none-sha256: SHA-256 hashing. No signature is used. No payload encryption is used. This mode is not recommended except over existing, trusted connections. 
     */
    "enum"?: number;
}

export interface ManifestContentsPayload {
    "format"?: ManifestContentsPayloadFormat;
    "reference"?: ManifestContentsPayloadReference;
    /**
     * An payload storage destination identifier. The identifier specifies where to place the firmware image on the device. For example, when an IoT device has multiple microcontrollers (MCUs), the identifier determines which MCU receives the image.
     */
    "storageIdentifier"?: string;
}

export interface ManifestContentsPayloadFormat {
    /**
     * Format of the payload. Can be: 1: raw-binary 2: cbor 3: hex-location-length-data 4: elf 
     */
    "enum"?: number;
}

export interface ManifestContentsPayloadReference {
    /**
     * Hex representation of the SHA-256 hash of the payload
     */
    "hash"?: string;
    /**
     * The payload URI
     */
    "uri"?: string;
    /**
     * Size of the payload in bytes
     */
    "size"?: number;
}

export type UpdateCampaignStateEnum = "draft" | "scheduled" | "devicefetch" | "devicecopy" | "publishing" | "deploying" | "deployed" | "manifestremoved" | "expired";
export interface UpdateCampaign {
    /**
     * The optional description of the campaign
     */
    "description"?: string;
    "root_manifest_id"?: string;
    /**
     * The time the update campaign was created
     */
    "created_at"?: Date;
    /**
     * The API resource entity
     */
    "object"?: string;
    /**
     * The scheduled start time for the update campaign
     */
    "when"?: string;
    /**
     * The state of the campaign
     */
    "state"?: UpdateCampaignStateEnum;
    /**
     * The campaign finish timestamp
     */
    "finished"?: Date;
    /**
     * The entity instance signature
     */
    "etag"?: string;
    "root_manifest_url"?: string;
    "started_at"?: Date;
    /**
     * The campaign ID
     */
    "id"?: string;
    /**
     * The filter for the devices the campaign will target
     */
    "device_filter"?: string;
    /**
     * The campaign name
     */
    "name"?: string;
}

export type UpdateCampaignPageOrderEnum = "ASC" | "DESC";
export interface UpdateCampaignPage {
    "object"?: string;
    "has_more"?: boolean;
    "total_count"?: number;
    "after"?: string;
    "limit"?: number;
    "data"?: Array<UpdateCampaign>;
    /**
     * The order of the records to return. Acceptable values: ASC, DESC. Default: ASC
     */
    "order"?: UpdateCampaignPageOrderEnum;
}

export type UpdateCampaignPatchRequestStateEnum = "draft" | "scheduled" | "devicefetch" | "devicecopy" | "publishing" | "deploying" | "deployed" | "manifestremoved" | "expired";
export interface UpdateCampaignPatchRequest {
    /**
     * The optional description of the campaign
     */
    "description"?: string;
    "root_manifest_id"?: string;
    /**
     * The API resource entity
     */
    "object"?: string;
    /**
     * The scheduled start time for the update campaign
     */
    "when"?: string;
    /**
     * The state of the campaign
     */
    "state"?: UpdateCampaignPatchRequestStateEnum;
    /**
     * The filter for the devices the campaign will target
     */
    "device_filter"?: string;
    /**
     * The campaign name
     */
    "name"?: string;
}

export type UpdateCampaignPostRequestStateEnum = "draft" | "scheduled" | "devicefetch" | "devicecopy" | "publishing" | "deploying" | "deployed" | "manifestremoved" | "expired";
export interface UpdateCampaignPostRequest {
    /**
     * The optional description of the campaign
     */
    "description"?: string;
    "root_manifest_id"?: string;
    /**
     * The API resource entity
     */
    "object"?: string;
    /**
     * The scheduled start time for the update campaign
     */
    "when"?: string;
    /**
     * The state of the campaign
     */
    "state"?: UpdateCampaignPostRequestStateEnum;
    /**
     * The filter for the devices the campaign will target
     */
    "device_filter": string;
    /**
     * The name for this campaign
     */
    "name": string;
}

export type UpdateCampaignPutRequestStateEnum = "draft" | "scheduled" | "devicefetch" | "devicecopy" | "publishing" | "deploying" | "deployed" | "manifestremoved" | "expired";
export interface UpdateCampaignPutRequest {
    /**
     * An optional description of the campaign
     */
    "description": string;
    "root_manifest_id": string;
    /**
     * The API resource entity
     */
    "object": string;
    /**
     * The scheduled start time for the update campaign
     */
    "when": string;
    /**
     * The state of the campaign
     */
    "state": UpdateCampaignPutRequestStateEnum;
    /**
     * The filter for the devices the campaign will target
     */
    "device_filter": string;
    /**
     * The campaign's name
     */
    "name": string;
}

/**
 * DefaultApi
 */
export class DefaultApi extends ApiBase {

    /**
     * Create firmware image.
     * @param datafile The firmware image file to upload
     * @param name The name of the firmware image
     * @param description The description of the firmware image
     */
    public firmwareImageCreate(datafile: any, name: string, description?: string, callback?: (error: any, data?: FirmwareImage, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "datafile" is set
        if (datafile === null || datafile === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'datafile' missing."));
            }
            return;
        }
        // verify required parameter "name" is set
        if (name === null || name === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'name' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};
        if (datafile !== undefined) {
            formParams["datafile"] = datafile;
        }
        useFormData = true;

        if (description !== undefined) {
            formParams["description"] = description;
        }

        if (name !== undefined) {
            formParams["name"] = name;
        }

        return this.request<FirmwareImage>({
            url: "/v3/firmware-images/",
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /**
     * Delete firmware image.
     * @param imageId The firmware image ID
     */
    public firmwareImageDestroy(imageId: string, callback?: (error: any, data?: any, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "imageId" is set
        if (imageId === null || imageId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'imageId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};
        return this.request<null>({
            url: "/v3/firmware-images/{image_id}/".replace("{" + "image_id" + "}", String(imageId)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /**
     * List all firmware images.
     * @param limit How many firmware images to retrieve
     * @param order ASC or DESC
     * @param after The ID of the the item after which to retrieve the next page
     * @param filter URL-encoded query string parameter to filter returned data. The results are paginated into groups of 50.  &lt;br/&gt; &#x60;&#x60;&#x60; ?filter&#x3D;{URL-encoded query string} &#x60;&#x60;&#x60; &lt;br/&gt;  The query string is made up of key-value pairs separated by ampersands. For example, this query: &#x60;&#x60;&#x60; key1&#x3D;value1&amp;key2&#x3D;value2&amp;key3&#x3D;value3 &#x60;&#x60;&#x60;  would be URL-encoded as: &#x60;&#x60;&#x60; ?filter&#x3D;key1%3Dvalue1%26key2%3Dvalue2%26key3%3Dvalue3 &#x60;&#x60;&#x60; &lt;br/&gt;  The examples below show the queries in *unencoded* form.&lt;br/&gt;  &lt;br/&gt;**Filtering by campaign properties** &#x60;&#x60;&#x60; state&#x3D;[draft|scheduled|devicefectch|devicecopy|publishing|deploying|deployed|manifestremoved|expired] &#x60;&#x60;&#x60;  &lt;br/&gt; &#x60;&#x60;&#x60; root_manifest_id&#x3D;43217771234242e594ddb433816c498a &#x60;&#x60;&#x60;  &lt;br/&gt;**Filtering on date-time fields**  Date-time fields should be specified in UTC RFC3339 format, &#x60;YYYY-MM-DDThh:mm:ss.msZ&#x60;. There are three permitted variations:  * UTC RFC3339 with milliseconds. Example: &#x60;2016-11-30T16:25:12.1234Z&#x60; * UTC RFC3339 without milliseconds. Example: &#x60;2016-11-30T16:25:12Z&#x60; * UTC RFC3339 shortened without milliseconds and punctuation. Example: &#x60;20161130T162512Z&#x60;  Date-time filtering supports three operators:  * equality * greater than or equal to by appending &#x60;__gte&#x60; to the field name * less than or equal to by appending &#x60;__lte&#x60; to the field name  &#x60;&#x60;&#x60; {field name}[|__lte|__gte]&#x3D;{UTC RFC3339 date-time} &#x60;&#x60;&#x60; &lt;br/&gt;  Time ranges may be specified by including both the &#x60;__gte&#x60; and &#x60;__lte&#x60; forms in the filter. For example:  &#x60;&#x60;&#x60; created_at__gte&#x3D;2016-11-30T16:25:12.1234Z&amp;created_at__lte&#x3D;2016-12-30T00:00:00Z &#x60;&#x60;&#x60;  &lt;br/&gt;**Filtering on multiple fields**  Example: &#x60;&#x60;&#x60; state&#x3D;deployed&amp;created_at__gte&#x3D;2016-11-30T16:25:12.1234Z&amp;created_at__lte&#x3D;2016-12-30T00:00:00Z &#x60;&#x60;&#x60;  The example after URL encoding: &#x60;&#x60;&#x60; ?filter&#x3D;state%3Ddeployed%26created_at__gte%3D2016-11-30T16%3A25%3A12.1234Z%26created_at__lte%3D2016-11-30T00%3A00%3A00Z &#x60;&#x60;&#x60;
     * @param include Comma-separated list of data fields to return. Currently supported: total_count
     */
    public firmwareImageList(limit?: number, order?: string, after?: string, filter?: string, include?: string, callback?: (error: any, data?: FirmwareImagePage, response?: superagent.Response) => any): superagent.SuperAgentRequest {

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (filter !== undefined) {
            queryParameters["filter"] = filter;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};
        return this.request<FirmwareImagePage>({
            url: "/v3/firmware-images/",
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /**
     * Retrieve firmware image.
     * @param imageId The firmware image ID
     */
    public firmwareImageRetrieve(imageId: string, callback?: (error: any, data?: FirmwareImage, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "imageId" is set
        if (imageId === null || imageId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'imageId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};
        return this.request<FirmwareImage>({
            url: "/v3/firmware-images/{image_id}/".replace("{" + "image_id" + "}", String(imageId)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /**
     * Create firmware manifest.
     * @param datafile The manifest file to create. The API gateway enforces the account-specific file size.
     * @param name The name of the firmware manifest
     * @param description The description of the firmware manifest
     */
    public firmwareManifestCreate(datafile: any, name: string, description?: string, callback?: (error: any, data?: FirmwareManifest, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "datafile" is set
        if (datafile === null || datafile === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'datafile' missing."));
            }
            return;
        }
        // verify required parameter "name" is set
        if (name === null || name === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'name' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};
        if (datafile !== undefined) {
            formParams["datafile"] = datafile;
        }
        useFormData = true;

        if (description !== undefined) {
            formParams["description"] = description;
        }

        if (name !== undefined) {
            formParams["name"] = name;
        }

        return this.request<FirmwareManifest>({
            url: "/v3/firmware-manifests/",
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /**
     * Delete firmware manifest.
     * @param manifestId The firmware manifest ID
     */
    public firmwareManifestDestroy(manifestId: string, callback?: (error: any, data?: any, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "manifestId" is set
        if (manifestId === null || manifestId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'manifestId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};
        return this.request<null>({
            url: "/v3/firmware-manifests/{manifest_id}/".replace("{" + "manifest_id" + "}", String(manifestId)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /**
     * List firmware manifests.
     * @param limit How many firmware manifests to retrieve
     * @param order ASC or DESC
     * @param after The ID of the the item after which to retrieve the next page.
     * @param filter URL-encoded query string parameter to filter returned data  &lt;br/&gt; &#x60;&#x60;&#x60; ?filter&#x3D;{URL-encoded query string} &#x60;&#x60;&#x60; &lt;br/&gt;  The query string is made up of key-value pairs separated by ampersands. For example, this query: &#x60;&#x60;&#x60; key1&#x3D;value1&amp;key2&#x3D;value2&amp;key3&#x3D;value3 &#x60;&#x60;&#x60;  would be URL-encoded as: &#x60;&#x60;&#x60; ?filter&#x3D;key1%3Dvalue1%26key2%3Dvalue2%26key3%3Dvalue3 &#x60;&#x60;&#x60; &lt;br/&gt;  The examples below show the queries in *unencoded* form.&lt;br/&gt;  &lt;br/&gt;**Filtering by campaign properties** &#x60;&#x60;&#x60; state&#x3D;[draft|scheduled|devicefectch|devicecopy|publishing|deploying|deployed|manifestremoved|expired] &#x60;&#x60;&#x60;  &lt;br/&gt; &#x60;&#x60;&#x60; root_manifest_id&#x3D;43217771234242e594ddb433816c498a &#x60;&#x60;&#x60;  &lt;br/&gt;**Filtering on date-time fields**  Date-time fields should be specified in UTC RFC3339 format, &#x60;YYYY-MM-DDThh:mm:ss.msZ&#x60;. There are three permitted variations:  * UTC RFC3339 with milliseconds. Example: &#x60;2016-11-30T16:25:12.1234Z&#x60; * UTC RFC3339 without milliseconds. Example: &#x60;2016-11-30T16:25:12Z&#x60; * UTC RFC3339 shortened without milliseconds and punctuation. Example: &#x60;20161130T162512Z&#x60;  Date-time filtering supports three operators:  * equality * greater than or equal to by appending &#x60;__gte&#x60; to the field name * less than or equal to by appending &#x60;__lte&#x60; to the field name  &#x60;&#x60;&#x60; {field name}[|__lte|__gte]&#x3D;{UTC RFC3339 date-time} &#x60;&#x60;&#x60; &lt;br/&gt;  Time ranges may be specified by including both the &#x60;__gte&#x60; and &#x60;__lte&#x60; forms in the filter. For example:  &#x60;&#x60;&#x60; created_at__gte&#x3D;2016-11-30T16:25:12.1234Z&amp;created_at__lte&#x3D;2016-12-30T00:00:00Z &#x60;&#x60;&#x60;  &lt;br/&gt;**Filtering on multiple fields**  Example: &#x60;&#x60;&#x60; state&#x3D;deployed&amp;created_at__gte&#x3D;2016-11-30T16:25:12.1234Z&amp;created_at__lte&#x3D;2016-12-30T00:00:00Z &#x60;&#x60;&#x60;  The example after URL encoding: &#x60;&#x60;&#x60; ?filter&#x3D;state%3Ddeployed%26created_at__gte%3D2016-11-30T16%3A25%3A12.1234Z%26created_at__lte%3D2016-11-30T00%3A00%3A00Z &#x60;&#x60;&#x60;
     * @param include Comma-separated list of data fields to return. Currently supported: total_count
     */
    public firmwareManifestList(limit?: number, order?: string, after?: string, filter?: string, include?: string, callback?: (error: any, data?: FirmwareManifestPage, response?: superagent.Response) => any): superagent.SuperAgentRequest {

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (filter !== undefined) {
            queryParameters["filter"] = filter;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};
        return this.request<FirmwareManifestPage>({
            url: "/v3/firmware-manifests/",
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /**
     * Retrieve firmware manifest.
     * @param manifestId The firmware manifest ID
     */
    public firmwareManifestRetrieve(manifestId: string, callback?: (error: any, data?: FirmwareManifest, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "manifestId" is set
        if (manifestId === null || manifestId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'manifestId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};
        return this.request<FirmwareManifest>({
            url: "/v3/firmware-manifests/{manifest_id}/".replace("{" + "manifest_id" + "}", String(manifestId)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /**
     * Create an update campaign.
     * @param campaign Update campaign
     */
    public updateCampaignCreate(campaign: UpdateCampaignPostRequest, callback?: (error: any, data?: UpdateCampaign, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "campaign" is set
        if (campaign === null || campaign === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'campaign' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};
        return this.request<UpdateCampaign>({
            url: "/v3/update-campaigns/",
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
            body: campaign,
        }, callback);
    }
    /**
     * Delete an update campaign.
     * @param campaignId The ID of the update campaign
     */
    public updateCampaignDestroy(campaignId: string, callback?: (error: any, data?: any, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "campaignId" is set
        if (campaignId === null || campaignId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'campaignId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};
        return this.request<null>({
            url: "/v3/update-campaigns/{campaign_id}/".replace("{" + "campaign_id" + "}", String(campaignId)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /**
     * Get update campaigns for devices specified by a filter.
     * @param limit How many update campaigns to retrieve
     * @param order The order of the records. Acceptable values: ASC, DESC. Default: ASC
     * @param after The ID of the the item after which to retrieve the next page
     * @param filter URL-encoded query string parameter to filter returned data  &lt;br/&gt; &#x60;&#x60;&#x60; ?filter&#x3D;{URL-encoded query string} &#x60;&#x60;&#x60; &lt;br/&gt;  The query string is made up of key-value pairs separated by ampersands. For example, this query: &#x60;&#x60;&#x60; key1&#x3D;value1&amp;key2&#x3D;value2&amp;key3&#x3D;value3 &#x60;&#x60;&#x60;  would be URL-encoded as: &#x60;&#x60;&#x60; ?filter&#x3D;key1%3Dvalue1%26key2%3Dvalue2%26key3%3Dvalue3 &#x60;&#x60;&#x60; &lt;br/&gt;  The examples below show the queries in *unencoded* form.&lt;br/&gt;  &lt;br/&gt;**Filtering by campaign properties** &#x60;&#x60;&#x60; state&#x3D;[draft|scheduled|devicefectch|devicecopy|publishing|deploying|deployed|manifestremoved|expired] &#x60;&#x60;&#x60;  &lt;br/&gt; &#x60;&#x60;&#x60; root_manifest_id&#x3D;43217771234242e594ddb433816c498a &#x60;&#x60;&#x60;  &lt;br/&gt;**Filtering on date-time fields**  Date-time fields should be specified in UTC RFC3339 format, &#x60;YYYY-MM-DDThh:mm:ss.msZ&#x60;. There are three permitted variations:  * UTC RFC3339 with milliseconds. Example: &#x60;2016-11-30T16:25:12.1234Z&#x60; * UTC RFC3339 without milliseconds. Example: &#x60;2016-11-30T16:25:12Z&#x60; * UTC RFC3339 shortened without milliseconds and punctuation. Example: &#x60;20161130T162512Z&#x60;  Date-time filtering supports three operators:  * equality * greater than or equal to by appending &#x60;__gte&#x60; to the field name * less than or equal to by appending &#x60;__lte&#x60; to the field name  &#x60;&#x60;&#x60; {field name}[|__lte|__gte]&#x3D;{UTC RFC3339 date-time} &#x60;&#x60;&#x60; &lt;br/&gt;  Time ranges may be specified by including both the &#x60;__gte&#x60; and &#x60;__lte&#x60; forms in the filter. For example:  &#x60;&#x60;&#x60; created_at__gte&#x3D;2016-11-30T16:25:12.1234Z&amp;created_at__lte&#x3D;2016-12-30T00:00:00Z &#x60;&#x60;&#x60;  &lt;br/&gt;**Filtering on multiple fields**  Example: &#x60;&#x60;&#x60; state&#x3D;deployed&amp;created_at__gte&#x3D;2016-11-30T16:25:12.1234Z&amp;created_at__lte&#x3D;2016-12-30T00:00:00Z &#x60;&#x60;&#x60;  The example after URL encoding: &#x60;&#x60;&#x60; ?filter&#x3D;state%3Ddeployed%26created_at__gte%3D2016-11-30T16%3A25%3A12.1234Z%26created_at__lte%3D2016-11-30T00%3A00%3A00Z &#x60;&#x60;&#x60;
     * @param include Comma-separated list of data fields to return. Currently supported: total_count
     */
    public updateCampaignList(limit?: number, order?: string, after?: string, filter?: string, include?: string, callback?: (error: any, data?: UpdateCampaignPage, response?: superagent.Response) => any): superagent.SuperAgentRequest {

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (filter !== undefined) {
            queryParameters["filter"] = filter;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};
        return this.request<UpdateCampaignPage>({
            url: "/v3/update-campaigns/",
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /**
     * Modify a subset of an update campaign&#39;s fields.
     * @param campaignId 
     * @param campaign Update campaign
     */
    public updateCampaignPartialUpdate(campaignId: string, campaign: UpdateCampaignPatchRequest, callback?: (error: any, data?: UpdateCampaign, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "campaignId" is set
        if (campaignId === null || campaignId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'campaignId' missing."));
            }
            return;
        }
        // verify required parameter "campaign" is set
        if (campaign === null || campaign === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'campaign' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};
        return this.request<UpdateCampaign>({
            url: "/v3/update-campaigns/{campaign_id}/".replace("{" + "campaign_id" + "}", String(campaignId)),
            method: "PATCH",
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
            body: campaign,
        }, callback);
    }
    /**
     * Get an update campaign.
     * @param campaignId The campaign ID
     */
    public updateCampaignRetrieve(campaignId: string, callback?: (error: any, data?: UpdateCampaign, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "campaignId" is set
        if (campaignId === null || campaignId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'campaignId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};
        return this.request<UpdateCampaign>({
            url: "/v3/update-campaigns/{campaign_id}/".replace("{" + "campaign_id" + "}", String(campaignId)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /**
     * Modify an update campaign.
     * @param campaignId 
     * @param campaign Update campaign
     */
    public updateCampaignUpdate(campaignId: string, campaign: UpdateCampaignPutRequest, callback?: (error: any, data?: UpdateCampaign, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "campaignId" is set
        if (campaignId === null || campaignId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'campaignId' missing."));
            }
            return;
        }
        // verify required parameter "campaign" is set
        if (campaign === null || campaign === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'campaign' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};
        return this.request<UpdateCampaign>({
            url: "/v3/update-campaigns/{campaign_id}/".replace("{" + "campaign_id" + "}", String(campaignId)),
            method: "PUT",
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
            body: campaign,
        }, callback);
    }
    /**
     * Get update campaign metadata.
     * @param campaignId The update campaign ID
     * @param campaignDeviceMetadataId The campaign device metadata ID
     */
    public v3UpdateCampaignsCampaignIdCampaignDeviceMetadataCampaignDeviceMetadataIdGet(campaignId: string, campaignDeviceMetadataId: string, callback?: (error: any, data?: CampaignDeviceMetadata, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "campaignId" is set
        if (campaignId === null || campaignId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'campaignId' missing."));
            }
            return;
        }
        // verify required parameter "campaignDeviceMetadataId" is set
        if (campaignDeviceMetadataId === null || campaignDeviceMetadataId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'campaignDeviceMetadataId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};
        return this.request<CampaignDeviceMetadata>({
            url: "/v3/update-campaigns/{campaign_id}/campaign-device-metadata/{campaign_device_metadata_id}/".replace("{" + "campaign_id" + "}", String(campaignId)).replace("{" + "campaign_device_metadata_id" + "}", String(campaignDeviceMetadataId)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /**
     * Get campaign device metadata.
     * @param campaignId The update campaign ID
     * @param limit How many objects to retrieve in the page
     * @param order ASC or DESC
     * @param after The ID of the the item after which to retrieve the next page
     * @param include Comma-separated list of data fields to return. Currently supported: total_count
     */
    public v3UpdateCampaignsCampaignIdCampaignDeviceMetadataGet(campaignId: string, limit?: number, order?: string, after?: string, include?: string, callback?: (error: any, data?: CampaignDeviceMetadataPage, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "campaignId" is set
        if (campaignId === null || campaignId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'campaignId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};
        return this.request<CampaignDeviceMetadataPage>({
            url: "/v3/update-campaigns/{campaign_id}/campaign-device-metadata/".replace("{" + "campaign_id" + "}", String(campaignId)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
}
