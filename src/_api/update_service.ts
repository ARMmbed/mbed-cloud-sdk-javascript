/* tslint:disable:array-type */
/* tslint:disable:no-string-literal */
/* tslint:disable:max-classes-per-file */
/* tslint:disable:no-trailing-whitespace */

// ===============================================
// This file is autogenerated - Please do not edit
// Tracks base typescript-fetch mustache 01/02/17
// ===============================================

/**
 * Update Service API
 * This is the API documentation for the Mbed deployment service, which is part of the update service.
 *
 * OpenAPI spec version: 3
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import superagent = require("superagent");
import { ApiBase } from "../common/apiBase";
import { SDKError } from "../common/sdkError";

export namespace CampaignDeviceMetadata {
    export type DeploymentStateEnum = "pending" | "updated_connector_channel" | "failed_connector_channel_update" | "deployed" | "manifestremoved" | "deregistered";
}
export interface CampaignDeviceMetadata {
    /**
     * Description
     */
    "description"?: string;
    /**
     * The device's campaign ID
     */
    "campaign"?: string;
    /**
     * The time the campaign was created
     */
    "created_at"?: Date;
    /**
     * Entity name: always 'update-campaign-device-metadata'
     */
    "object"?: string;
    /**
     * This time this record was modified in the database format: date-time
     */
    "updated_at"?: Date;
    /**
     * How the firmware is delivered (connector or direct)
     */
    "mechanism"?: string;
    /**
     * The record name
     */
    "name"?: string;
    /**
     * API resource entity version
     */
    "etag"?: string;
    /**
     * The Cloud Connect URL
     */
    "mechanism_url"?: string;
    /**
     * The state of the update campaign on the device
     */
    "deployment_state"?: CampaignDeviceMetadata.DeploymentStateEnum;
    /**
     * The metadata record ID
     */
    "id"?: string;
    /**
     * The device ID
     */
    "device_id"?: string;
}

export namespace CampaignDeviceMetadataPage {
    export type OrderEnum = "ASC" | "DESC";
}
export interface CampaignDeviceMetadataPage {
    /**
     * The entity ID to fetch after the given one
     */
    "after"?: string;
    /**
     * Flag indicating whether there are more results
     */
    "has_more"?: boolean;
    /**
     * The total number or records, if requested. It might be returned also for small lists.
     */
    "total_count"?: number;
    /**
     * Entity name: always ‘list’
     */
    "object"?: string;
    /**
     * The number of results to return, (range: 2-1000), or equals to total_count
     */
    "limit"?: number;
    /**
     * A list of entities
     */
    "data"?: Array<CampaignDeviceMetadata>;
    /**
     * The order of the records to return. Acceptable values: ASC, DESC. Default: ASC
     */
    "order"?: CampaignDeviceMetadataPage.OrderEnum;
}

export interface FirmwareImage {
    /**
     * The firmware image file URL
     */
    "datafile": string;
    /**
     * The description of the object
     */
    "description": string;
    /**
     * The time the object was created
     */
    "created_at": Date;
    /**
     * The API resource entity
     */
    "object": string;
    /**
     * The time the object was updated
     */
    "updated_at": Date;
    /**
     * The entity instance signature
     */
    "etag": Date;
    /**
     * Checksum generated for the datafile
     */
    "datafile_checksum": string;
    /**
     * Size of the datafile in bytes
     */
    "datafile_size"?: number;
    /**
     * The firmware image ID
     */
    "id": string;
    /**
     * The firmware image name
     */
    "name": string;
}

export namespace FirmwareImagePage {
    export type OrderEnum = "ASC" | "DESC";
}
export interface FirmwareImagePage {
    "object"?: string;
    "has_more"?: boolean;
    "total_count"?: number;
    "after"?: string;
    "limit"?: number;
    "data"?: Array<FirmwareImage>;
    /**
     * The order of the records based on creation time, `ASC` or `DESC`; by default `ASC`.
     */
    "order"?: FirmwareImagePage.OrderEnum;
}

export interface FirmwareManifest {
    /**
     * The URL of the firmware manifest binary
     */
    "datafile": string;
    /**
     * The description of the firmware manifest
     */
    "description": string;
    /**
     * The firmware manifest version as a timestamp
     */
    "timestamp": Date;
    /**
     * The time the object was created
     */
    "created_at": Date;
    /**
     * The API resource entity
     */
    "object": string;
    /**
     * The time the object was updated
     */
    "updated_at": Date;
    /**
     * The entity instance signature
     */
    "etag": Date;
    /**
     * The class of the device
     */
    "device_class": string;
    /**
     * Checksum generated for the datafile
     */
    "datafile_checksum"?: string;
    /**
     * Size of the datafile in bytes
     */
    "datafile_size"?: number;
    /**
     * The firmware manifest ID
     */
    "id": string;
    /**
     * The name of the object
     */
    "name": string;
}

export namespace FirmwareManifestPage {
    export type OrderEnum = "ASC" | "DESC";
}
export interface FirmwareManifestPage {
    "object"?: string;
    "has_more"?: boolean;
    "total_count"?: number;
    "after"?: string;
    "limit"?: number;
    "data"?: Array<FirmwareManifest>;
    /**
     * The order of the records to return. Acceptable values: ASC, DESC. Default: ASC
     */
    "order"?: FirmwareManifestPage.OrderEnum;
}

export namespace UpdateCampaign {
    export type StateEnum = "draft" | "scheduled" | "devicefetch" | "devicecopy" | "publishing" | "deploying" | "deployed" | "manifestremoved" | "expired";
}
export interface UpdateCampaign {
    /**
     * The optional description of the campaign
     */
    "description"?: string;
    "root_manifest_id"?: string;
    /**
     * The time the update campaign was created
     */
    "created_at"?: Date;
    /**
     * The API resource entity
     */
    "object"?: string;
    /**
     * The scheduled start time for the update campaign
     */
    "when"?: Date;
    /**
     * The state of the campaign
     */
    "state"?: UpdateCampaign.StateEnum;
    /**
     * The campaign finish timestamp
     */
    "finished"?: Date;
    /**
     * The entity instance signature
     */
    "etag"?: string;
    "root_manifest_url"?: string;
    "started_at"?: Date;
    /**
     * The campaign ID
     */
    "id"?: string;
    /**
     * The filter for the devices the campaign will target
     */
    "device_filter"?: string;
    /**
     * The campaign name
     */
    "name"?: string;
}

export namespace UpdateCampaignPage {
    export type OrderEnum = "ASC" | "DESC";
}
export interface UpdateCampaignPage {
    "object"?: string;
    "has_more"?: boolean;
    "total_count"?: number;
    "after"?: string;
    "limit"?: number;
    "data"?: Array<UpdateCampaign>;
    /**
     * The order of the records to return. Acceptable values: ASC, DESC. Default: ASC
     */
    "order"?: UpdateCampaignPage.OrderEnum;
}

export namespace UpdateCampaignPatchRequest {
    export type StateEnum = "draft" | "scheduled" | "devicefetch" | "devicecopy" | "publishing" | "deploying" | "deployed" | "manifestremoved" | "expired";
}
export interface UpdateCampaignPatchRequest {
    /**
     * The optional description of the campaign
     */
    "description"?: string;
    "root_manifest_id"?: string;
    /**
     * The API resource entity
     */
    "object"?: string;
    /**
     * The scheduled start time for the update campaign
     */
    "when"?: Date;
    /**
     * The state of the campaign
     */
    "state"?: UpdateCampaignPatchRequest.StateEnum;
    /**
     * The filter for the devices the campaign will target
     */
    "device_filter"?: string;
    /**
     * The campaign name
     */
    "name"?: string;
}

export namespace UpdateCampaignPostRequest {
    export type StateEnum = "draft" | "scheduled" | "devicefetch" | "devicecopy" | "publishing" | "deploying" | "deployed" | "manifestremoved" | "expired";
}
export interface UpdateCampaignPostRequest {
    /**
     * The optional description of the campaign
     */
    "description"?: string;
    "root_manifest_id"?: string;
    /**
     * The API resource entity
     */
    "object"?: string;
    /**
     * The scheduled start time for the update campaign
     */
    "when"?: Date;
    /**
     * The state of the campaign
     */
    "state"?: UpdateCampaignPostRequest.StateEnum;
    /**
     * The filter for the devices the campaign will target
     */
    "device_filter": string;
    /**
     * The name for this campaign
     */
    "name": string;
}

export namespace UpdateCampaignPutRequest {
    export type StateEnum = "draft" | "scheduled" | "devicefetch" | "devicecopy" | "publishing" | "deploying" | "deployed" | "manifestremoved" | "expired";
}
export interface UpdateCampaignPutRequest {
    /**
     * An optional description of the campaign
     */
    "description": string;
    "root_manifest_id": string;
    /**
     * The API resource entity
     */
    "object": string;
    /**
     * The scheduled start time for the update campaign
     */
    "when": Date;
    /**
     * The state of the campaign
     */
    "state": UpdateCampaignPutRequest.StateEnum;
    /**
     * The filter for the devices the campaign will target
     */
    "device_filter": string;
    /**
     * The campaign's name
     */
    "name": string;
}

/**
 * DefaultApi
 */
export class DefaultApi extends ApiBase {

    /**
     * Create firmware image.
     * @param datafile The firmware image file to upload
     * @param name The name of the firmware image
     * @param description The description of the firmware image
     */
    public firmwareImageCreate(datafile: any, name: string, description?: string, callback?: (error: any, data?: FirmwareImage, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "datafile" is set
        if (datafile === null || datafile === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'datafile' missing."));
            }
            return;
        }
        // verify required parameter "name" is set
        if (name === null || name === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'name' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        if (datafile !== undefined) {
            formParams["datafile"] = datafile;
        }
        useFormData = true;

        if (description !== undefined) {
            formParams["description"] = description;
        }

        if (name !== undefined) {
            formParams["name"] = name;
        }

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "multipart/form-data"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<FirmwareImage>({
            url: "/v3/firmware-images/",
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
        }, callback);
    }
    /**
     * Delete firmware image.
     * @param imageId The firmware image ID
     */
    public firmwareImageDestroy(imageId: string, callback?: (error: any, data?: any, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "imageId" is set
        if (imageId === null || imageId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'imageId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<null>({
            url: "/v3/firmware-images/{image_id}/".replace("{" + "image_id" + "}", String(imageId)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
        }, callback);
    }
    /**
     * List all firmware images.
     * @param limit How many firmware images to retrieve
     * @param order ASC or DESC
     * @param after The ID of the the item after which to retrieve the next page
     * @param filter URL-encoded query string parameter to filter returned data. The results are paginated into groups of 50.  &lt;br/&gt; ?filter&#x3D;{URL-encoded query string} &lt;br/&gt;  The query string is made up of key-value pairs separated by ampersands. For example, this query: key1&#x3D;value1&amp;key2&#x3D;value2&amp;key3&#x3D;value3  would be URL-encoded as: ?filter&#x3D;key1%3Dvalue1%26key2%3Dvalue2%26key3%3Dvalue3 &lt;br/&gt;  The examples below show the queries in *unencoded* form.&lt;br/&gt;  &lt;br/&gt;**Filtering by campaign properties** state&#x3D;[draft|scheduled|devicefectch|devicecopy|publishing|deploying|deployed|manifestremoved|expired]  &lt;br/&gt; root_manifest_id&#x3D;43217771234242e594ddb433816c498a  &lt;br/&gt;**Filtering on date-time fields**  Date-time fields should be specified in UTC RFC3339 format, &#x60;YYYY-MM-DDThh:mm:ss.msZ&#x60;. There are three permitted variations:  * UTC RFC3339 with milliseconds. Example: &#x60;2016-11-30T16:25:12.1234Z&#x60; * UTC RFC3339 without milliseconds. Example: &#x60;2016-11-30T16:25:12Z&#x60; * UTC RFC3339 shortened without milliseconds and punctuation. Example: &#x60;20161130T162512Z&#x60;  Date-time filtering supports three operators:  * equality * greater than or equal to by appending &#x60;__gte&#x60; to the field name * less than or equal to by appending &#x60;__lte&#x60; to the field name  {field name}[|__lte|__gte]&#x3D;{UTC RFC3339 date-time} &lt;br/&gt;  Time ranges may be specified by including both the &#x60;__gte&#x60; and &#x60;__lte&#x60; forms in the filter. For example:  created_at__gte&#x3D;2016-11-30T16:25:12.1234Z&amp;created_at__lte&#x3D;2016-12-30T00:00:00Z  &lt;br/&gt;**Filtering on multiple fields**  Example: state&#x3D;deployed&amp;created_at__gte&#x3D;2016-11-30T16:25:12.1234Z&amp;created_at__lte&#x3D;2016-12-30T00:00:00Z  The example after URL encoding: ?filter&#x3D;state%3Ddeployed%26created_at__gte%3D2016-11-30T16%3A25%3A12.1234Z%26created_at__lte%3D2016-11-30T00%3A00%3A00Z
     * @param include Comma-separated list of data fields to return. Currently supported: total_count
     */
    public firmwareImageList(limit?: number, order?: string, after?: string, filter?: string, include?: string, callback?: (error: any, data?: FirmwareImagePage, response?: superagent.Response) => any): superagent.SuperAgentRequest {

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (filter !== undefined) {
            queryParameters["filter"] = filter;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<FirmwareImagePage>({
            url: "/v3/firmware-images/",
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
        }, callback);
    }
    /**
     * Retrieve firmware image.
     * @param imageId The firmware image ID
     */
    public firmwareImageRetrieve(imageId: string, callback?: (error: any, data?: FirmwareImage, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "imageId" is set
        if (imageId === null || imageId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'imageId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<FirmwareImage>({
            url: "/v3/firmware-images/{image_id}/".replace("{" + "image_id" + "}", String(imageId)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
        }, callback);
    }
    /**
     * Create firmware manifest.
     * @param datafile The manifest file to create. The API gateway enforces the account-specific file size.
     * @param name The name of the firmware manifest
     * @param description The description of the firmware manifest
     */
    public firmwareManifestCreate(datafile: any, name: string, description?: string, callback?: (error: any, data?: FirmwareManifest, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "datafile" is set
        if (datafile === null || datafile === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'datafile' missing."));
            }
            return;
        }
        // verify required parameter "name" is set
        if (name === null || name === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'name' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        if (datafile !== undefined) {
            formParams["datafile"] = datafile;
        }
        useFormData = true;

        if (description !== undefined) {
            formParams["description"] = description;
        }

        if (name !== undefined) {
            formParams["name"] = name;
        }

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "multipart/form-data"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<FirmwareManifest>({
            url: "/v3/firmware-manifests/",
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
        }, callback);
    }
    /**
     * Delete firmware manifest.
     * @param manifestId The firmware manifest ID
     */
    public firmwareManifestDestroy(manifestId: string, callback?: (error: any, data?: any, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "manifestId" is set
        if (manifestId === null || manifestId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'manifestId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<null>({
            url: "/v3/firmware-manifests/{manifest_id}/".replace("{" + "manifest_id" + "}", String(manifestId)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
        }, callback);
    }
    /**
     * List firmware manifests.
     * @param limit How many firmware manifests to retrieve
     * @param order ASC or DESC
     * @param after The ID of the the item after which to retrieve the next page.
     * @param filter URL-encoded query string parameter to filter returned data  &lt;br/&gt; ?filter&#x3D;{URL-encoded query string} &lt;br/&gt;  The query string is made up of key-value pairs separated by ampersands. For example, this query: key1&#x3D;value1&amp;key2&#x3D;value2&amp;key3&#x3D;value3  would be URL-encoded as: ?filter&#x3D;key1%3Dvalue1%26key2%3Dvalue2%26key3%3Dvalue3 &lt;br/&gt;  The examples below show the queries in *unencoded* form.&lt;br/&gt;  &lt;br/&gt;**Filtering by campaign properties** state&#x3D;[draft|scheduled|devicefectch|devicecopy|publishing|deploying|deployed|manifestremoved|expired]  &lt;br/&gt; root_manifest_id&#x3D;43217771234242e594ddb433816c498a  &lt;br/&gt;**Filtering on date-time fields**  Date-time fields should be specified in UTC RFC3339 format, &#x60;YYYY-MM-DDThh:mm:ss.msZ&#x60;. There are three permitted variations:  * UTC RFC3339 with milliseconds. Example: &#x60;2016-11-30T16:25:12.1234Z&#x60; * UTC RFC3339 without milliseconds. Example: &#x60;2016-11-30T16:25:12Z&#x60; * UTC RFC3339 shortened without milliseconds and punctuation. Example: &#x60;20161130T162512Z&#x60;  Date-time filtering supports three operators:  * equality * greater than or equal to by appending &#x60;__gte&#x60; to the field name * less than or equal to by appending &#x60;__lte&#x60; to the field name  {field name}[|__lte|__gte]&#x3D;{UTC RFC3339 date-time} &lt;br/&gt;  Time ranges may be specified by including both the &#x60;__gte&#x60; and &#x60;__lte&#x60; forms in the filter. For example:  created_at__gte&#x3D;2016-11-30T16:25:12.1234Z&amp;created_at__lte&#x3D;2016-12-30T00:00:00Z  &lt;br/&gt;**Filtering on multiple fields**  Example: state&#x3D;deployed&amp;created_at__gte&#x3D;2016-11-30T16:25:12.1234Z&amp;created_at__lte&#x3D;2016-12-30T00:00:00Z  The example after URL encoding: ?filter&#x3D;state%3Ddeployed%26created_at__gte%3D2016-11-30T16%3A25%3A12.1234Z%26created_at__lte%3D2016-11-30T00%3A00%3A00Z
     * @param include Comma-separated list of data fields to return. Currently supported: total_count
     */
    public firmwareManifestList(limit?: number, order?: string, after?: string, filter?: string, include?: string, callback?: (error: any, data?: FirmwareManifestPage, response?: superagent.Response) => any): superagent.SuperAgentRequest {

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (filter !== undefined) {
            queryParameters["filter"] = filter;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<FirmwareManifestPage>({
            url: "/v3/firmware-manifests/",
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
        }, callback);
    }
    /**
     * Retrieve firmware manifest.
     * @param manifestId The firmware manifest ID
     */
    public firmwareManifestRetrieve(manifestId: string, callback?: (error: any, data?: FirmwareManifest, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "manifestId" is set
        if (manifestId === null || manifestId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'manifestId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<FirmwareManifest>({
            url: "/v3/firmware-manifests/{manifest_id}/".replace("{" + "manifest_id" + "}", String(manifestId)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
        }, callback);
    }
    /**
     * Create an update campaign.
     * @param campaign Update campaign
     */
    public updateCampaignCreate(campaign: UpdateCampaignPostRequest, callback?: (error: any, data?: UpdateCampaign, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "campaign" is set
        if (campaign === null || campaign === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'campaign' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdateCampaign>({
            url: "/v3/update-campaigns/",
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            body: campaign,
        }, callback);
    }
    /**
     * Delete an update campaign.
     * @param campaignId The ID of the update campaign
     */
    public updateCampaignDestroy(campaignId: string, callback?: (error: any, data?: any, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "campaignId" is set
        if (campaignId === null || campaignId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'campaignId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<null>({
            url: "/v3/update-campaigns/{campaign_id}/".replace("{" + "campaign_id" + "}", String(campaignId)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
        }, callback);
    }
    /**
     * Get update campaigns for devices specified by a filter.
     * @param limit How many update campaigns to retrieve
     * @param order The order of the records. Acceptable values: ASC, DESC. Default: ASC
     * @param after The ID of the the item after which to retrieve the next page
     * @param filter URL-encoded query string parameter to filter returned data  &lt;br/&gt; ?filter&#x3D;{URL-encoded query string} &lt;br/&gt;  The query string is made up of key-value pairs separated by ampersands. For example, this query: key1&#x3D;value1&amp;key2&#x3D;value2&amp;key3&#x3D;value3  would be URL-encoded as: ?filter&#x3D;key1%3Dvalue1%26key2%3Dvalue2%26key3%3Dvalue3 &lt;br/&gt;  The examples below show the queries in *unencoded* form.&lt;br/&gt;  &lt;br/&gt;**Filtering by campaign properties** state&#x3D;[draft|scheduled|devicefectch|devicecopy|publishing|deploying|deployed|manifestremoved|expired]  &lt;br/&gt; root_manifest_id&#x3D;43217771234242e594ddb433816c498a  &lt;br/&gt;**Filtering on date-time fields**  Date-time fields should be specified in UTC RFC3339 format, &#x60;YYYY-MM-DDThh:mm:ss.msZ&#x60;. There are three permitted variations:  * UTC RFC3339 with milliseconds. Example: &#x60;2016-11-30T16:25:12.1234Z&#x60; * UTC RFC3339 without milliseconds. Example: &#x60;2016-11-30T16:25:12Z&#x60; * UTC RFC3339 shortened without milliseconds and punctuation. Example: &#x60;20161130T162512Z&#x60;  Date-time filtering supports three operators:  * equality * greater than or equal to by appending &#x60;__gte&#x60; to the field name * less than or equal to by appending &#x60;__lte&#x60; to the field name  {field name}[|__lte|__gte]&#x3D;{UTC RFC3339 date-time} &lt;br/&gt;  Time ranges may be specified by including both the &#x60;__gte&#x60; and &#x60;__lte&#x60; forms in the filter. For example:  created_at__gte&#x3D;2016-11-30T16:25:12.1234Z&amp;created_at__lte&#x3D;2016-12-30T00:00:00Z  &lt;br/&gt;**Filtering on multiple fields**  Example: state&#x3D;deployed&amp;created_at__gte&#x3D;2016-11-30T16:25:12.1234Z&amp;created_at__lte&#x3D;2016-12-30T00:00:00Z  The example after URL encoding: ?filter&#x3D;state%3Ddeployed%26created_at__gte%3D2016-11-30T16%3A25%3A12.1234Z%26created_at__lte%3D2016-11-30T00%3A00%3A00Z
     * @param include Comma-separated list of data fields to return. Currently supported: total_count
     */
    public updateCampaignList(limit?: number, order?: string, after?: string, filter?: string, include?: string, callback?: (error: any, data?: UpdateCampaignPage, response?: superagent.Response) => any): superagent.SuperAgentRequest {

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (filter !== undefined) {
            queryParameters["filter"] = filter;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdateCampaignPage>({
            url: "/v3/update-campaigns/",
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
        }, callback);
    }
    /**
     * Modify a subset of an update campaign&#39;s fields.
     * @param campaignId 
     * @param campaign Update campaign
     */
    public updateCampaignPartialUpdate(campaignId: string, campaign: UpdateCampaignPatchRequest, callback?: (error: any, data?: UpdateCampaign, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "campaignId" is set
        if (campaignId === null || campaignId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'campaignId' missing."));
            }
            return;
        }
        // verify required parameter "campaign" is set
        if (campaign === null || campaign === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'campaign' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdateCampaign>({
            url: "/v3/update-campaigns/{campaign_id}/".replace("{" + "campaign_id" + "}", String(campaignId)),
            method: "PATCH",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            body: campaign,
        }, callback);
    }
    /**
     * Get an update campaign.
     * @param campaignId The campaign ID
     */
    public updateCampaignRetrieve(campaignId: string, callback?: (error: any, data?: UpdateCampaign, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "campaignId" is set
        if (campaignId === null || campaignId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'campaignId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdateCampaign>({
            url: "/v3/update-campaigns/{campaign_id}/".replace("{" + "campaign_id" + "}", String(campaignId)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
        }, callback);
    }
    /**
     * Modify an update campaign.
     * @param campaignId 
     * @param campaign Update campaign
     */
    public updateCampaignUpdate(campaignId: string, campaign: UpdateCampaignPutRequest, callback?: (error: any, data?: UpdateCampaign, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "campaignId" is set
        if (campaignId === null || campaignId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'campaignId' missing."));
            }
            return;
        }
        // verify required parameter "campaign" is set
        if (campaign === null || campaign === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'campaign' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdateCampaign>({
            url: "/v3/update-campaigns/{campaign_id}/".replace("{" + "campaign_id" + "}", String(campaignId)),
            method: "PUT",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            body: campaign,
        }, callback);
    }
    /**
     * Get update campaign metadata.
     * @param campaignId The update campaign ID
     * @param campaignDeviceMetadataId The campaign device metadata ID
     */
    public v3UpdateCampaignsCampaignIdCampaignDeviceMetadataCampaignDeviceMetadataIdGet(campaignId: string, campaignDeviceMetadataId: string, callback?: (error: any, data?: CampaignDeviceMetadata, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "campaignId" is set
        if (campaignId === null || campaignId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'campaignId' missing."));
            }
            return;
        }
        // verify required parameter "campaignDeviceMetadataId" is set
        if (campaignDeviceMetadataId === null || campaignDeviceMetadataId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'campaignDeviceMetadataId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<CampaignDeviceMetadata>({
            url: "/v3/update-campaigns/{campaign_id}/campaign-device-metadata/{campaign_device_metadata_id}/".replace("{" + "campaign_id" + "}", String(campaignId)).replace("{" + "campaign_device_metadata_id" + "}", String(campaignDeviceMetadataId)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
        }, callback);
    }
    /**
     * Get campaign device metadata.
     * @param campaignId The update campaign ID
     * @param limit How many objects to retrieve in the page
     * @param order ASC or DESC
     * @param after The ID of the the item after which to retrieve the next page
     * @param include Comma-separated list of data fields to return. Currently supported: total_count
     */
    public v3UpdateCampaignsCampaignIdCampaignDeviceMetadataGet(campaignId: string, limit?: number, order?: string, after?: string, include?: string, callback?: (error: any, data?: CampaignDeviceMetadataPage, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "campaignId" is set
        if (campaignId === null || campaignId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'campaignId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<CampaignDeviceMetadataPage>({
            url: "/v3/update-campaigns/{campaign_id}/campaign-device-metadata/".replace("{" + "campaign_id" + "}", String(campaignId)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
        }, callback);
    }
}
