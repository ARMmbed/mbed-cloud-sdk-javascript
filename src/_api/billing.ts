// ===============================================
// This file is autogenerated - Please do not edit
// Tracks base typescript-fetch mustache 01/02/17
// ===============================================
/**
 * mbed-billing REST API documentation for API-server
 * This document contains the public REST API definitions of the mbed-billing service's API server component.
 *
 * OpenAPI spec version: 1.3.4-SNAPSHOT
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-variable */
/* tslint:disable:no-implicit-any */

import superagent = require('superagent');
import { ApiBase } from "../common/apiBase";

export interface Account {
    "phone_number"?: string;
    "address_line2"?: string;
    "address_line1"?: string;
    "city"?: string;
    "country"?: string;
    "company": string;
    "email"?: string;
    "state"?: string;
    "contact"?: string;
    "postal_code"?: string;
    "id": string;
}

export interface AccountBillingData {
    "bootstrap_count": number;
    "account": string;
    "firmware_update_count": number;
    "transaction_count": number;
    "device_count": number;
}

export interface AccountReport {
    "billing_data": BillingData;
    "account": Account;
    "children": Array<ChildAccountReport>;
    "aggregated": BillingData;
}

export interface ActiveDevice {
    "timestamp": number;
    "device_id": string;
}

export interface BillingData {
    "transactions": number;
    "active_devices": number;
    "generated": string;
    "period_end": string;
    "firmware_updates": number;
    "period_start": string;
    "bootstraps": number;
}

export interface BuildInfo {
    "build-timestamp"?: Date;
    "built-by"?: string;
    "build-number"?: string;
    "build-tag"?: string;
    "build-version"?: string;
}

export interface ChildAccountReport {
    "billing_data": BillingData;
    "account": Account;
}

export interface Health {
    "iam": boolean;
    "psql": boolean;
    "all": boolean;
    "last_updated": Date;
}

export interface ImportLog {
    "import_id": number;
    "bootstrap_count"?: number;
    "from": number;
    "service": string;
    "timestamp": number;
    "transaction_count"?: number;
    "device_count"?: number;
    "to": number;
    "firmware_update_count"?: number;
}

export interface MetricCounter {
    "count": number;
}

export interface MetricGauge {
    "value": number;
}

/**
 * A histogram measures the statistical distribution of values in a stream of data.
 */
export interface MetricHistogram {
    "count": number;
    "p98": number;
    "p75": number;
    "p99": number;
    "min": number;
    "max": number;
    "median": number;
    "p95": number;
    "stddev": number;
    "p999": number;
    "mean": number;
}

export interface MetricHostCounter {
    "count": number;
    "host": string;
}

/**
 * A meter measures the rate of events over time. All measurements are in presented in milliseconds.
 */
export interface MetricMeter {
    "count": number;
    "m1_rate": number;
    "m5_rate": number;
    "m15_rate": number;
    "mean_rate": number;
}

/**
 * A timer measures both the rate and the distribution of particular metric duration. All measurements are in presented in milliseconds.
 */
export interface MetricTimer {
    "p98": number;
    "p99": number;
    "p75": number;
    "mean": number;
    "mean_rate": number;
    "m15_rate": number;
    "min": number;
    "m5_rate": number;
    "p95": number;
    "median": number;
    "stddev": number;
    "max": number;
    "m1_rate": number;
    "s1_rate": number;
    "p999": number;
    "count": number;
}

export interface Metrics {
    "vertx.http.servers.delete-requests": MetricTimer;
    "jvm.mem.pools.PS-Survivor-Space.init": MetricGauge;
    "vertx.pools.worker.vert.x-worker-thread.queue-size": MetricCounter;
    "vertx.http.servers.options-requests": MetricTimer;
    "jvm.mem.non-heap.max": MetricGauge;
    "jvm.mem.heap.used": MetricGauge;
    "jvm.mem.total.max": MetricGauge;
    "persistence.insert.account": MetricTimer;
    "vertx.http.servers.bytes-read": MetricHistogram;
    "vertx.http.clients.iam.bytes-written": MetricHistogram;
    "vertx.http.clients.iam.options-requests": MetricTimer;
    "vertx.http.clients.iam.requests": MetricTimer;
    "persistent-store-ds.pool.Usage": MetricHistogram;
    "vertx.pools.worker.vert.x-internal-blocking.pool-ratio": MetricGauge;
    "persistence.insert.active-devices": MetricTimer;
    "jvm.mem.total.init": MetricGauge;
    "jvm.mem.pools.PS-Old-Gen.committed": MetricGauge;
    "vertx.timers": MetricCounter;
    "vertx.eventbus.messages.sent": MetricMeter;
    "persistence.select.service-update-log": MetricTimer;
    "persistence.select.accounts-statistics-with-accounts": MetricTimer;
    "http.handler.activedevices-in-imports.timer": MetricTimer;
    "persistence.select.healthcheck": MetricTimer;
    "vertx.http.clients.iam.bytes-read": MetricHistogram;
    "persistence.select.initial-accounts": MetricTimer;
    "vertx.eventbus.handlers": MetricCounter;
    "vertx.http.servers.exceptions": MetricCounter;
    "vertx.eventbus.messages.reply-failures": MetricMeter;
    "vertx.http.clients.iam.head-requests": MetricTimer;
    "jvm.mem.pools.PS-Old-Gen.max": MetricGauge;
    "jvm.mem.pools.Compressed-Class-Space.init": MetricGauge;
    "jvm.mem.pools.Code-Cache.usage": MetricGauge;
    "vertx.verticles": MetricCounter;
    "vertx.http.servers.responses-2xx": MetricMeter;
    "persistence.insert.import-log": MetricTimer;
    "vertx.http.servers.patch-requests": MetricTimer;
    "http.handler.service-update-log.timer": MetricTimer;
    "jvm.mem.pools.Metaspace.init": MetricGauge;
    "jvm.gc.PS-MarkSweep.time": MetricGauge;
    "http.handler.time-series.timer": MetricTimer;
    "vertx.http.servers.connections": MetricTimer;
    "vertx.eventbus.messages.sent-local": MetricMeter;
    "vertx.http.clients.iam.other-requests": MetricTimer;
    "vertx.http.clients.iam.responses-5xx": MetricMeter;
    "jvm.mem.pools.PS-Eden-Space.max": MetricGauge;
    "vertx.eventbus.messages.delivered-remote": MetricMeter;
    "vertx.http.clients.iam.connections.pool-ratio": MetricGauge;
    "persistent-store-ds.pool.ConnectionTimeoutRate": MetricMeter;
    "jvm.mem.pools.PS-Survivor-Space.usage": MetricGauge;
    "jvm.mem.total.committed": MetricGauge;
    "jvm.mem.non-heap.used": MetricGauge;
    "persistent-store-ds.pool.Wait": MetricTimer;
    "vertx.worker-pool-size": MetricGauge;
    "vertx.pools.worker.vert.x-internal-blocking.in-use": MetricCounter;
    "vertx.eventbus.messages.published": MetricMeter;
    "vertx.http.servers.get-requests": MetricTimer;
    "vertx.http.clients.iam.open-netsockets": MetricCounter;
    "jvm.mem.non-heap.init": MetricGauge;
    "vertx.http.clients.iam.delete-requests": MetricTimer;
    "jvm.mem.pools.PS-Eden-Space.used": MetricGauge;
    "http.handler.metrics-handler.timer": MetricTimer;
    "persistence.select.import-log-active-devices": MetricTimer;
    "http.handler.activedevices.timer": MetricTimer;
    "vertx.http.clients.iam.open-connections": Array<MetricHostCounter>;
    "jvm.mem.pools.PS-Survivor-Space.used": MetricGauge;
    "vertx.http.clients.iam.responses-1xx": MetricMeter;
    "persistence.insert.dlq": MetricTimer;
    "vertx.eventbus.messages.published-remote": MetricMeter;
    "jvm.mem.pools.PS-Old-Gen.init": MetricGauge;
    "vertx.http.clients.iam.connections": MetricTimer;
    "vertx.eventbus.messages.pending": MetricCounter;
    "vertx.http.servers.connect-requests": MetricTimer;
    "vertx.pools.worker.vert.x-internal-blocking.queue-size": MetricCounter;
    "http.handler.build-info.timer": MetricTimer;
    "jvm.mem.pools.PS-Eden-Space.usage": MetricGauge;
    "vertx.eventbus.messages.published-local": MetricMeter;
    "persistence.select.accounts-statistics-all": MetricTimer;
    "persistence.select.accounts-statistics-with-account": MetricTimer;
    "jvm.gc.PS-Scavenge.time": MetricGauge;
    "vertx.http.clients.iam.exceptions": MetricCounter;
    "jvm.mem.pools.PS-Old-Gen.usage": MetricGauge;
    "vertx.http.servers.post-requests": MetricTimer;
    "jvm.mem.pools.PS-Old-Gen.used-after-gc": MetricGauge;
    "vertx.eventbus.messages.sent-remote": MetricMeter;
    "persistence.select.accounts": MetricTimer;
    "vertx.eventbus.messages.pending-remote": MetricCounter;
    "vertx.eventbus.messages.received-local": MetricMeter;
    "jvm.mem.pools.Code-Cache.max": MetricGauge;
    "vertx.pools.worker.vert.x-internal-blocking.max-pool-size": MetricGauge;
    "persistence.operation.store": MetricTimer;
    "http.handler.health-check.timer": MetricTimer;
    "vertx.http.clients.iam.connect-requests": MetricTimer;
    "vertx.http.servers.trace-requests": MetricTimer;
    "jvm.mem.non-heap.usage": MetricGauge;
    "vertx.http.servers.put-requests": MetricTimer;
    "jvm.mem.total.used": MetricGauge;
    "jvm.mem.pools.Code-Cache.committed": MetricGauge;
    "http.handler.account-stats.without-account": MetricTimer;
    "vertx.eventbus.messages.delivered-local": MetricMeter;
    "jvm.mem.pools.PS-Eden-Space.used-after-gc": MetricGauge;
    "jvm.mem.pools.Compressed-Class-Space.used": MetricGauge;
    "vertx.pools.worker.vert.x-worker-thread.queue-delay": MetricTimer;
    "vertx.pools.worker.vert.x-internal-blocking.queue-delay": MetricTimer;
    "http.handler.account-stats.with-account": MetricTimer;
    "jvm.mem.pools.Compressed-Class-Space.max": MetricGauge;
    "http.handler.account-list.timer": MetricTimer;
    "persistent-store-ds.pool.TotalConnections": MetricGauge;
    "jvm.mem.pools.PS-Survivor-Space.committed": MetricGauge;
    "vertx.http.servers.responses-5xx": MetricMeter;
    "jvm.mem.pools.Code-Cache.init": MetricGauge;
    "http.handler.report.json": MetricTimer;
    "vertx.http.servers.responses-4xx": MetricMeter;
    "vertx.pools.worker.vert.x-worker-thread.usage": MetricTimer;
    "jvm.mem.heap.init": MetricGauge;
    "jvm.mem.heap.max": MetricGauge;
    "vertx.http.servers.responses-1xx": MetricMeter;
    "vertx.http.clients.iam.post-requests": MetricTimer;
    "vertx.http.servers.open-websockets": MetricCounter;
    "vertx.http.servers.other-requests": MetricTimer;
    "vertx.pools.worker.vert.x-worker-thread.in-use": MetricCounter;
    "jvm.mem.heap.usage": MetricGauge;
    "jvm.mem.non-heap.committed": MetricGauge;
    "jvm.mem.pools.Compressed-Class-Space.usage": MetricGauge;
    "persistent-store-ds.pool.ConnectionCreation": MetricHistogram;
    "vertx.http.clients.iam.open-websockets": MetricCounter;
    "persistence.select.import-log": MetricTimer;
    "persistence.select.accounts-statistics-with-accounts-and-starttime": MetricTimer;
    "persistence.operation.dlq": MetricTimer;
    "jvm.gc.PS-Scavenge.count": MetricGauge;
    "vertx.http.clients.iam.connections.max-pool-size": MetricGauge;
    "vertx.eventbus.messages.bytes-written": MetricMeter;
    "jvm.mem.pools.Compressed-Class-Space.committed": MetricGauge;
    "vertx.verticles.com.mbed.billing.server.apiserver.http.HttpServer": MetricCounter;
    "jvm.mem.pools.Code-Cache.used": MetricGauge;
    "http.handler.import-log.timer": MetricTimer;
    "vertx.eventbus.messages.pending-local": MetricCounter;
    "vertx.http.servers.bytes-written": MetricHistogram;
    "vertx.eventbus.messages.bytes-read": MetricMeter;
    "vertx.http.servers.head-requests": MetricTimer;
    "jvm.mem.pools.PS-Survivor-Space.used-after-gc": MetricGauge;
    "persistent-store-ds.pool.ActiveConnections": MetricGauge;
    "persistence.connection.connect": MetricTimer;
    "jvm.mem.pools.PS-Eden-Space.init": MetricGauge;
    "vertx.http.clients.iam.responses-2xx": MetricMeter;
    "persistence.insert.account-statistics": MetricTimer;
    "jvm.mem.pools.Metaspace.used": MetricGauge;
    "jvm.mem.pools.Metaspace.max": MetricGauge;
    "http.handler.report.zip": MetricTimer;
    "vertx.event-loop-size": MetricGauge;
    "vertx.http.servers.open-connections": Array<MetricHostCounter>;
    "vertx.http.clients.iam.responses-3xx": MetricMeter;
    "jvm.mem.pools.PS-Eden-Space.committed": MetricGauge;
    "vertx.http.servers.responses-3xx": MetricMeter;
    "vertx.http.clients.iam.get-requests": MetricTimer;
    "jvm.mem.heap.committed": MetricGauge;
    "vertx.http.servers.open-netsockets": MetricCounter;
    "vertx.http.servers.requests": MetricTimer;
    "persistent-store-ds.pool.PendingConnections": MetricGauge;
    "jvm.mem.pools.PS-Old-Gen.used": MetricGauge;
    "jvm.mem.pools.Metaspace.usage": MetricGauge;
    "persistence.select.time-series": MetricTimer;
    "jvm.mem.pools.Metaspace.committed": MetricGauge;
    "vertx.eventbus.messages.delivered": MetricMeter;
    "vertx.http.clients.iam.patch-requests": MetricTimer;
    "vertx.eventbus.messages.received-remote": MetricMeter;
    "vertx.http.clients.iam.responses-4xx": MetricMeter;
    "vertx.pools.worker.vert.x-worker-thread.pool-ratio": MetricGauge;
    "vertx.http.clients.iam.trace-requests": MetricTimer;
    "vertx.pools.worker.vert.x-worker-thread.max-pool-size": MetricGauge;
    "vertx.pools.worker.vert.x-internal-blocking.usage": MetricTimer;
    "persistence.select.check-if-exists": MetricTimer;
    "vertx.eventbus.messages.received": MetricMeter;
    "jvm.gc.PS-MarkSweep.count": MetricGauge;
    "jvm.mem.pools.PS-Survivor-Space.max": MetricGauge;
    "persistent-store-ds.pool.IdleConnections": MetricGauge;
    "vertx.http.clients.iam.put-requests": MetricTimer;
}

export interface Report {
    "account_reports": Array<AccountReport>;
    "month": string;
}

export interface Service {
    "timestamp": number;
    "service": string;
}

export interface ServiceTimeSeries {
    "time_series": Array<TimeSeries>;
    "service": string;
}

export interface TimeSeries {
    "to": number;
    "from": number;
}

/**
 * DefaultApi
 */
export class DefaultApi extends ApiBase {

    /** 
     * Build information
     * Get a full build information of the running system.
     */
    publicV1BuildGet (callback?: (error:any, data?:BuildInfo, response?: superagent.Response) => any): superagent.SuperAgentRequest {

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request({
            url: '/public/v1/build',
            method: 'GET',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /** 
     * Service health
     * Check current service health
     */
    publicV1HealthGet (callback?: (error:any, data?:Health, response?: superagent.Response) => any): superagent.SuperAgentRequest {

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request({
            url: '/public/v1/health',
            method: 'GET',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /** 
     * List of accounts
     * Get a list of all accounts.
     */
    v1AccountsGet (callback?: (error:any, data?:Array<string>, response?: superagent.Response) => any): superagent.SuperAgentRequest {

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request({
            url: '/v1/accounts',
            method: 'GET',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /** 
     * Active devices per account
     * Get active devices for an account with specified from and to timestamp
     * @param account account id
     * @param from in epoch millis, inclusive
     * @param to in epoch millis, exclusive
     */
    v1ActivedevicesGet (account: string, from: number, to: number, callback?: (error:any, data?:Array<ActiveDevice>, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "account" is set
        if (account === null || account === undefined) {
            if (callback) {
                callback(new Error("Required parameter 'account' missing when calling 'v1ActivedevicesGet'."));
            }
            return;
        }
        // verify required parameter "from" is set
        if (from === null || from === undefined) {
            if (callback) {
                callback(new Error("Required parameter 'from' missing when calling 'v1ActivedevicesGet'."));
            }
            return;
        }
        // verify required parameter "to" is set
        if (to === null || to === undefined) {
            if (callback) {
                callback(new Error("Required parameter 'to' missing when calling 'v1ActivedevicesGet'."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};
        if (account !== undefined) {
            queryParameters['account'] = account;
        }
        if (from !== undefined) {
            queryParameters['from'] = from;
        }
        if (to !== undefined) {
            queryParameters['to'] = to;
        }

        let useFormData = false;
        let formParams: any = {};

        return this.request({
            url: '/v1/activedevices',
            method: 'GET',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /** 
     * Active devices
     * Get active devices for an account in import log
     * @param account account id
     * @param importId import id
     */
    v1ImportsActivedevicesGet (account: string, importId: number, callback?: (error:any, data?:Array<string>, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "account" is set
        if (account === null || account === undefined) {
            if (callback) {
                callback(new Error("Required parameter 'account' missing when calling 'v1ImportsActivedevicesGet'."));
            }
            return;
        }
        // verify required parameter "importId" is set
        if (importId === null || importId === undefined) {
            if (callback) {
                callback(new Error("Required parameter 'importId' missing when calling 'v1ImportsActivedevicesGet'."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};
        if (account !== undefined) {
            queryParameters['account'] = account;
        }
        if (importId !== undefined) {
            queryParameters['import_id'] = importId;
        }

        let useFormData = false;
        let formParams: any = {};

        return this.request({
            url: '/v1/imports/activedevices',
            method: 'GET',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /** 
     * Import log
     * Get full import log for a single account.
     * @param account account id
     */
    v1ImportsGet (account: string, callback?: (error:any, data?:Array<ImportLog>, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "account" is set
        if (account === null || account === undefined) {
            if (callback) {
                callback(new Error("Required parameter 'account' missing when calling 'v1ImportsGet'."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};
        if (account !== undefined) {
            queryParameters['account'] = account;
        }

        let useFormData = false;
        let formParams: any = {};

        return this.request({
            url: '/v1/imports',
            method: 'GET',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /** 
     * System metrics
     * Get various internal metrics of the service.
     */
    v1MetricsGet (callback?: (error:any, data?:Metrics, response?: superagent.Response) => any): superagent.SuperAgentRequest {

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request({
            url: '/v1/metrics',
            method: 'GET',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /** 
     * Billing report
     * Generate billing report for all accounts.
     * @param month year and month
     * @param format report format
     */
    v1ReportGet (month: string, format?: string, callback?: (error:any, data?:Report, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "month" is set
        if (month === null || month === undefined) {
            if (callback) {
                callback(new Error("Required parameter 'month' missing when calling 'v1ReportGet'."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};
        if (month !== undefined) {
            queryParameters['month'] = month;
        }
        if (format !== undefined) {
            queryParameters['format'] = format;
        }

        let useFormData = false;
        let formParams: any = {};

        return this.request({
            url: '/v1/report',
            method: 'GET',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /** 
     * Known services
     * Get a full list of known services and when they have last updated data to the system.
     */
    v1ServicesGet (callback?: (error:any, data?:Array<Service>, response?: superagent.Response) => any): superagent.SuperAgentRequest {

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request({
            url: '/v1/services',
            method: 'GET',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /** 
     * Account billing data
     * Get account billing data for one or multiple accounts for a given month.
     * @param month year and month
     * @param account account id
     */
    v1StatsGet (month: string, account?: string, callback?: (error:any, data?:Array<AccountBillingData>, response?: superagent.Response) => any): superagent.SuperAgentRequest {
        // verify required parameter "month" is set
        if (month === null || month === undefined) {
            if (callback) {
                callback(new Error("Required parameter 'month' missing when calling 'v1StatsGet'."));
            }
            return;
        }

        let headerParams: any = {};

        let queryParameters: any = {};
        if (month !== undefined) {
            queryParameters['month'] = month;
        }
        if (account !== undefined) {
            queryParameters['account'] = account;
        }

        let useFormData = false;
        let formParams: any = {};

        return this.request({
            url: '/v1/stats',
            method: 'GET',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
    /** 
     * Known time series
     * Get a full list of consecutive known time series grouped by service and timestamp.
     */
    v1TimeseriesGet (callback?: (error:any, data?:Array<ServiceTimeSeries>, response?: superagent.Response) => any): superagent.SuperAgentRequest {

        let headerParams: any = {};

        let queryParameters: any = {};

        let useFormData = false;
        let formParams: any = {};

        return this.request({
            url: '/v1/timeseries',
            method: 'GET',
            headers: headerParams,
            query: queryParameters,
            useFormData: useFormData,
            formParams: formParams,
            json: true,
        }, callback);
    }
}

