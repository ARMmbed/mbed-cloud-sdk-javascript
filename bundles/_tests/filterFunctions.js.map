{"version":3,"sources":["_tests/filterFunctions.ts"],"names":["Object","defineProperty","exports","value","_a","intern","getInterface","suite","test","assert","getPlugin","functions_1","require","result","extractFilter","strictEqual","filter","$eq","encodeFilter","key","error","$ne","range","$lte","$gte","theRange","custom_1","custom_2","decodeFilter","deepEqual"],"mappings":"ycAAA;;;;;;;;;;;;;;;;AAiBMA,OAAAC,eAAAC,EAAA,cAAEC,OAAK,GACL,IAAAC,GAAAC,OAAAC,aAAA,OAAAC,EAAoCH,EAAAG,MAAAC,EAAAJ,EAAAI,KAE5CC,EAAAJ,OAAAK,UAAA,QAAAD,OAEAE,EAAMC,EAAiB,yBAEnB,gBAAK,aACD,wBAA0B,WAC1B,GACAC,GAAOF,EAAkBG,cAAU,KAAA,KADpB,WAEhBL,GAAAM,YAAAF,EAFgB,gBAKf,yBAAuB,WACvB,GACIG,IACFA,QAAAC,IAFU,WAKZJ,EAAOF,EAAkBG,cAASE,EAAA,SACnCP,GAAAM,YAAAF,EANa,cASZ,4BAAuB,WACvB,GACIG,IACFA,OAFU,UAKZH,EAAOF,EAAkBG,cAASE,EAAA,SACnCP,GAAAM,YAAAF,EANa,gBAWhB,eAAK,aACD,sBAAe,WACf,GAAAA,GAAOF,EAAkBO,aAAM,KAChCT,GAAAM,YAAAF,EAAA,QAGC,4BAAe,WACf,GAAAA,GAAOF,EAAkBO,gBAC1BT,GAAAM,YAAAF,EAAA,QAGC,uBAAe,cACXA,GAAOF,EAAcO,cACrBC,KAAOF,IAAK,SACZG,OAASC,IAAI,SACdC,OAAAC,KAAA,GAAAC,KAAA,IAEJf,GAAAM,YAAAF,EAAA,6DAGC,6BAAe,cACXA,GAAOF,EAAcO,cACrBC,KAAOF,IAAK,SACZG,OAAQC,IAAI,SACbI,UAAAF,KAAA,GAAAC,KAAA,IAEJf,GAAAM,YAAAF,EAAA,qEAGC,4BAAe,cACXA,GAAKF,EAAOO,cACZC,IAAK,QACLC,OAASC,IAAI,SACdC,OAAAC,KAAA,GAAAC,KAAA,IAEJf,GAAAM,YAAAF,EAAA,6DAGC,gCAAe,cACXA,GAAOF,EAAcO,cACrBC,KAAOF,IAAK,SACZG,OAASC,IAAI,SACdC,OAAAC,KAAA,GAAAC,KAAA,WAGE,WAGA,WAGNf,GAAAM,YAAAF,EAAA,gEAGC,iCAAe,cACXA,GAAOF,EAAcO,cACrBC,KAAOF,IAAK,SACZG,OAASC,IAAI,SACbC,OAAQC,KAAA,GAAAC,KAAA,WAEJE,UAAYT,IAAK,kBACpBU,UAAAN,IAAA,2BAIA,WAGA,YAGF,UAEJZ,GAAAM,YAAAF,EAAA,uIAKH,eAAK,aACD,uBAAe,WACf,GAAAA,GAAOF,EAAkBiB,aAAI,KAC9BnB,GAAAoB,UAAAhB,UAGC,uBAAe,WACf,GAAAA,GAAOF,EAAkBiB,aAAA,2DAClBC,UAAShB,GACZM,KAAOF,IAAK,SACZG,OAASC,IAAI,SACdC,OAAAC,KAAA,KAAAC,KAAA,WAIH,6BAAe,WACf,GAAAX,GAAOF,EAAkBiB,aAAA,mEAClBC,UAAShB,GACZM,KAAOF,IAAK,SACZG,OAAQC,IAAI,SACbI,UAAAF,KAAA,KAAAC,KAAA,WAIH,yBAAe,cACXX,GAAMF,EAAAiB,aAAA,kEAEL,WAGA,cAGEC,UAAShB,GACZM,KAAOF,IAAK,SACZG,OAASC,IAAI,SACdC,OAAAC,KAAA,KAAAC,KAAA,WAIH,0BAAe,cACXX,GAAMF,EAAAiB,aAAA,uIAEL,WAGA,YAGF,aAEIC,UAAShB,GACZM,KAAOF,IAAK,SACZG,OAASC,IAAI,SACbC,OAAQC,KAAA,KAAAC,KAAA,aAEJE,UAAYT,IAAK,kBACpBU,UAAAN,IAAA","file":"filterFunctions.js","sourcesContent":["/*\n* Mbed Cloud JavaScript SDK\n* Copyright Arm Limited 2017\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nconst { suite, test } = intern.getInterface(\"tdd\");\nconst { assert } = intern.getPlugin(\"chai\");\n\nimport { extractFilter, encodeFilter, decodeFilter } from \"../common/functions\";\n\nsuite(\"extractFilter\", () => {\n\n    test(\"should return default\", () => {\n        const string = \"dee folt\";\n        const result = extractFilter(null, null, string);\n        assert.strictEqual(result, string);\n    });\n\n    test(\"should extract from eq\", () => {\n        const value = \"coffee\";\n        const filter = {\n            filter: { $eq: value }\n        };\n\n        const result = extractFilter(filter, \"filter\");\n        assert.strictEqual(result, value);\n    });\n\n    test(\"should extract without eq\", () => {\n        const value = \"coffee\";\n        const filter = {\n            filter: value\n        };\n\n        const result = extractFilter(filter, \"filter\");\n        assert.strictEqual(result, value);\n    });\n});\n\nsuite(\"encodeFilter\", () => {\n\n    test(\"should return empty\", () => {\n        const result = encodeFilter(null);\n        assert.strictEqual(result, \"\");\n    });\n\n    test(\"should still return empty\", () => {\n        const result = encodeFilter({});\n        assert.strictEqual(result, \"\");\n    });\n\n    test(\"should encode filter\", () => {\n        const result = encodeFilter({\n            key: { $eq: \"value\" },\n            error: { $ne: \"found\" },\n            range: { $lte: 10, $gte: 2 }\n        });\n        assert.strictEqual(result, \"key=value&error__neq=found&range__lte=10&range__gte=2\");\n    });\n\n    test(\"should encode camel filter\", () => {\n        const result = encodeFilter({\n            key: { $eq: \"value\" },\n            error: { $ne: \"found\" },\n            theRange: { $lte: 10, $gte: 2 }\n        });\n        assert.strictEqual(result, \"key=value&error__neq=found&the_range__lte=10&the_range__gte=2\");\n    });\n\n    test(\"should encode bare filter\", () => {\n        const result = encodeFilter({\n            key: \"value\",\n            error: { $ne: \"found\" },\n            range: { $lte: 10, $gte: 2 }\n        });\n        assert.strictEqual(result, \"key=value&error__neq=found&range__lte=10&range__gte=2\");\n    });\n\n    test(\"should encode filter with map\", () => {\n        const result = encodeFilter({\n            key: { $eq: \"value\" },\n            error: { $ne: \"found\" },\n            range: { $lte: 10, $gte: 2 }\n        }, {\n            from: [\n                \"key\"\n            ],\n            to: [\n                \"switch\"\n            ]\n        });\n        assert.strictEqual(result, \"switch=value&error__neq=found&range__lte=10&range__gte=2\");\n    });\n\n    test(\"should encode filter with nest\", () => {\n        const result = encodeFilter({\n            key: { $eq: \"value\" },\n            error: { $ne: \"found\" },\n            range: { $lte: 10, $gte: 2 },\n            custom: {\n                custom_1: { $eq: \"custom_value_1\" },\n                custom_2: { $ne: \"custom_value_2\" }\n            }\n        }, {\n            from: [\n                \"key\"\n            ],\n            to: [\n                \"switch\"\n            ]\n        }, [\n            \"custom\"\n        ]);\n        assert.strictEqual(result, \"switch=value&error__neq=found&range__lte=10&range__gte=2&custom__custom_1=custom_value_1&custom__custom_2__neq=custom_value_2\");\n    });\n});\n\nsuite(\"decodeFilter\", () => {\n\n    test(\"should return object\", () => {\n        const result = decodeFilter(null);\n        assert.deepEqual(result, {});\n    });\n\n    test(\"should decode string\", () => {\n        const result = decodeFilter(\"key=value&error__neq=found&range__lte=10&range__gte=2\");\n        assert.deepEqual(result, {\n            key: { $eq: \"value\" },\n            error: { $ne: \"found\" },\n            range: { $lte: \"10\", $gte: \"2\" }\n        });\n    });\n\n    test(\"should decode snake string\", () => {\n        const result = decodeFilter(\"key=value&error__neq=found&the_range__lte=10&the_range__gte=2\");\n        assert.deepEqual(result, {\n            key: { $eq: \"value\" },\n            error: { $ne: \"found\" },\n            theRange: { $lte: \"10\", $gte: \"2\" }\n        });\n    });\n\n    test(\"should decode with map\", () => {\n        const result = decodeFilter(\"switch=value&error__neq=found&range__lte=10&range__gte=2\", {\n            from: [\n                \"key\"\n            ],\n            to: [\n                \"switch\"\n            ]\n        });\n        assert.deepEqual(result, {\n            key: { $eq: \"value\" },\n            error: { $ne: \"found\" },\n            range: { $lte: \"10\", $gte: \"2\" }\n        });\n    });\n\n    test(\"should decode with nest\", () => {\n        const result = decodeFilter(\"switch=value&error__neq=found&range__lte=10&range__gte=2&custom__custom_1=custom_value_1&custom__custom_2__neq=custom_value_2\", {\n            from: [\n                \"key\"\n            ],\n            to: [\n                \"switch\"\n            ]\n        }, [\n            \"custom\"\n        ]);\n        assert.deepEqual(result, {\n            key: { $eq: \"value\" },\n            error: { $ne: \"found\" },\n            range: { $lte: \"10\", $gte: \"2\" },\n            custom: {\n                custom_1: { $eq: \"custom_value_1\" },\n                custom_2: { $ne: \"custom_value_2\" }\n            }\n        });\n    });\n});\n"]}