{"version":3,"sources":["_tests/connectEvents.ts"],"names":["defineProperty","exports","value","sdkError_1","require","DefaultApi","_super","apply","this","arguments","__extends","prototype","deviceCreate","device","callback","undefined","SDKError","headerParams","queryParameters","formParams","request","url","method","headers","query","useFormData","json","body","deviceDestroy","id","replace","String","deviceEventList","limit","order","after","filter","include","deviceEventRetrieve","deviceEventId","deviceList","deviceLogList"],"mappings":"ycAAA,2VAeEA,eAAAC,EAAA,cAAAC,OAAA,iCAEIC,EAAAC,EAAA,sBAOFC,EAAoB,SAAAC,WAGbD,WACc,QAAbC,GAAaA,EAAAC,MAAAC,KAAAC,YAAAD,WAFrBE,GAAUL,EAACC,KAWHK,UAAOC,aAAqB,SAAEC,EAAaC,GAE/C,GAAG,OAAAD,OAAAE,KAAAF,EAIC,YAHGC,GACHA,EAAa,GAACX,GAAAa,SAAA,yCAIlB,IAAGC,MACCC,KAGAC,WACAX,MAAOY,SACRC,IAAA,eAECC,OAAO,OACPC,QAAAN,EACDO,MAAAN,EACJO,aARI,EAUFN,WAAAA,EAEKO,MAAM,EAERC,KAAGd,SAOAF,UAAAiB,cAAW,SAAAC,EAAAf,GAElB,GAAG,OAAAe,OAAAd,KAAAc,EAIC,YAHGf,GACHA,EAAa,GAACX,GAAAa,SAAA,qCAIlB,IAAGC,MAECC,KAGLC,IAEC,OAACX,MAAAY,SAEKC,IAAG,oBAAmBS,QAAA,OAAAC,OAAAF,IAExBP,OAAG,SACHC,QAAON,EACRO,MAAAN,EACCO,aAVD,EAWCN,WAAYA,EACbO,MAAA,GACAZ,MAWCH,UAAOqB,gBAAA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAvB,MACPG,MACDC,SACJH,KAAAkB,IAEEf,EAAA,MAA6Be,OAIvBlB,KAAHmB,IACAhB,EAAc,MAAAgB,OAEXnB,KAAHoB,IACAjB,EAAc,MAAAiB,OAEXpB,KAAHqB,IACAlB,EAAc,OAAAkB,OAEXrB,KAAHsB,IACAnB,EAAuB,QAAAmB,EAG3B,IACIlB,KACJ,OAAGX,MAAAY,SAECC,IAAA,qBACAC,OAAA,MACDC,QAAAN,EACJO,MAAAN,EAEEO,aATM,EAWDN,WAAUA,EAEZO,MAAG,SAOHf,UAAa2B,oBAAC,SAAAC,EAAAzB,GAElB,GAAO,OAAHyB,OAAcxB,KAADwB,EAIb,YAHAzB,GACDA,EAAA,GAAAX,GAAAa,SAAA,gDAIH,IAAGC,MAECC,KAGLC,IAEC,OAACX,MAAAY,SAEKC,IAAA,uCAAgBS,QAAA,oBAAAC,OAAAQ,IAClBjB,OAAA,MACAC,QAAAN,EACAO,MAAAN,EACAO,aATD,EAUCN,WAAAA,EACFO,MAAA,GAEFZ,MAWGH,UAAA6B,WAAA,SAAAP,EAAAC,EAAAC,EAAAC,EAAAC,EAAAvB,GACH,GAAIG,MACAC,SACDH,KAAAkB,IACCf,EAAG,MAAWe,OAEflB,KAAAmB,IAEChB,EAAsB,MAAAgB,OAE/BnB,KAAAoB,IAEGjB,EAAiB,MAAAiB,OAIHpB,KAAhBqB,IACQlB,EAAgB,OAAWkB,OACpBrB,KAAXsB,IACHnB,EAAA,QAAAmB,MAKMlB,KACJ,OAAAX,MAAAY,SAEEC,IAAA,eAEKC,OAAM,MACNC,QAAQN,EACRO,MAAAN,EACAO,aATW,EAUXN,WAAYA,EAElBO,MAAU,mBAaHe,cAAA,SAAAR,EAAAC,EAAAC,EAAAC,EAAAC,EAAAvB,MACJG,MACJC,SAEEH,KAAAkB,IAEKf,EAAsB,MAAAe,OAEZlB,KAAVmB,IACAhB,EAAc,MAAAgB,OAGTnB,KAAPoB,IACAjB,EAAc,MAAAiB,OAGlBpB,KAAAqB,IACIlB,EAAwB,OAAAkB,OAGxBrB,KAAAsB,MACe,QAAAA,MAIpBlB,KACJ,OAAAX,MAAAY,0EAFQ","file":"connectEvents.js","sourcesContent":["/*\n* Mbed Cloud JavaScript SDK\n* Copyright Arm Limited 2017\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nconst { suite, test, beforeEach } = intern.getInterface(\"tdd\");\nconst { assert } = intern.getPlugin(\"chai\");\n\nimport { ConnectApi } from \"../connect/connectApi\";\n\nsuite(\"connectEvents\", () => {\n\n    let api: ConnectApi;\n\n    beforeEach(() => {\n        api = new ConnectApi({\n            apiKey: \"key\"\n        });\n    });\n\n    test(\"should emit notification\", ctx => {\n\n        const dfd = ctx.async(1000);\n\n        api.on(ConnectApi.EVENT_NOTIFICATION, device => {\n            assert.strictEqual(device.id, \"device-id\");\n            dfd.resolve();\n        });\n        api.on(ConnectApi.EVENT_REGISTRATION, () => {\n            assert(false);\n        });\n        api.on(ConnectApi.EVENT_REREGISTRATION, () => {\n            assert(false);\n        });\n        api.on(ConnectApi.EVENT_DEREGISTRATION, () => {\n            assert(false);\n        });\n        api.on(ConnectApi.EVENT_EXPIRED, () => {\n            assert(false);\n        });\n\n        api.notify({\n            notifications: [ { ep: \"device-id\" } ]\n        });\n    });\n\n    test(\"should emit registration\", ctx => {\n\n        const dfd = ctx.async(1000);\n\n        api.on(ConnectApi.EVENT_NOTIFICATION, () => {\n            assert(false);\n        });\n        api.on(ConnectApi.EVENT_REGISTRATION, device => {\n            assert.strictEqual(device.id, \"device-id\");\n            dfd.resolve();\n        });\n        api.on(ConnectApi.EVENT_REREGISTRATION, () => {\n            assert(false);\n        });\n        api.on(ConnectApi.EVENT_DEREGISTRATION, () => {\n            assert(false);\n        });\n        api.on(ConnectApi.EVENT_EXPIRED, () => {\n            assert(false);\n        });\n\n        api.notify({\n            registrations: [ { ep: \"device-id\" } ]\n        });\n    });\n\n    test(\"should emit re-registration\", ctx => {\n\n        const dfd = ctx.async(1000);\n\n        api.on(ConnectApi.EVENT_NOTIFICATION, () => {\n            assert(false);\n        });\n        api.on(ConnectApi.EVENT_REGISTRATION, () => {\n            assert(false);\n        });\n        api.on(ConnectApi.EVENT_REREGISTRATION, device => {\n            assert.strictEqual(device.id, \"device-id\");\n            dfd.resolve();\n        });\n        api.on(ConnectApi.EVENT_DEREGISTRATION, () => {\n            assert(false);\n        });\n        api.on(ConnectApi.EVENT_EXPIRED, () => {\n            assert(false);\n        });\n\n        api.notify({\n            \"reg-updates\": [ { ep: \"device-id\" } ]\n        });\n    });\n\n    test(\"should emit de-registration\", ctx => {\n\n        const dfd = ctx.async(1000);\n\n        api.on(ConnectApi.EVENT_NOTIFICATION, () => {\n            assert(false);\n        });\n        api.on(ConnectApi.EVENT_REGISTRATION, () => {\n            assert(false);\n        });\n        api.on(ConnectApi.EVENT_REREGISTRATION, () => {\n            assert(false);\n        });\n        api.on(ConnectApi.EVENT_DEREGISTRATION, id => {\n            assert.strictEqual(id, \"device-id\");\n            dfd.resolve();\n        });\n        api.on(ConnectApi.EVENT_EXPIRED, () => {\n            assert(false);\n        });\n\n        api.notify({\n            \"de-registrations\": [ \"device-id\" ]\n        });\n    });\n\n    test(\"should emit expired\", ctx => {\n\n        const dfd = ctx.async(1000);\n\n        api.on(ConnectApi.EVENT_NOTIFICATION, () => {\n            assert(false);\n        });\n        api.on(ConnectApi.EVENT_REGISTRATION, () => {\n            assert(false);\n        });\n        api.on(ConnectApi.EVENT_REREGISTRATION, () => {\n            assert(false);\n        });\n        api.on(ConnectApi.EVENT_DEREGISTRATION, () => {\n            assert(false);\n        });\n        api.on(ConnectApi.EVENT_EXPIRED, id => {\n            assert.strictEqual(id, \"device-id\");\n            dfd.resolve();\n        });\n\n        api.notify({\n            \"registrations-expired\": [ \"device-id\" ]\n        });\n    });\n\n    test(\"should emit multiple\", ctx => {\n\n        const notifications = {\n            \"notifications\": [ \"1\", \"2\" ],\n            \"registrations\": [ \"1\", \"2\" ],\n            \"reg-updates\": [ \"1\", \"2\" ],\n            \"de-registrations\": [ \"1\", \"2\" ],\n            \"registrations-expired\": [ \"1\", \"2\" ]\n        };\n\n        const notificationCount = Object.keys(notifications).length * 2;\n        const dfd = ctx.async(1000, notificationCount);\n\n        api.on(ConnectApi.EVENT_NOTIFICATION, () => {\n            dfd.resolve();\n        });\n        api.on(ConnectApi.EVENT_REGISTRATION, () => {\n            dfd.resolve();\n        });\n        api.on(ConnectApi.EVENT_REREGISTRATION, () => {\n            dfd.resolve();\n        });\n        api.on(ConnectApi.EVENT_DEREGISTRATION, () => {\n            dfd.resolve();\n        });\n        api.on(ConnectApi.EVENT_EXPIRED, () => {\n            dfd.resolve();\n        });\n\n        api.notify(notifications);\n    });\n});\n\nsuite(\"notifications\", () => {\n\n    let api: ConnectApi;\n\n    function encode(payload) {\n        if (typeof btoa === \"function\") return btoa(payload);\n        return new Buffer(payload).toString(\"base64\");\n    }\n\n    beforeEach(() => {\n        api = new ConnectApi({\n            apiKey: \"key\"\n        });\n    });\n\n    test(\"should notify\", ctx => {\n\n        const dfd = ctx.async(1000);\n        const deviceId = \"device-id\";\n        const devicePath = \"test\";\n        const payload = \"test-payload\";\n        const notifyFns = {};\n\n        notifyFns[`${deviceId}${devicePath}`] = value => {\n            assert.strictEqual(value, payload);\n            dfd.resolve();\n        };\n\n        // tslint:disable-next-line:no-string-literal\n        api[\"_notifyFns\"] = notifyFns;\n\n        api.notify({\n            notifications: [ {\n                ep: deviceId,\n                path: devicePath,\n                payload: encode(payload)\n            } ]\n        });\n    });\n\n    test(\"should respond to async\", ctx => {\n\n        const dfd = ctx.async(1000);\n        const asyncId = \"async-id\";\n        const payload = \"test-payload\";\n        const asyncFns = {};\n\n        asyncFns[asyncId] = (_error, value) => {\n            assert.strictEqual(value, payload);\n            dfd.resolve();\n        };\n\n        // tslint:disable-next-line:no-string-literal\n        api[\"_asyncFns\"] = asyncFns;\n\n        api.notify({\n            \"async-responses\": [ {\n                id: asyncId,\n                payload: encode(payload)\n            } ]\n        });\n    });\n});\n"]}