{"version":3,"sources":["../../src/_tests/pagination.ts"],"names":["Object","defineProperty","exports","value","pagination_1","require","_a","intern","getInterface","suite","test","assert","getPlugin","wait","Promise","resolve","setTimeout","mockAsync","calls","mock","call","reject","promise","resolvePromise","rejectPromise","push","checkPromise","tracker","resolved","rejected","then","executeCalls","execute","_b","getPageCalls","getPage","executeForAll","strictEqual","length","data","hasMore","id","all","map"],"mappings":"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","file":"pagination.js","sourcesContent":["/*\n * Mbed Cloud JavaScript SDK\n * Copyright Arm Limited 2018\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { executeForAll } from \"../common/pagination\";\nimport { ListResponse } from \"../common/listResponse\";\n\nconst { suite, test } = intern.getInterface(\"tdd\");\nconst { assert } = intern.getPlugin(\"chai\");\n\ninterface Call<O> {\n    resolve: (o: O) => Promise<void>;\n    reject: () => Promise<void>;\n    promise: Promise<O>;\n}\n\n// Wait for the stack to clear. Required because callbacks assigned with Promise.then are called asynchronously.\nconst wait = (): Promise<void> => {\n    return new Promise(resolve => {\n        setTimeout(resolve, 1);\n    });\n};\n\n// Mock a function that returns a promise. Calls to the function are tracked in the `calls` array allowing the returned promises to be resolved and rejected.\nconst mockAsync = <I, O>(): { calls: Array<Call<O>>, mock: (i: I) => Promise<O> } => {\n    const calls: Array<Call<O>> = [];\n\n    const mock = (): Promise<O> => {\n        const call: Call<O> = { resolve: null, reject: null, promise: null };\n\n        call.promise = new Promise<O>((resolvePromise, rejectPromise) => {\n            call.resolve = value => {\n                resolvePromise(value);\n                return wait();\n            };\n\n            call.reject = () => {\n                rejectPromise();\n                return wait();\n            };\n        });\n\n        calls.push(call);\n        return call.promise;\n    };\n\n    return { calls, mock };\n};\n\n// Utility to track if a promise has been rejected or resolved. The return value is mutated asynchronously.\nconst checkPromise = <T>(promise: Promise<T>): { resolved: boolean, rejected: boolean } => {\n    const tracker = { resolved: false, rejected: false };\n    promise.then(() => { tracker.resolved = true; }, () => { tracker.rejected = true; });\n    return tracker;\n};\n\nsuite(\"executeForAll\", () => {\n    test(\"never runs execute if there are no items\", () => {\n        const { calls: executeCalls, mock: execute } = mockAsync<string, void>();\n        const { calls: getPageCalls, mock: getPage } = mockAsync<{ after: string }, ListResponse<{ id: string }>>();\n\n        const tracker = checkPromise(executeForAll(getPage, execute));\n\n        assert.strictEqual(getPageCalls.length, 1);\n\n        return getPageCalls[ 0 ].resolve({\n            data: [],\n            hasMore: false\n        })\n            .then(() => {\n                assert.strictEqual(executeCalls.length, 0);\n\n                assert.strictEqual(tracker.resolved, true);\n                assert.strictEqual(tracker.rejected, false);\n            });\n    });\n\n    test(\"runs execute once per item if there is only one page\", () => {\n        const { calls: executeCalls, mock: execute } = mockAsync<string, void>();\n        const { calls: getPageCalls, mock: getPage } = mockAsync<{after: string}, ListResponse<{id: string}>>();\n\n        const tracker = checkPromise(executeForAll(getPage, execute));\n\n        assert.strictEqual(getPageCalls.length, 1);\n\n        return getPageCalls[ 0 ].resolve({\n            data: [ { id: \"1\" }, { id: \"2\" } ],\n            hasMore: false\n        })\n            .then(() => {\n                assert.strictEqual(executeCalls.length, 2);\n\n                return Promise.all(executeCalls.map(({ resolve }) => resolve(null)))\n                    .then(() => {\n                        assert.strictEqual(tracker.resolved, true);\n                        assert.strictEqual(tracker.rejected, false);\n                    });\n            });\n    });\n\n    test(\"runs execute once per item if there are two pages\", () => {\n        const { calls: executeCalls, mock: execute } = mockAsync<string, void>();\n        const { calls: getPageCalls, mock: getPage } = mockAsync<{after: string}, ListResponse<{id: string}>>();\n\n        const tracker = checkPromise(executeForAll(getPage, execute));\n\n        assert.strictEqual(getPageCalls.length, 1);\n\n        return getPageCalls[ 0 ].resolve({\n            data: [ { id: \"1\" }, { id: \"2\" } ],\n            hasMore: true\n        })\n            .then(() => {\n                assert.strictEqual(executeCalls.length, 2);\n\n                return Promise.all(executeCalls.map(({ resolve }) => resolve(null)))\n                    .then(() => {\n                        return getPageCalls[ 1 ].resolve({\n                            data: [ { id: \"3\" }, { id: \"4\" } ],\n                            hasMore: false\n                        })\n                            .then(() => {\n                                assert.strictEqual(executeCalls.length, 4);\n\n                                return Promise.all([ executeCalls[ 2 ].resolve(null), executeCalls[ 3 ].resolve(null) ])\n                                    .then(() => {\n                                        assert.strictEqual(tracker.resolved, true);\n                                        assert.strictEqual(tracker.rejected, false);\n                                    });\n                            });\n                    });\n            });\n    });\n\n    test(\"rejects the promise if the first getPage fails\", () => {\n        const { calls: executeCalls, mock: execute } = mockAsync<string, void>();\n        const { calls: getPageCalls, mock: getPage } = mockAsync<{ after: string }, ListResponse<{ id: string }>>();\n\n        const tracker = checkPromise(executeForAll(getPage, execute));\n\n        assert.strictEqual(getPageCalls.length, 1);\n\n        return getPageCalls[0].reject()\n            .then(() => {\n                assert.strictEqual(executeCalls.length, 0);\n\n                assert.strictEqual(tracker.resolved, false);\n                assert.strictEqual(tracker.rejected, true);\n            });\n    });\n\n    test(\"rejects the promise if an execute call fails\", () => {\n        const { calls: executeCalls, mock: execute } = mockAsync<string, void>();\n        const { calls: getPageCalls, mock: getPage } = mockAsync<{ after: string }, ListResponse<{ id: string }>>();\n\n        const tracker = checkPromise(executeForAll(getPage, execute));\n\n        assert.strictEqual(getPageCalls.length, 1);\n\n        return getPageCalls[ 0 ].resolve({\n            data: [ { id: \"1\" }, { id: \"2\" } ],\n            hasMore: true\n        })\n            .then(() => {\n                assert.strictEqual(executeCalls.length, 2);\n\n                return Promise.all([ executeCalls[ 0 ].resolve(null), executeCalls[ 1 ].reject() ])\n                    .then(() => {\n                        assert.strictEqual(tracker.resolved, false);\n                        assert.strictEqual(tracker.rejected, true);\n                    });\n            });\n    });\n\n    test(\"rejects the promise if the second getPage fails\", () => {\n        const { calls: executeCalls, mock: execute } = mockAsync<string, void>();\n        const { calls: getPageCalls, mock: getPage } = mockAsync<{ after: string }, ListResponse<{ id: string }>>();\n\n        const tracker = checkPromise(executeForAll(getPage, execute));\n\n        assert.strictEqual(getPageCalls.length, 1);\n\n        return getPageCalls[0].resolve({\n            data: [ { id: \"1\" }, { id: \"2\" } ],\n            hasMore: true\n        })\n            .then(() => {\n                assert.strictEqual(executeCalls.length, 2);\n\n                return Promise.all([ executeCalls[0].resolve(null), executeCalls[1].resolve(null) ])\n                    .then(() => {\n                        assert.strictEqual(getPageCalls.length, 2);\n\n                        return getPageCalls[1].reject()\n                            .then(() => {\n                                assert.strictEqual(executeCalls.length, 2);\n\n                                assert.strictEqual(tracker.resolved, false);\n                                assert.strictEqual(tracker.rejected, true);\n                            });\n                    });\n            });\n    });\n});\n"],"sourceRoot":"../../lib"}